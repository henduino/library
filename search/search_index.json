{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Selamat Datang di Henduino Library \u00b6 Apa Henduino? \u00b6 Ketika anda membuka halaman situs ini mungkin dalam hati bertanya-tanya, apa itu Henduino? Henduino adalah produk mikrokontroler yang dikembangkan oleh Dede Hendriono dengan dikhususkan pada chip mikrokontroler yang diproduksi oleh perusahaan Atmel dan perusahaan Espressif . Sedangkan konsentrasinya lebih ke turunan Arduino , hal ini agar para Artis Elektronika terbiasa dengan perangkat lunak Arduino IDE. Selain berbasis Arduino, Henduino juga membuat beberapa papan mikrokontroler dengan basis ESP baik ESP8266 maupun ESP32 yang terkenal murah, mudah dan berdaya guna. Namun ada beberapa proyek yang dibuat oleh tim Henduino keluar dari 2 basis mikrokontroler tersebut. Sedangkan situs ini merupakan arsip atau perpustakaan tim Henduino, jadi apa yang tertulis disini bisa berupa ide, rencana, yang sedang dikembangkan atau bahkan produk yang siap untuk digunakan. Apa saja? Ikuti saja perkembangannya disitus ini. :D Kenapa Arduino dan ESP? \u00b6 Henduino menggunakan basis Arduino dan ESP karena memang papan mikrokontroler ini merupakan papan yang sangat populer baik di Indonesia maupun didunia. Perkembangannya yang pesat telah melahirkan berbagai perangkat keras yang berdaya guna baik untuk kesenangan maupun untuk menghadapi proyek sesungguhnya yang bisa diterapkan sesuai kebutuhan dan tentunya bernilai bisnis yang tinggi. Kebiasaan dan kebutuhan masyarakat dunia yang hampir terbiasa dengan internet membuat produk mikrokontroler hampir dimiliki oleh setiap orang didunia. Disadari atau pun tidak disekitar kita hampir beberapa jenis perangkat itu dibuat dengan basis mikrokontroler, misal remote, sistem pengaman rumah, pembaca suhu dan lain sebagainya. Ini membuat geliat para artis elektronika semakin semangat dan pertumbuhannya semakin banyak, membuat para artis elektronika tidak memiliki pilihan kecuali ikut terjun untuk berkecimpung dalam pengembangan dunia mikrokontroler. Henduino merupakan bagian kecil dari kepedulian terhadap perkembangan mikrokontroler tersebut. Ini sebagai upaya generasi Indonesia untuk menghadap tantangan global perkembangan dunia. Seperti apa Papan Henduino? \u00b6 Papan Henduino dibuat dengan susunan yang mengedepankan kemudahan dan biaya, dengan harapan menjadi Papan Mikrokontroler pertama Indonesia yang murah namun tetap mudah untuk dikembangkan. Walau tidak sempurna namun mudah-mudahan ini mampu jadi pemicu dan membangkitkan kepedulian developer mikrokontroler Indonesia untuk ikut andil terhadap perkembangan dunia mikrokontroler Indonesia. Sebenarnya ada beberapa varian yang sedang dikembangkan tapi karena terbentur masalah pendanaan sehingga baru sedikit yang sudah dibuat dan mulai dikembagkan secara pribadi. Keterbatasan dana ini membuat kami dari tim Henduino baru mampu membuat untuk kebutuhan internal saja tanpa mampu membuat untuk kebutuhan secara umum. Namun bagi siapa saja yang ingin membuat sendiri silahkan ambil datanya dari repository yang kami simpan di GitHub. Beberapa varian Henduino dibuat secara spesifik untuk kebutuhan tertentu yang memudahkan siapa saja untuk membuat proyek mikrokontroler yang langsung siap digunakan. Seperti Henduino R2, HESP IoT R2, dan beberapa varian lainnya. Tunggu terbitnya ya? Apa semua yang dibahas hanya Papan Henduino? \u00b6 Halaman ini bukan halaman khusus Papan Henduino karena hal tersebut tidak relevan dengan semangat open source. Pada halaman ini akan dibahas papan-papan mikrokontroler lain yang memiliki semangat open source, sedangkan papan mikrokontroler yang closed source hanya akan dibahas untuk memancing para pengembang untuk membuat papan lainnya yang memiliki kemampuan sama. Selain papan mikrokontroler pada situs ini juga disertakan perpustakaan ( library ), contoh penggunaan, dan beberapa contoh aplikasinya sehingga memudahkan siapa saja yang ingin belajar mikrokontroler terutama yang berbasis Arduino dan ESP. Dimanakah bisa membeli Papan Henduino? \u00b6 Untuk saat ini Henduino masih dalam tahap pengembangan dan produksi jadi untuk sementara Henduino masih digunakan internal tim Henduino saja. Karena sudah dijelaskan diatas bahwa produksi Henduino membutuhkan dana yang cukup besar dan kami belum memiliki dana sebesar itu. Ini membuat proses produksi masal Papan Henduino menjadi terhambat, dan kami pun belum tahu hingga kapan kami bisa memproduksi Papan Henduino untuk kebutuhan umum. Mudah-mudahan secepatnya, karena itu kami mohon do'anya mudah-mudahan Papan Henduino mampu diproduksi masal dalam waktu dekat. Amin... Bagi yang ingin membuat sendiri Papan Henduino, kami akan membagikannya melalui Repository GitHub dan silahkan dibuat sendiri dengan tujuan non komersil. Setelah membuat bagikan pengalamannya bersama kami untuk membangkitkan semangat tim Henduino. Apa lisensi yang diterapkan pada Papan Henduino? \u00b6 Sudah dijelaskan diawal bahwa Henduino mengambil semangat Arduino sehingga kami pun meneruskan semangat tersebut. Henduino direncanakan menerapkan lisensi sumber terbuka atau Open Source License walau sampai hari ini kami belum mendaftarkannya tapi mudah-mudahan kedepannya kita dapat memperoleh Sertifikat Sumber Terbuka dari Open Source Hardware Association . Lalu apa lisensi Open Source? Dijelaskan dibawah ini mengenai Open Source Software dan Open Source Hardware. Tentang Open Source Software - Wikipedia Open Source atau Sumber Terbuka adalah sistem pengembangan yang tidak dikoordinasi oleh suatu individu/lembaga pusat, tetapi oleh para pelaku yang bekerja sama dengan memanfaatkan kode sumber ( source-code ) yang tersebar dan tersedia bebas (biasanya menggunakan fasilitas komunikasi internet). Pola pengembangan ini mengambil model ala bazaar, sehingga pola Open Source ini memiliki ciri bagi komunitasnya yaitu adanya dorongan yang bersumber dari budaya memberi, yang artinya ketika suatu komunitas menggunakan sebuah program Open Source dan telah menerima sebuah manfaat kemudian akan termotivasi untuk menimbulkan sebuah pertanyaan apa yang bisa pengguna berikan balik kepada orang banyak. Tentang Open Source Hardware - OpenSource Open Hardware atau Open Source Hardware mengacu pada spesifikasi desain objek fisik yang dilisensikan sedemikian rupa sehingga objek tersebut dapat dipelajari, dimodifikasi, dibuat, dan didistribusikan oleh siapa saja. Kode sumber perangkat keras terbuka harus mudah diakses, dan komponen-komponennya lebih mudah bagi siapa saja untuk mendapatkannya. Pada dasarnya, perangkat keras terbuka menghilangkan hambatan umum untuk desain dan pembuatan barang fisik; itu memberikan sebanyak mungkin orang kemampuan untuk membangun, membuat ulang dengan fungsi khusus, dan berbagi pengetahuan mereka tentang desain dan fungsi perangkat keras.","title":"Beranda"},{"location":"#selamat-datang-di-henduino-library","text":"","title":"Selamat Datang di Henduino Library"},{"location":"#apa-henduino","text":"Ketika anda membuka halaman situs ini mungkin dalam hati bertanya-tanya, apa itu Henduino? Henduino adalah produk mikrokontroler yang dikembangkan oleh Dede Hendriono dengan dikhususkan pada chip mikrokontroler yang diproduksi oleh perusahaan Atmel dan perusahaan Espressif . Sedangkan konsentrasinya lebih ke turunan Arduino , hal ini agar para Artis Elektronika terbiasa dengan perangkat lunak Arduino IDE. Selain berbasis Arduino, Henduino juga membuat beberapa papan mikrokontroler dengan basis ESP baik ESP8266 maupun ESP32 yang terkenal murah, mudah dan berdaya guna. Namun ada beberapa proyek yang dibuat oleh tim Henduino keluar dari 2 basis mikrokontroler tersebut. Sedangkan situs ini merupakan arsip atau perpustakaan tim Henduino, jadi apa yang tertulis disini bisa berupa ide, rencana, yang sedang dikembangkan atau bahkan produk yang siap untuk digunakan. Apa saja? Ikuti saja perkembangannya disitus ini. :D","title":"Apa Henduino?"},{"location":"#kenapa-arduino-dan-esp","text":"Henduino menggunakan basis Arduino dan ESP karena memang papan mikrokontroler ini merupakan papan yang sangat populer baik di Indonesia maupun didunia. Perkembangannya yang pesat telah melahirkan berbagai perangkat keras yang berdaya guna baik untuk kesenangan maupun untuk menghadapi proyek sesungguhnya yang bisa diterapkan sesuai kebutuhan dan tentunya bernilai bisnis yang tinggi. Kebiasaan dan kebutuhan masyarakat dunia yang hampir terbiasa dengan internet membuat produk mikrokontroler hampir dimiliki oleh setiap orang didunia. Disadari atau pun tidak disekitar kita hampir beberapa jenis perangkat itu dibuat dengan basis mikrokontroler, misal remote, sistem pengaman rumah, pembaca suhu dan lain sebagainya. Ini membuat geliat para artis elektronika semakin semangat dan pertumbuhannya semakin banyak, membuat para artis elektronika tidak memiliki pilihan kecuali ikut terjun untuk berkecimpung dalam pengembangan dunia mikrokontroler. Henduino merupakan bagian kecil dari kepedulian terhadap perkembangan mikrokontroler tersebut. Ini sebagai upaya generasi Indonesia untuk menghadap tantangan global perkembangan dunia.","title":"Kenapa Arduino dan ESP?"},{"location":"#seperti-apa-papan-henduino","text":"Papan Henduino dibuat dengan susunan yang mengedepankan kemudahan dan biaya, dengan harapan menjadi Papan Mikrokontroler pertama Indonesia yang murah namun tetap mudah untuk dikembangkan. Walau tidak sempurna namun mudah-mudahan ini mampu jadi pemicu dan membangkitkan kepedulian developer mikrokontroler Indonesia untuk ikut andil terhadap perkembangan dunia mikrokontroler Indonesia. Sebenarnya ada beberapa varian yang sedang dikembangkan tapi karena terbentur masalah pendanaan sehingga baru sedikit yang sudah dibuat dan mulai dikembagkan secara pribadi. Keterbatasan dana ini membuat kami dari tim Henduino baru mampu membuat untuk kebutuhan internal saja tanpa mampu membuat untuk kebutuhan secara umum. Namun bagi siapa saja yang ingin membuat sendiri silahkan ambil datanya dari repository yang kami simpan di GitHub. Beberapa varian Henduino dibuat secara spesifik untuk kebutuhan tertentu yang memudahkan siapa saja untuk membuat proyek mikrokontroler yang langsung siap digunakan. Seperti Henduino R2, HESP IoT R2, dan beberapa varian lainnya. Tunggu terbitnya ya?","title":"Seperti apa Papan Henduino?"},{"location":"#apa-semua-yang-dibahas-hanya-papan-henduino","text":"Halaman ini bukan halaman khusus Papan Henduino karena hal tersebut tidak relevan dengan semangat open source. Pada halaman ini akan dibahas papan-papan mikrokontroler lain yang memiliki semangat open source, sedangkan papan mikrokontroler yang closed source hanya akan dibahas untuk memancing para pengembang untuk membuat papan lainnya yang memiliki kemampuan sama. Selain papan mikrokontroler pada situs ini juga disertakan perpustakaan ( library ), contoh penggunaan, dan beberapa contoh aplikasinya sehingga memudahkan siapa saja yang ingin belajar mikrokontroler terutama yang berbasis Arduino dan ESP.","title":"Apa semua yang dibahas hanya Papan Henduino?"},{"location":"#dimanakah-bisa-membeli-papan-henduino","text":"Untuk saat ini Henduino masih dalam tahap pengembangan dan produksi jadi untuk sementara Henduino masih digunakan internal tim Henduino saja. Karena sudah dijelaskan diatas bahwa produksi Henduino membutuhkan dana yang cukup besar dan kami belum memiliki dana sebesar itu. Ini membuat proses produksi masal Papan Henduino menjadi terhambat, dan kami pun belum tahu hingga kapan kami bisa memproduksi Papan Henduino untuk kebutuhan umum. Mudah-mudahan secepatnya, karena itu kami mohon do'anya mudah-mudahan Papan Henduino mampu diproduksi masal dalam waktu dekat. Amin... Bagi yang ingin membuat sendiri Papan Henduino, kami akan membagikannya melalui Repository GitHub dan silahkan dibuat sendiri dengan tujuan non komersil. Setelah membuat bagikan pengalamannya bersama kami untuk membangkitkan semangat tim Henduino.","title":"Dimanakah bisa membeli Papan Henduino?"},{"location":"#apa-lisensi-yang-diterapkan-pada-papan-henduino","text":"Sudah dijelaskan diawal bahwa Henduino mengambil semangat Arduino sehingga kami pun meneruskan semangat tersebut. Henduino direncanakan menerapkan lisensi sumber terbuka atau Open Source License walau sampai hari ini kami belum mendaftarkannya tapi mudah-mudahan kedepannya kita dapat memperoleh Sertifikat Sumber Terbuka dari Open Source Hardware Association . Lalu apa lisensi Open Source? Dijelaskan dibawah ini mengenai Open Source Software dan Open Source Hardware. Tentang Open Source Software - Wikipedia Open Source atau Sumber Terbuka adalah sistem pengembangan yang tidak dikoordinasi oleh suatu individu/lembaga pusat, tetapi oleh para pelaku yang bekerja sama dengan memanfaatkan kode sumber ( source-code ) yang tersebar dan tersedia bebas (biasanya menggunakan fasilitas komunikasi internet). Pola pengembangan ini mengambil model ala bazaar, sehingga pola Open Source ini memiliki ciri bagi komunitasnya yaitu adanya dorongan yang bersumber dari budaya memberi, yang artinya ketika suatu komunitas menggunakan sebuah program Open Source dan telah menerima sebuah manfaat kemudian akan termotivasi untuk menimbulkan sebuah pertanyaan apa yang bisa pengguna berikan balik kepada orang banyak. Tentang Open Source Hardware - OpenSource Open Hardware atau Open Source Hardware mengacu pada spesifikasi desain objek fisik yang dilisensikan sedemikian rupa sehingga objek tersebut dapat dipelajari, dimodifikasi, dibuat, dan didistribusikan oleh siapa saja. Kode sumber perangkat keras terbuka harus mudah diakses, dan komponen-komponennya lebih mudah bagi siapa saja untuk mendapatkannya. Pada dasarnya, perangkat keras terbuka menghilangkan hambatan umum untuk desain dan pembuatan barang fisik; itu memberikan sebanyak mungkin orang kemampuan untuk membangun, membuat ulang dengan fungsi khusus, dan berbagi pengetahuan mereka tentang desain dan fungsi perangkat keras.","title":"Apa lisensi yang diterapkan pada Papan Henduino?"},{"location":"tentang/","text":"Tentang Henduino Library \u00b6 Penamaan Henduino \u00b6 Nama Henduino diambil dari nama pendirinya yaitu Dede Hendriono yang kemudian nama tersebut di ambil kata HEND sedangkan kata selanjutnya diambil dari papan Arduino yang diambil penggalan katanya yaitu UINO , sehingga ketika digabungkan menjadi HENDUINO dan ini dirasa tepat. Itu saja... Tidak ada sejarah khusus dalam penamaan Papan Henduino. Penamaan Henduino Library \u00b6 Henduino Library bukanlah perpustakaan papan Henduino tapi lebih ke perpustakaan yang selama ini dikumpulkan dan berserakan didalam komputer. Karena keterserakan tersebutlah muncul keinginan untuk mengarsipkan agar suatu hari nanti ketika membutuhkan sesuatu masih tersedia secara online, selain itu agar siapa saja bisa ikut mengembangkan sehingga terbentuk jaringan yang kuat dalam perjalanannya. Entah akan seperti apa Henduino suatu hari? Apakah akan menjadi papan yang bermanfaat atau justru tenggelam ditengah-tengah hiruk pikuk teknologi. Hanya optimisme untuk berbagi itulah yang membuat kami merasa perlu untuk membagikan apa yang kami pelajari, kami hadapi, kami rasakan agar minimal kesulitan kami dalam belajar mikrokontroler bisa diambil hikmahnya oleh siapa saja yang akan dan sedang belajar mikrokontroler. Tim Henduino \u00b6 Berapakah tim Henduino? Tim Henduino hanya satu dan sampai hari ini juga masih satu orang yaitu Dede Hendriono, namun saya secara pribadi berharap suatu hari nanti ada yang mau berkontribusi dalam pengemabangannya. Baik kontribusi dalam bentuk ilmu, perangkat keras, dana, tempat atau yang lainnya. Munculnya situs ini hanya untuk memancing seberapa peduli masyarakat dan seberapa antusias generasi dalam belajar teknologi. Walau sendirian dalam mengelola situs, sendiri dalam membuat papan Henduino yang tentunya dengan biaya mandiri pula tanpa ( belum ) ada campur tangan pihak lain, namun keinginan untuk berbagi tetap ada. Saya sadar bahwa tidak mudah dalam membangun sebuah tim yang solid namun minimal ada keinginan untuk mengumpulkan orang-orang yang peduli dengan perkembangan mikrokontroler Indonesia dan peduli terhadap kelangsungan generasi berikutnya dalam menghadapi tantangan perkembangan teknologi terutama dunia mikrokontroler. Tentang Situs \u00b6 Pertanyaan tentang situs sebenarnya tidak terlalu penting untuk ditulis, namun tetap saja ada yang penasaran. Artikel pada situs ini ditulis dengan bahasa Markdown sehingga menjadi situs dengan tipe static page atau halaman statis yang disimpan pada penyedia repository GitHub . Sedangkan tool yang digunakan untuk meng- generate -nya adalah MkDocs . Pilihan jatuh pada halaman statis karena jika suatu hari penyedia layanan tutup, tim masih memiliki salinannya dalam format HTML yang masih bisa dibaca secara luring ( offline ) tanpa bantuan alat yang rumit.","title":"Tentang"},{"location":"tentang/#tentang-henduino-library","text":"","title":"Tentang Henduino Library"},{"location":"tentang/#penamaan-henduino","text":"Nama Henduino diambil dari nama pendirinya yaitu Dede Hendriono yang kemudian nama tersebut di ambil kata HEND sedangkan kata selanjutnya diambil dari papan Arduino yang diambil penggalan katanya yaitu UINO , sehingga ketika digabungkan menjadi HENDUINO dan ini dirasa tepat. Itu saja... Tidak ada sejarah khusus dalam penamaan Papan Henduino.","title":"Penamaan Henduino"},{"location":"tentang/#penamaan-henduino-library","text":"Henduino Library bukanlah perpustakaan papan Henduino tapi lebih ke perpustakaan yang selama ini dikumpulkan dan berserakan didalam komputer. Karena keterserakan tersebutlah muncul keinginan untuk mengarsipkan agar suatu hari nanti ketika membutuhkan sesuatu masih tersedia secara online, selain itu agar siapa saja bisa ikut mengembangkan sehingga terbentuk jaringan yang kuat dalam perjalanannya. Entah akan seperti apa Henduino suatu hari? Apakah akan menjadi papan yang bermanfaat atau justru tenggelam ditengah-tengah hiruk pikuk teknologi. Hanya optimisme untuk berbagi itulah yang membuat kami merasa perlu untuk membagikan apa yang kami pelajari, kami hadapi, kami rasakan agar minimal kesulitan kami dalam belajar mikrokontroler bisa diambil hikmahnya oleh siapa saja yang akan dan sedang belajar mikrokontroler.","title":"Penamaan Henduino Library"},{"location":"tentang/#tim-henduino","text":"Berapakah tim Henduino? Tim Henduino hanya satu dan sampai hari ini juga masih satu orang yaitu Dede Hendriono, namun saya secara pribadi berharap suatu hari nanti ada yang mau berkontribusi dalam pengemabangannya. Baik kontribusi dalam bentuk ilmu, perangkat keras, dana, tempat atau yang lainnya. Munculnya situs ini hanya untuk memancing seberapa peduli masyarakat dan seberapa antusias generasi dalam belajar teknologi. Walau sendirian dalam mengelola situs, sendiri dalam membuat papan Henduino yang tentunya dengan biaya mandiri pula tanpa ( belum ) ada campur tangan pihak lain, namun keinginan untuk berbagi tetap ada. Saya sadar bahwa tidak mudah dalam membangun sebuah tim yang solid namun minimal ada keinginan untuk mengumpulkan orang-orang yang peduli dengan perkembangan mikrokontroler Indonesia dan peduli terhadap kelangsungan generasi berikutnya dalam menghadapi tantangan perkembangan teknologi terutama dunia mikrokontroler.","title":"Tim Henduino"},{"location":"tentang/#tentang-situs","text":"Pertanyaan tentang situs sebenarnya tidak terlalu penting untuk ditulis, namun tetap saja ada yang penasaran. Artikel pada situs ini ditulis dengan bahasa Markdown sehingga menjadi situs dengan tipe static page atau halaman statis yang disimpan pada penyedia repository GitHub . Sedangkan tool yang digunakan untuk meng- generate -nya adalah MkDocs . Pilihan jatuh pada halaman statis karena jika suatu hari penyedia layanan tutup, tim masih memiliki salinannya dalam format HTML yang masih bisa dibaca secara luring ( offline ) tanpa bantuan alat yang rumit.","title":"Tentang Situs"},{"location":"blog/2019/internet-sumber-belajar/","text":"Internet Sebagai Sumber Belajar \u00b6 Internet merupakan salah satu perkembangan teknologi informasi bukanlah sesuatu yang eksklusif bahkan sudah menjadi suatu hal yang biasa bagi masyarakat Indonesia saat ini. Bahkan beberapa provider (perusahaan penyedia layanan internet) telah merambah kedaerah terpencil dalam memberikan layanan jaringan internet. Ini mempermudah bagi siapa saja dan dimana saja untuk mengakses internet. Undangan, informasi, berita dan berbagai kejadian dibelahan dunia satu dapat langsung diterima dibelahan bumi lainnya. Perkembangan teknologi informasi ini mampu menekan biaya dan waktu menjadi lebih murah, mudah dan cepat. Perilaku Didepan Internet \u00b6 Kemudahan yang diberikan internet tidaklah serta merta membuat para pelaku pendidikan menjadikan internet ini sebagai salah satu sarana yang mampu mengakselerasi proses transfer ilmu kepada peserta didiknya tapi justru memunculkan masalah baru. Banyaknya waktu yang terbuang oleh guru, siswa dan pelaku pendidik justru membalikan fungsi internet yang sedianya sebagai sumber belajar menjadi hanya sebagai sarana hiburan semata. Sangatlah wajar jika kemudian badan statistik dunia menempatkan Indonesia sebagai negara yang paling boros bandwidth dan waktu hanya sekedar untuk mencari sesuatu hal yang tidaklah penting dan bahkan apa yang dilakukan didepan internet tidak ada kaitannya dengan profesi yang dimiliki. Perhatikan di sekitar kita ketika seorang guru tersenyum-senyum bahkan tertawa lepas didepan monitor tanpa ada seorang teman pun disampingnya. Atau perhatikanlah siswa-siswi kita yang justru sibuk membuat status dan membalas komentar-komentar yang sama sekali tidak ada hubungannya dengan pelajaran yang sedang dihadapi. Beberapa contoh inilah yang justru kemudian membuat internet menjadi tidaklah efektif dan efisien sebagai sumber belajar. Dalih sebagai hiburan menjadikan seseorang \u201c kebablasan \u201d tanpa disadarinya. Tingkah laku negatif didepan internet akan mempengaruhi tingkah laku yang aneh pula didunia nyata, bahkan mampu merubah cara berfikir seseorang. Tips Memanfaatkan Internet \u00b6 Dibawah ini beberapa tips bagi para pendidik agar tidak terjerumus dalam maraknya dunia internet dengan harapan akan mampu memanfaatkan internet secara maksimal sebagai sumber belajar. Buatlah jadwal khusus untuk bermain internet. Jadwal akan memaksa kita untuk melakukan suatu kegiatan menjadi seefektif dan seefisiensi mungkin serta mengurangi perilaku negatif yang akan membuat jadwal internet kita menjadi membengkak. Kumpulkan, susun dan pilihlah kata kunci spesifik yang akan kita gunakan dalam mencari sumber belajar. Maraknya situs sampah akhir-akhir ini membuat proses pencarian menjadi sulit ditemukan maka hindarilah menggunakan kata kunci umum untuk mencari suatu sumber belajar. Belajar dan buatlah blog sebagai salah satu catatan untuk menyimpan arsip-arsip dan atau sebagai administrasi dalam menjalankan profesi guru. Pengarsipan administrasi dalam bentuk hardcopy memiliki banyak kelemahan, diantaranya; Memerlukan tempat yang relatif luas, Sulit dan lama jika ingin membuka-buka arsip lama, Mudah hilang. Jika arsip tersebut disimpan pada media blog maka orang lain juga berkesempatan untuk membaca sebagai bahan kajian mereka ataupun sekedar referensi dan ikut membantu menemukan kekurangannya. Bergabunglah di grup, forum atau milis guru sebagai sarana diskusi antar para pendidik. Dengan begitu guru akan mudah untuk menyampaikan masalah, pengalaman dan idenya selama menjalankan profesinya. Dan bahkan mampu membuka wawasan guru tentang dunia pendidikan secara luas ketika terhubung dengan guru-guru lain yang datang dari berbagai latar permasalahan dan pengalaman. Buatlah \u201c review \u201d untuk siswa terhadap suatu situs yang pernah guru kunjungi. Hal ini sangat bermanfaat bagi guru atau pun siswa dalam belajar suatu materi yang mungkin saja hal itu sangatlah sulit untuk disampaikan dikelas dan hanya mampu dijabarkan melalui penelitian siswa sendiri dengan referensi yang kita berikan melalui review situs yang guru berikan. Buatlah grup khusus mata pelajaran yang guru ajarkan sebagai sarana diskusi bersama, hal ini untuk memfasilitasi bagi siswa-siswa yang sulit mengungkapkan permasalahnya secara langsung melalui pertanyaan dikelas atau untuk menyelesaikan pertanyaan dan atau masalah yang kemudian ditemukan ketika para siswa belajar diluar kelas. Jadilah guru yang benar-benar profesional dengan mampu menggunakan berbagai fasilitas yang sudah tersedia seperti halnya internet sebagai sumber belajar sehingga proses transfer ilmu menjadi lebih efektif dan efesien tentunya dengan harapan tujuan mulia pendidikan akan tercapai dengan waktu relatif singkat tanpa harus mengeluarkan biaya yang mahal.","title":"Internet Sumber Belajar"},{"location":"blog/2019/internet-sumber-belajar/#internet-sebagai-sumber-belajar","text":"Internet merupakan salah satu perkembangan teknologi informasi bukanlah sesuatu yang eksklusif bahkan sudah menjadi suatu hal yang biasa bagi masyarakat Indonesia saat ini. Bahkan beberapa provider (perusahaan penyedia layanan internet) telah merambah kedaerah terpencil dalam memberikan layanan jaringan internet. Ini mempermudah bagi siapa saja dan dimana saja untuk mengakses internet. Undangan, informasi, berita dan berbagai kejadian dibelahan dunia satu dapat langsung diterima dibelahan bumi lainnya. Perkembangan teknologi informasi ini mampu menekan biaya dan waktu menjadi lebih murah, mudah dan cepat.","title":"Internet Sebagai Sumber Belajar"},{"location":"blog/2019/internet-sumber-belajar/#perilaku-didepan-internet","text":"Kemudahan yang diberikan internet tidaklah serta merta membuat para pelaku pendidikan menjadikan internet ini sebagai salah satu sarana yang mampu mengakselerasi proses transfer ilmu kepada peserta didiknya tapi justru memunculkan masalah baru. Banyaknya waktu yang terbuang oleh guru, siswa dan pelaku pendidik justru membalikan fungsi internet yang sedianya sebagai sumber belajar menjadi hanya sebagai sarana hiburan semata. Sangatlah wajar jika kemudian badan statistik dunia menempatkan Indonesia sebagai negara yang paling boros bandwidth dan waktu hanya sekedar untuk mencari sesuatu hal yang tidaklah penting dan bahkan apa yang dilakukan didepan internet tidak ada kaitannya dengan profesi yang dimiliki. Perhatikan di sekitar kita ketika seorang guru tersenyum-senyum bahkan tertawa lepas didepan monitor tanpa ada seorang teman pun disampingnya. Atau perhatikanlah siswa-siswi kita yang justru sibuk membuat status dan membalas komentar-komentar yang sama sekali tidak ada hubungannya dengan pelajaran yang sedang dihadapi. Beberapa contoh inilah yang justru kemudian membuat internet menjadi tidaklah efektif dan efisien sebagai sumber belajar. Dalih sebagai hiburan menjadikan seseorang \u201c kebablasan \u201d tanpa disadarinya. Tingkah laku negatif didepan internet akan mempengaruhi tingkah laku yang aneh pula didunia nyata, bahkan mampu merubah cara berfikir seseorang.","title":"Perilaku Didepan Internet"},{"location":"blog/2019/internet-sumber-belajar/#tips-memanfaatkan-internet","text":"Dibawah ini beberapa tips bagi para pendidik agar tidak terjerumus dalam maraknya dunia internet dengan harapan akan mampu memanfaatkan internet secara maksimal sebagai sumber belajar. Buatlah jadwal khusus untuk bermain internet. Jadwal akan memaksa kita untuk melakukan suatu kegiatan menjadi seefektif dan seefisiensi mungkin serta mengurangi perilaku negatif yang akan membuat jadwal internet kita menjadi membengkak. Kumpulkan, susun dan pilihlah kata kunci spesifik yang akan kita gunakan dalam mencari sumber belajar. Maraknya situs sampah akhir-akhir ini membuat proses pencarian menjadi sulit ditemukan maka hindarilah menggunakan kata kunci umum untuk mencari suatu sumber belajar. Belajar dan buatlah blog sebagai salah satu catatan untuk menyimpan arsip-arsip dan atau sebagai administrasi dalam menjalankan profesi guru. Pengarsipan administrasi dalam bentuk hardcopy memiliki banyak kelemahan, diantaranya; Memerlukan tempat yang relatif luas, Sulit dan lama jika ingin membuka-buka arsip lama, Mudah hilang. Jika arsip tersebut disimpan pada media blog maka orang lain juga berkesempatan untuk membaca sebagai bahan kajian mereka ataupun sekedar referensi dan ikut membantu menemukan kekurangannya. Bergabunglah di grup, forum atau milis guru sebagai sarana diskusi antar para pendidik. Dengan begitu guru akan mudah untuk menyampaikan masalah, pengalaman dan idenya selama menjalankan profesinya. Dan bahkan mampu membuka wawasan guru tentang dunia pendidikan secara luas ketika terhubung dengan guru-guru lain yang datang dari berbagai latar permasalahan dan pengalaman. Buatlah \u201c review \u201d untuk siswa terhadap suatu situs yang pernah guru kunjungi. Hal ini sangat bermanfaat bagi guru atau pun siswa dalam belajar suatu materi yang mungkin saja hal itu sangatlah sulit untuk disampaikan dikelas dan hanya mampu dijabarkan melalui penelitian siswa sendiri dengan referensi yang kita berikan melalui review situs yang guru berikan. Buatlah grup khusus mata pelajaran yang guru ajarkan sebagai sarana diskusi bersama, hal ini untuk memfasilitasi bagi siswa-siswa yang sulit mengungkapkan permasalahnya secara langsung melalui pertanyaan dikelas atau untuk menyelesaikan pertanyaan dan atau masalah yang kemudian ditemukan ketika para siswa belajar diluar kelas. Jadilah guru yang benar-benar profesional dengan mampu menggunakan berbagai fasilitas yang sudah tersedia seperti halnya internet sebagai sumber belajar sehingga proses transfer ilmu menjadi lebih efektif dan efesien tentunya dengan harapan tujuan mulia pendidikan akan tercapai dengan waktu relatif singkat tanpa harus mengeluarkan biaya yang mahal.","title":"Tips Memanfaatkan Internet"},{"location":"blog/2019/prinsip-atm-belajar/","text":"Prinsip ATM Dalam Pembelajaran \u00b6 Proses Belajar Mengajar di kelas harusnya menjadi sarana yang paling tepat untuk mentransfer ilmu bahkan menjadi ibadah dengan pahala yang tak akan terputus. Namun kenyataan dilapangan para guru dan para siswa seperti terjebak pada rutinitas yang membuat proses transfer ilmu tidak bisa maksimal. Siswa merasa jenuh dengan proses belajar mengajar yang dihadapinya yang seakan tidak memberikan sesuatu yang menantang bagi mereka. Pun demikian dengan para guru, seakan mereka hanya sekedar menjalankan kewajibannya sebagai guru tanpa ada semangat sedikitpun untuk bisa melakukan inovasi pendidikan ke arah lebih baik. Prinsip ATM ( Amati Tiru Modifikasi ) merupakan salah satu teknik pembelajaran yang cukup menantang sekarang ini terutama pada dunia teknologi yang terus berkembang sangat pesat. Selangkah demi selangkah kita menjadi tertinggal sangat jauh bahkan menjadi hal yang tak mungkin untuk mengejar perkembangan teknologi tersebut. Lalu apa prinsip Amati Tiru Modifikasi dalam pembelajaran itu. Paradigma Dunia Pendidikan \u00b6 Paradigma baru dunia pendidikan Indonesia telah menggeser peran guru dan siswa dalam kegiatan belajar mengajar. Semula guru merupakan sumber segala informasi, seiring perkembangan ilmu pengetahuan dan teknologi sekarang guru berperan sebagai fasilitator, tutor dan sekaligus pembelajar. Sedangkan siswa bukan lagi pengingat fakta dan prinsip tetapi berperan sebagai periset, problem-solver, dan pembuat strategi. Sebuah studi menunjukan bahwa setelah 1982 ketika seorang anak mencapai umur 21 tahun mereka banyak sekali membuang-buang waktu untuk melakukan hal-hal yang tidak penting diantaranya; 10.000 jam bermain game, 20.000 jam menonton televisi, mengirim 200.000 email, dan 10.000 jam menggunakan telepon genggam, tetapi justru hanya meluangkan waktu kurang dari 5.000 jam untuk membaca ( Oblinger D, Educating the Next Generation \u2013 Educause Denver 2004. October 2004 ). Prinsip ATM ( Amati, Tiru, Modifikasi ) dalam pembelajaran diharapkan mampu menggali potensi dari setiap unsur yang telibat dalam proses pendidikan secara maksimal agar mampu berkembang lebih maju dan mampu mengurangi perilaku negatif yang dapat membuang waktu. Prinsip ATM dalam pembelajaran tidak hanya berlaku untuk siswa tetapi untuk semua unsur yang terlibat dalam pendidikan terutama guru sebagai ujung tombak proses belajar mengajar. (A) Amati \u00b6 Guru dan siswa haruslah memiliki prinsip \"amati\" terhadap segala hal yang berhubungan dengan disiplin ilmu yang sedang dipelajarinya. Hal ini untuk memupuk rasa keingintahuan terhadap sesuatu yang berhubungan dengan disiplin ilmu yang dimiliki dan dipelajarinya. Apalagi guru yang memiliki peran penting untuk membantu anak didiknya agar memiliki kemampuan pengamatan terhadap sesuatu yang berhubungan dengan suatu materi pembelajaran. Pengamatan akan menimbulkan rasa keingintahuan terhadap sesuatu, hal ini akan meningkatkan minat belajar dan kemampuan untuk menemukan metode belajar yang terbaik. Rasa ingin tahu akan meningkatkan kualitas belajar seseorang dan meningkatkan kwantitas waktu belajarnya sehingga proses pembelajaran dengan sendirinya akan terjadi di dalam dan di luar kelas, di sekolah dan di lingkungannya, bahkan saat bermainpun akan digunakan sebagai salah satu cara untuk belajar. (T) Tiru \u00b6 Prinsip tiru adalah lanjutan dari prinsip amati yang lahir dari dalam diri sendiri ketika dirasa sudah memahami sesuatu dari hasil pengamatan yang dilakukan. Meniru merupakan tindakan yang kemudian dilakukan ketika seseorang telah merasa mampu secara teori maupun praktek terhadap sesuatu. Kebanggaan akan muncul ketika seseorang mampu meniru sesuatu hal yang mirip dengan aslinya, rasa bangga ini akan meningkatkan keingintahuan secara menyeluruh untuk menemukan berbagai kelemahan yang ada pada sesuatu yang telah ditirunya. Sehingga proses belajar mengajar akan terbentuk sebagai suatu kegiatan yang menyenangkan karena keinginan meniru akan menciptakan suasana yang kondusif dan aktif bagi mereka yang terlibat dalam proses pembelajaran baik guru maupun siswa. (M) Modifikasi \u00b6 Setelah melakukan pengamatan dan peniruan maka prinsip selanjutnya adalah prinsip modifikasi. Hal ini penting sebagai langkah lanjutan dalam pembelajaran, karena sebagian orang terjebak sampai pada prinsip \"tiru\" sehingga akan melahirkan para \"pembajak\". Meniru sesuatu sesuai dengan aslinya merupakan tindakan tidak terpuji jika hal tersebut kemudian dilakukan untuk menghasilkan suatu keuntungan bagi pribadi yang meniru. Maka hindari pembelajaran terhenti sampai dengan prinsip \"tiru\" agar generasi kita tidak menjadi generasi pembajak. Ketika seseorang telah mampu meniru sesuatu sesuai dengan aslinya maka selanjutnya harus mampu menemukan dan memperbaiki berbagai kelemahan yang ditemukan dari sesuatu yang ditirunya dan kemudian menciptakan sesuatu yang baru sebagai hasil modifikasi (perbaikan) dengan hasil yang lebih baik (sempurna) daripada aslinya. Galileo Galilei Anda tidak dapat mengajari orang apapun juga; anda hanya dapat membantu dirinya untuk menemukannya sendiri. Maka dari itu prinsip ATM janganlah berlaku sepihak hanya untuk siswa tetapi semua elemen yang terlibat dalam proses pembelajaran. Integrasi prinsip ATM pada pembelajaran akan mampu menciptakan proses belajar mengajar yang menyenangkan, dinamis, aktif dan kreatif bagi mereka yang terlibat, baik didalam maupun diluar sekolah sehingga proses transfer ilmu akan berjalan dengan waktu yang relatif singkat.","title":"Prinsip ATM Belajar"},{"location":"blog/2019/prinsip-atm-belajar/#prinsip-atm-dalam-pembelajaran","text":"Proses Belajar Mengajar di kelas harusnya menjadi sarana yang paling tepat untuk mentransfer ilmu bahkan menjadi ibadah dengan pahala yang tak akan terputus. Namun kenyataan dilapangan para guru dan para siswa seperti terjebak pada rutinitas yang membuat proses transfer ilmu tidak bisa maksimal. Siswa merasa jenuh dengan proses belajar mengajar yang dihadapinya yang seakan tidak memberikan sesuatu yang menantang bagi mereka. Pun demikian dengan para guru, seakan mereka hanya sekedar menjalankan kewajibannya sebagai guru tanpa ada semangat sedikitpun untuk bisa melakukan inovasi pendidikan ke arah lebih baik. Prinsip ATM ( Amati Tiru Modifikasi ) merupakan salah satu teknik pembelajaran yang cukup menantang sekarang ini terutama pada dunia teknologi yang terus berkembang sangat pesat. Selangkah demi selangkah kita menjadi tertinggal sangat jauh bahkan menjadi hal yang tak mungkin untuk mengejar perkembangan teknologi tersebut. Lalu apa prinsip Amati Tiru Modifikasi dalam pembelajaran itu.","title":"Prinsip ATM Dalam Pembelajaran"},{"location":"blog/2019/prinsip-atm-belajar/#paradigma-dunia-pendidikan","text":"Paradigma baru dunia pendidikan Indonesia telah menggeser peran guru dan siswa dalam kegiatan belajar mengajar. Semula guru merupakan sumber segala informasi, seiring perkembangan ilmu pengetahuan dan teknologi sekarang guru berperan sebagai fasilitator, tutor dan sekaligus pembelajar. Sedangkan siswa bukan lagi pengingat fakta dan prinsip tetapi berperan sebagai periset, problem-solver, dan pembuat strategi. Sebuah studi menunjukan bahwa setelah 1982 ketika seorang anak mencapai umur 21 tahun mereka banyak sekali membuang-buang waktu untuk melakukan hal-hal yang tidak penting diantaranya; 10.000 jam bermain game, 20.000 jam menonton televisi, mengirim 200.000 email, dan 10.000 jam menggunakan telepon genggam, tetapi justru hanya meluangkan waktu kurang dari 5.000 jam untuk membaca ( Oblinger D, Educating the Next Generation \u2013 Educause Denver 2004. October 2004 ). Prinsip ATM ( Amati, Tiru, Modifikasi ) dalam pembelajaran diharapkan mampu menggali potensi dari setiap unsur yang telibat dalam proses pendidikan secara maksimal agar mampu berkembang lebih maju dan mampu mengurangi perilaku negatif yang dapat membuang waktu. Prinsip ATM dalam pembelajaran tidak hanya berlaku untuk siswa tetapi untuk semua unsur yang terlibat dalam pendidikan terutama guru sebagai ujung tombak proses belajar mengajar.","title":"Paradigma Dunia Pendidikan"},{"location":"blog/2019/prinsip-atm-belajar/#a-amati","text":"Guru dan siswa haruslah memiliki prinsip \"amati\" terhadap segala hal yang berhubungan dengan disiplin ilmu yang sedang dipelajarinya. Hal ini untuk memupuk rasa keingintahuan terhadap sesuatu yang berhubungan dengan disiplin ilmu yang dimiliki dan dipelajarinya. Apalagi guru yang memiliki peran penting untuk membantu anak didiknya agar memiliki kemampuan pengamatan terhadap sesuatu yang berhubungan dengan suatu materi pembelajaran. Pengamatan akan menimbulkan rasa keingintahuan terhadap sesuatu, hal ini akan meningkatkan minat belajar dan kemampuan untuk menemukan metode belajar yang terbaik. Rasa ingin tahu akan meningkatkan kualitas belajar seseorang dan meningkatkan kwantitas waktu belajarnya sehingga proses pembelajaran dengan sendirinya akan terjadi di dalam dan di luar kelas, di sekolah dan di lingkungannya, bahkan saat bermainpun akan digunakan sebagai salah satu cara untuk belajar.","title":"(A) Amati"},{"location":"blog/2019/prinsip-atm-belajar/#t-tiru","text":"Prinsip tiru adalah lanjutan dari prinsip amati yang lahir dari dalam diri sendiri ketika dirasa sudah memahami sesuatu dari hasil pengamatan yang dilakukan. Meniru merupakan tindakan yang kemudian dilakukan ketika seseorang telah merasa mampu secara teori maupun praktek terhadap sesuatu. Kebanggaan akan muncul ketika seseorang mampu meniru sesuatu hal yang mirip dengan aslinya, rasa bangga ini akan meningkatkan keingintahuan secara menyeluruh untuk menemukan berbagai kelemahan yang ada pada sesuatu yang telah ditirunya. Sehingga proses belajar mengajar akan terbentuk sebagai suatu kegiatan yang menyenangkan karena keinginan meniru akan menciptakan suasana yang kondusif dan aktif bagi mereka yang terlibat dalam proses pembelajaran baik guru maupun siswa.","title":"(T) Tiru"},{"location":"blog/2019/prinsip-atm-belajar/#m-modifikasi","text":"Setelah melakukan pengamatan dan peniruan maka prinsip selanjutnya adalah prinsip modifikasi. Hal ini penting sebagai langkah lanjutan dalam pembelajaran, karena sebagian orang terjebak sampai pada prinsip \"tiru\" sehingga akan melahirkan para \"pembajak\". Meniru sesuatu sesuai dengan aslinya merupakan tindakan tidak terpuji jika hal tersebut kemudian dilakukan untuk menghasilkan suatu keuntungan bagi pribadi yang meniru. Maka hindari pembelajaran terhenti sampai dengan prinsip \"tiru\" agar generasi kita tidak menjadi generasi pembajak. Ketika seseorang telah mampu meniru sesuatu sesuai dengan aslinya maka selanjutnya harus mampu menemukan dan memperbaiki berbagai kelemahan yang ditemukan dari sesuatu yang ditirunya dan kemudian menciptakan sesuatu yang baru sebagai hasil modifikasi (perbaikan) dengan hasil yang lebih baik (sempurna) daripada aslinya. Galileo Galilei Anda tidak dapat mengajari orang apapun juga; anda hanya dapat membantu dirinya untuk menemukannya sendiri. Maka dari itu prinsip ATM janganlah berlaku sepihak hanya untuk siswa tetapi semua elemen yang terlibat dalam proses pembelajaran. Integrasi prinsip ATM pada pembelajaran akan mampu menciptakan proses belajar mengajar yang menyenangkan, dinamis, aktif dan kreatif bagi mereka yang terlibat, baik didalam maupun diluar sekolah sehingga proses transfer ilmu akan berjalan dengan waktu yang relatif singkat.","title":"(M) Modifikasi"},{"location":"blog/2019/senyum-sejenak-a/","text":"Senyum Sejenak \u00b6 Sekumpulan cerita lucu yang bisa membuat anda sedikit melupakan hal-hal yang membuat penat dan jenuh. Cerita-cerita lucu ini dikumpulkan dari berbagai sumber baik itu jejaring sosial, cerita antar teman dan beberapa situs yang tersedia di belantara internet. Penulis mohon ma'af jika ternyata kumpulan cerita ini terasa basi bagi anda. Ini hanya sekedar menghibur, minimal buat admin blog ini. Yudono Fani Amsori \u00b6 Seorang pemuda di telephone oleh Customer Service sebuah perusahaa. Orang Bule : \" What is your last name? \" Orang Indo : \" I\u2019m sorry. \" Orang Bule : \" You don\u2019t have to sorry.. And what is your first name? \" Orang Indo : \" You don\u2019t know. \" Orang Bule : \" Off course I don\u2019t know, that\u2019s why I ask you\u2026 And your middle name? \" Orang Indo : \" Funny\u2026 \" Akhirnya orang bule-nya marah dan menutup telepon. Orang Indonesia-nya kebingungan, sambil memandangi nama di KTP-nya sendiri yang tertulis \" Yudono Fani Amsori \". Angkot Misteri \u00b6 Tepatnya malam Jum'at kemarin, bertepatan di jalan depan Pom Bensin Kertahayu jam 9 malam, ada seorang wanita naik angkot jurusan Banjarsari - Banjar. Didalam angkot itu cuma ada dirinya tanpa penumpang lain. Tidak seperti biasanya, malam itu sangat sepi. Kemudian angkot melaju dengan perlahan karena tidak ada penumpang lain. Saking capenya si wanita penumpang itu tertidur beberapa saat, dijalan yang sepi wanita itu terbangun karena angkot tersebut berjalan sangat lambat. Pas matanya terbuka, perempuan itu langsung melirik ke arah pengemudi. Betapa kagetnya wanita tersebut karena di kursi pengemudi tidak ada yang mengemudikan. Dalam hati penumpang ini bertanya-tanya sambil menahan rasa takut \" Angkot berjalan tapi tidak ada pengemudinya... \" Tak tahan menahan rasa takut, wanita ini langsung berteriak minta tolong sambil menjerit-jerit. Wanita tersebut langsung membuka kaca jendela angkot untuk meminta tolong kepada siapa saja yang lewat, begitu kaca jendela dibuka wanita semakin kaget... Karena ada kepala yang nongol dekat jendela sambil ngomong \" Gandeng siah!!! Gogorowokan wae!!! Lain ngabantuan aing ngadorong mobil! Mogok yeuh!!! \" Posisi Duduk Menentukan \u00b6 Pesawat Medan ke Jakarta bersiap akan take-off, tapi tertunda gara-gara Tagor (yang baru pertama kali naik pesawat) dengan tiket ekonomi, tapi ngotot ingin duduk di kelas bisnis. Asiong (pemilik kursi bisnis): \" Maaf pak... Ini kursi saya. \" Tagor : \" Anda siapa...? \" Asiong : \" Saya penumpang yang duduk di kursi sini Pak! \" Tagor : \" Penumpang..? Saya juga, sama-sama bayar..! Sama-sama penumpang, kenapa kau mau ngatur-ngatur saya? \" Asiong tak mau ribut, lalu Asiong lapor ke pramugari. Pramugari : \" Maaf Pak Tagor..dari tiket bapak mesti nya Bapak duduk di belakang. \" Tagor : \" Anda siapa? \" Pramugari : \" Saya pramugari.. \" Tagor : \" Pramugari itu apa? \" Pramugari : \" Pramugari itu yang melayani penumpang. \" Tagor : \" Bah... pelayan rupanya kau !!! Saya kira siapa tadi, udah lah kau urus aja kerjaan kau, nggak usah ngatur-ngatur saya. Pokoknya saya tetap duduk di sini. Anda mau apa...??!! \" Pramugari habis akal, dia pun memanggil pilot. Pilot : \" Maaf pak, mestinya bapak duduk di belakang..!! \" Tagor : \" Siapa pula Anda? \" Pilot : \" Saya pilot pak! \" Tagor : \" Pilot itu apa? \" Pilot : \" Pilot itu yang mengemudikan pesawat ini. \" Tagor : \" Bahhh yang tadi pelayan, sekarang sopir..? Saya kira Anda siapa, berpakaian kayak DLLAJ, pake topi, ternyata cuma sopir. Pokoknya saya tetap disini. Mau apa Anda? Bikin kesal saya saja \". Bonar, orang Batak yang baru masuk pesawat mendengar ribut-ribut bertanya pada pilot, kemudian dia manggut-manggut dan minta waktu 5 menit pada pilot untuk dapat bicara pada Tagor. Kemudian Bonar duduk disebelah Tagor sambil mengobrol. Tiga menit kemudian, Tagor tiba-tiba bangkit sambil ngomel-ngomel. Tagor pun pindah ke belakang, Pilot merasa takjub, dia lalu bertanya pada Bonar. Pilot : \" Apa sih yang Bapak bicarakan, kok tiba-tiba dia bisa pindah kursi? \" Bonar : \" Aku bilang \"lae mau kemana?\" Dia jawab \"ke Jakarta\", terus Aku bilang \"Lae, duduknya salah, kalau ke Jakarta, duduknya di belakang, yang di depan ini turunnya di Samosir... !!! \" Tikus Kelelawar \u00b6 Ada ibu tikus dan anak tikus yang sedang ngobrol di pinggir got. Anak tikus melihat kelelawar yang terbang di atasnya. Anak Tikus : \" Ibu, apa itu yang terbang di atas kita? \" Ibu Tikus : \" Ooo\u2026 Itu kelelawar namanya nak \" Anak Tikus : \" Kok mukanya mirip dengan kita? \" Ibu Tikus : \" Sebenarnya dia masih sebangsa dengan kita, cuma dia ambil jurusan penerbangan \" Telinga Kemasukan Kacang Ijo \u00b6 Cerita Dokter THT dengan Pasiennya yang pelitnya minta ampun. Pasien : \" Dok, telinga saya kemasukan kacang ijo nih... \" Dokter : \" Wah itu harus dioperasi, biayanya sekitar 2 juta \" Pasien : \" Mahal amat dok, ngga ada yang murah? \" Dokter : \" Ada sih yg gratis, hanya bermodal sabar saja \" Pasien : \" Ok, dok saya akan sabar \" Dokter : \" Caranya begini : masukkan air ke telinga anda 2 kali sehari, pagi and sore, nanti kalo sudah tumbuh menjadi toge tinggal ditarik aja... Mudah bukan? Begitu saja kok repot... \" Pasien : \" Ah...! Dokter Bisa aja. \" Menanam Jagung \u00b6 Ada seorang warga Aceh dari kabupaten Pidie, menulis surat kepada anaknya yang ada di penjara Nusa Kambangan karena dituduh terlibat GAM (Gerakan Aceh Merdeka). Bunyi surat tersebut \" Hasan, bapakmu ini sudah tua, sekarang sedang musim tanam jagung, dan kamu ditahan di penjara pula, siapa yang mau bantu bapak mencangkul kebun jagung ini? \" Eh, anaknya membalas surat itu beberapa minggu kemudian. \" Pak! Hasan mohon dengan sangat, jangan cangkul itu kebun, saya menaruh senjata di sana \" kata si anak dalam surat itu. Rupanya surat itu disensor pihak rumah tahanan, maka keesokan harinya setelah si bapak terima surat, datang satu peleton tentara dari kota Medan. Tanpa banyak bicara mereka segera ke kebun jagung dan sibuk seharian mencangkul tanah di kebun tersebut. Setelah mereka pergi, kembali si bapak tulis surat ke anaknya. \" Hasan, setelah bapak terima suratmu, datang satu peleton tentara mencari senjata di kebun jagung kita, namun tanpa hasil. Apa yang harus bapak lakukan sekarang? \" Si anak kembali membalas surat tersebut, \" Sekarang bapak mulai tanam jagung, kan sudah dicangkul oleh tentara, dan jangan lupa ucapkan terima kasih kepada mereka \" Pihak rumah tahanan yang menyensor surat ini langsung klepek-klepek!!!","title":"Senyum Sejenak Vol 1"},{"location":"blog/2019/senyum-sejenak-a/#senyum-sejenak","text":"Sekumpulan cerita lucu yang bisa membuat anda sedikit melupakan hal-hal yang membuat penat dan jenuh. Cerita-cerita lucu ini dikumpulkan dari berbagai sumber baik itu jejaring sosial, cerita antar teman dan beberapa situs yang tersedia di belantara internet. Penulis mohon ma'af jika ternyata kumpulan cerita ini terasa basi bagi anda. Ini hanya sekedar menghibur, minimal buat admin blog ini.","title":"Senyum Sejenak"},{"location":"blog/2019/senyum-sejenak-a/#yudono-fani-amsori","text":"Seorang pemuda di telephone oleh Customer Service sebuah perusahaa. Orang Bule : \" What is your last name? \" Orang Indo : \" I\u2019m sorry. \" Orang Bule : \" You don\u2019t have to sorry.. And what is your first name? \" Orang Indo : \" You don\u2019t know. \" Orang Bule : \" Off course I don\u2019t know, that\u2019s why I ask you\u2026 And your middle name? \" Orang Indo : \" Funny\u2026 \" Akhirnya orang bule-nya marah dan menutup telepon. Orang Indonesia-nya kebingungan, sambil memandangi nama di KTP-nya sendiri yang tertulis \" Yudono Fani Amsori \".","title":"Yudono Fani Amsori"},{"location":"blog/2019/senyum-sejenak-a/#angkot-misteri","text":"Tepatnya malam Jum'at kemarin, bertepatan di jalan depan Pom Bensin Kertahayu jam 9 malam, ada seorang wanita naik angkot jurusan Banjarsari - Banjar. Didalam angkot itu cuma ada dirinya tanpa penumpang lain. Tidak seperti biasanya, malam itu sangat sepi. Kemudian angkot melaju dengan perlahan karena tidak ada penumpang lain. Saking capenya si wanita penumpang itu tertidur beberapa saat, dijalan yang sepi wanita itu terbangun karena angkot tersebut berjalan sangat lambat. Pas matanya terbuka, perempuan itu langsung melirik ke arah pengemudi. Betapa kagetnya wanita tersebut karena di kursi pengemudi tidak ada yang mengemudikan. Dalam hati penumpang ini bertanya-tanya sambil menahan rasa takut \" Angkot berjalan tapi tidak ada pengemudinya... \" Tak tahan menahan rasa takut, wanita ini langsung berteriak minta tolong sambil menjerit-jerit. Wanita tersebut langsung membuka kaca jendela angkot untuk meminta tolong kepada siapa saja yang lewat, begitu kaca jendela dibuka wanita semakin kaget... Karena ada kepala yang nongol dekat jendela sambil ngomong \" Gandeng siah!!! Gogorowokan wae!!! Lain ngabantuan aing ngadorong mobil! Mogok yeuh!!! \"","title":"Angkot Misteri"},{"location":"blog/2019/senyum-sejenak-a/#posisi-duduk-menentukan","text":"Pesawat Medan ke Jakarta bersiap akan take-off, tapi tertunda gara-gara Tagor (yang baru pertama kali naik pesawat) dengan tiket ekonomi, tapi ngotot ingin duduk di kelas bisnis. Asiong (pemilik kursi bisnis): \" Maaf pak... Ini kursi saya. \" Tagor : \" Anda siapa...? \" Asiong : \" Saya penumpang yang duduk di kursi sini Pak! \" Tagor : \" Penumpang..? Saya juga, sama-sama bayar..! Sama-sama penumpang, kenapa kau mau ngatur-ngatur saya? \" Asiong tak mau ribut, lalu Asiong lapor ke pramugari. Pramugari : \" Maaf Pak Tagor..dari tiket bapak mesti nya Bapak duduk di belakang. \" Tagor : \" Anda siapa? \" Pramugari : \" Saya pramugari.. \" Tagor : \" Pramugari itu apa? \" Pramugari : \" Pramugari itu yang melayani penumpang. \" Tagor : \" Bah... pelayan rupanya kau !!! Saya kira siapa tadi, udah lah kau urus aja kerjaan kau, nggak usah ngatur-ngatur saya. Pokoknya saya tetap duduk di sini. Anda mau apa...??!! \" Pramugari habis akal, dia pun memanggil pilot. Pilot : \" Maaf pak, mestinya bapak duduk di belakang..!! \" Tagor : \" Siapa pula Anda? \" Pilot : \" Saya pilot pak! \" Tagor : \" Pilot itu apa? \" Pilot : \" Pilot itu yang mengemudikan pesawat ini. \" Tagor : \" Bahhh yang tadi pelayan, sekarang sopir..? Saya kira Anda siapa, berpakaian kayak DLLAJ, pake topi, ternyata cuma sopir. Pokoknya saya tetap disini. Mau apa Anda? Bikin kesal saya saja \". Bonar, orang Batak yang baru masuk pesawat mendengar ribut-ribut bertanya pada pilot, kemudian dia manggut-manggut dan minta waktu 5 menit pada pilot untuk dapat bicara pada Tagor. Kemudian Bonar duduk disebelah Tagor sambil mengobrol. Tiga menit kemudian, Tagor tiba-tiba bangkit sambil ngomel-ngomel. Tagor pun pindah ke belakang, Pilot merasa takjub, dia lalu bertanya pada Bonar. Pilot : \" Apa sih yang Bapak bicarakan, kok tiba-tiba dia bisa pindah kursi? \" Bonar : \" Aku bilang \"lae mau kemana?\" Dia jawab \"ke Jakarta\", terus Aku bilang \"Lae, duduknya salah, kalau ke Jakarta, duduknya di belakang, yang di depan ini turunnya di Samosir... !!! \"","title":"Posisi Duduk Menentukan"},{"location":"blog/2019/senyum-sejenak-a/#tikus-kelelawar","text":"Ada ibu tikus dan anak tikus yang sedang ngobrol di pinggir got. Anak tikus melihat kelelawar yang terbang di atasnya. Anak Tikus : \" Ibu, apa itu yang terbang di atas kita? \" Ibu Tikus : \" Ooo\u2026 Itu kelelawar namanya nak \" Anak Tikus : \" Kok mukanya mirip dengan kita? \" Ibu Tikus : \" Sebenarnya dia masih sebangsa dengan kita, cuma dia ambil jurusan penerbangan \"","title":"Tikus Kelelawar"},{"location":"blog/2019/senyum-sejenak-a/#telinga-kemasukan-kacang-ijo","text":"Cerita Dokter THT dengan Pasiennya yang pelitnya minta ampun. Pasien : \" Dok, telinga saya kemasukan kacang ijo nih... \" Dokter : \" Wah itu harus dioperasi, biayanya sekitar 2 juta \" Pasien : \" Mahal amat dok, ngga ada yang murah? \" Dokter : \" Ada sih yg gratis, hanya bermodal sabar saja \" Pasien : \" Ok, dok saya akan sabar \" Dokter : \" Caranya begini : masukkan air ke telinga anda 2 kali sehari, pagi and sore, nanti kalo sudah tumbuh menjadi toge tinggal ditarik aja... Mudah bukan? Begitu saja kok repot... \" Pasien : \" Ah...! Dokter Bisa aja. \"","title":"Telinga Kemasukan Kacang Ijo"},{"location":"blog/2019/senyum-sejenak-a/#menanam-jagung","text":"Ada seorang warga Aceh dari kabupaten Pidie, menulis surat kepada anaknya yang ada di penjara Nusa Kambangan karena dituduh terlibat GAM (Gerakan Aceh Merdeka). Bunyi surat tersebut \" Hasan, bapakmu ini sudah tua, sekarang sedang musim tanam jagung, dan kamu ditahan di penjara pula, siapa yang mau bantu bapak mencangkul kebun jagung ini? \" Eh, anaknya membalas surat itu beberapa minggu kemudian. \" Pak! Hasan mohon dengan sangat, jangan cangkul itu kebun, saya menaruh senjata di sana \" kata si anak dalam surat itu. Rupanya surat itu disensor pihak rumah tahanan, maka keesokan harinya setelah si bapak terima surat, datang satu peleton tentara dari kota Medan. Tanpa banyak bicara mereka segera ke kebun jagung dan sibuk seharian mencangkul tanah di kebun tersebut. Setelah mereka pergi, kembali si bapak tulis surat ke anaknya. \" Hasan, setelah bapak terima suratmu, datang satu peleton tentara mencari senjata di kebun jagung kita, namun tanpa hasil. Apa yang harus bapak lakukan sekarang? \" Si anak kembali membalas surat tersebut, \" Sekarang bapak mulai tanam jagung, kan sudah dicangkul oleh tentara, dan jangan lupa ucapkan terima kasih kepada mereka \" Pihak rumah tahanan yang menyensor surat ini langsung klepek-klepek!!!","title":"Menanam Jagung"},{"location":"blog/2019/submodule-git/","text":"Menggunakan Submodule pada Git \u00b6 Pada umumnya, setiap proyek perangkat lunak yang dikembangkan oleh seseorang, biasanya akan membutuhkan dan atau bergantung pada proyek lain, perpustakaan, atau kerangka kerja lainnya. Git menyediakan submodule untuk membantu masalah ini. Submodule memungkinkan Kita untuk memasukkan atau menanamkan satu atau lebih repositori sebagai sub-folder di dalam repositori yang sedang kita buat atau kembangkan. Untuk proyek yang komplek atau banyak, submodule bukanlah solusi terbaik, bekerja dengan submodule bisa saja menjadi sangat rumit, tetapi mari kita pelajari bagaimana menggunakan submodule pada Git terutama GitHub. Menambahkan Submodule \u00b6 Sebagai contoh Anda sedang mengerjakan proyek yang disebut ketapel . Didalam proyek ketapel sudah tersedia folder kode kayu - cagak dan folder kode karet - ban . Disaat yang sama, di repositori yang lain, Anda punya proyek lain yang disebut kerikil dan itu hanya sebuah perpustakaan umum, tetapi Anda berpikir itu akan menjadi sempurna untuk proyek ketapel . Anda dapat menambahkan proyek kerikil sebagai submodule dari proyek ketapel . Gunakan perintah dibawah ini untuk menambahkan repositori proyek kerikil ke dalam repositori proyek ketapel : 1 git submodule add https://github.com/<user>/kerikil.git kerikil Penggunaan perintah diatas ketika Anda berada di dalam repositori proyek ketapel . Gambar 1. Penggunaan Perintah Submodule Git Setelah perintah tersebut digunakan, Anda akan memiliki folder kerikil di dalam repositori ketapel , tetapi jika Anda membuka folder kerikil , tetapi juga tergantung pada versi Git Anda, Anda mungkin tidak akan menemukan apa-apa. Versi Git yang yang terbaru akan mengunduh dan menempatkan kerikil secara otomatis, tetapi versi yang lebih lama akan meminta Anda untuk secara eksplisit memberitahu Git agar mengunduh konten dari kerikil . Gunakan perintah ini jika Anda menggunakan Git versi lama: 1 git submodule update --init --recursive Jika semuanya berjalan baik, Anda dapat menemukan perubahan dan Anda akan memiliki folder kerikil di dalam repositori ketapel dengan semua konten yang berasal dari repositori kerikil . Tampilan pada GitHub, ikon folder kerikil akan memiliki sedikit indikator yang menunjukkan bahwa itu adalah submodule: Gambar 2. Indikator Ikon Folder Submodule GitHub Dan ketika anda membuka folder kerikil maka Anda akan di bawa menuju repositori kerikil . Nah ini dia! Anda telah berhasil menyematkan repositori kerikil di dalam repositori ketapel . Anda dapat berinteraksi dengan semua konten dari kerikil , seolah-olah folder kerikil itu bagian terintegrasi di dalam repositori ketapel (dan karena memang begitu). Pada baris perintah (command-line), perintah Git yang digunakan didalam repositori ketapel (atau didalam folder lain, seperti karet-ban dan cagak-kayu) akan beroperasi pada \"repositori induk\" ketapel, tetapi perintah yang Anda gunakan pada folder kerikil hanya akan beroperasi pada repositori kerikil : 1 2 3 4 5 6 cd ~/ketapel git log # menampilkan log commit dari Proyek Ketapel cd ~/ketapel/karet-ban git log # masih menampilkan log commit dari Proyek Ketapel cd ~/ketapel/kerikil git log # menampilkan commit dari Proyek Kerikil Bergabung pada Sebuah Proyek Menggunakan Submodule \u00b6 Sekarang, misalkan Anda adalah seorang kolaborator baru yang akan bergabung dengan Proyek Ketapel. Tentunya Anda akan memulainya dengan menjalankan printah git clone untuk mengunduh konten dari repositori ketapel . Setelah itu, jika Anda membuka folder kerikil , Anda pasti tidak akan menemukan apa-apa. Sekali lagi, Git mengharuskan kita secara eksplisit untuk mengunduh konten submodule. Anda dapat menggunakan perintah git submodule update --init --recursive , tetapi jika Anda melakukan clone proyek ketapel untuk pertama kalinya, Anda dapat menggunakan perintah clone yang dimodifikasi untuk memastikan Anda mengunduh semuanya, termasuk submodule didalamnya. Gunakan perintah dibawah ini: 1 git clone --recursive <alamat url proyek> Alihkan ke Submodule \u00b6 Mungkin agak sulit untuk mengambil subfolder yang ada didalam sebuah repositori dan kemudian mengubahnya menjadi dependensi eksternal (sesuatu yang bisa digunakan oleh proyek lain). Mari kita lihat sebuah contoh berikut. Misal Anda akan memulai proyek baru - kaleng ajaib - yang ternyata di dalam proyek tersebut membutuhkan karet - ban , sedangkan karet - ban adalah sub folder dari proyek ketapel . Mari kita ambil karet - ban yang sudah Anda buat untuk proyek ketapel , membaginya / memisahkannya menjadi repositori yang berdiri sendiri, dan kemudian menanamkannya ke dalam kedua proyek tersebut (proyek ketapel dan proyek kaleng ajaib ) melalui submodule. Anda dapat mengambil semua dari folder karet - ban yang ada di dalam proyek ketapel dan mengekstraknya ke dalam repositori baru dengan tetap mempertahankan histori commit. Mari kita mulai dengan mengekstraksi isi folder karet - ban keluar dari proyek ketapel . Anda dapat menggunakan perintah git filter - branch , kemudian membiarkan apa saja kecuali hal-hal yang berhubungan dengan commit terkait karet - ban . Perintah git filter - branch akan menulis ulang histori repositori kita, sehingga terlihat seolah-olah folder karet - ban merupakan repositori yang berdiri sendiri selama ini. Untuk informasi lebih lanjut tentang git filter-branch, silahkan baca artikel ini . Langkah pertama adalah membuat salinan ketapel untuk dikerjakan \u2014 tujuan akhirnya adalah membuat folder karet - ban sebagai repositori yang berdiri sendiri, jadi biarkan ketapel apa adanya. Anda dapat menggunakan cp dan - r untuk menyalin seluruh folder ketapel secara rekursif ke folder baru karet - ban . 1 2 cd .. cp -r ketapel karet-ban Sekarang tampak karet - ban bagian lain dari ketapel , lalu sekarang, dari dalam repositori karet - ban , jalankan perintag git filter - branch : 1 2 3 cd karet-ban # pindah ke direktori karet-ban pwd # periksa dua kali sebelum memproses! git filter-branch --subdirectory-filter karet-ban -- --all Sampai di sini, Anda akan memiliki folder karet-ban, yang merupakan repositori yang mirip dengan Proyek ketapel , tetapi hanya memiliki file dan sejarah (history) dari folder karet - ban tersebut. Karena Anda menyalinnya dari ketapel , repositori baru ini masih akan memiliki cabang pelacakan jarak jauh yang Anda siapkan saat di ketapel . Sedangkan Anda tidak ingin mengembalikan karet - ban kembali ke ketapel . Anda harus mengarahkannya ke repositori baru. Buat repositori baru untuk karet - ban di GitHub, lalu perbarui remote untuk karet - ban . Dengan asumsi Anda memanggil remote origin, Anda bisa menuliskan perintah: 1 git remote set-url origin https://github.com/<user>/karet-ban Kemudian Anda dapat menerbitkan \"modul karet-ban generik\" yang baru dengan git push . Sekarang setelah Anda memisahkan karet - ban ke dalam repositori sendiri, Anda harus menghapus folder karet - ban lama dari repositori ketapel dengan perintah: 1 2 git rm -r karet-ban git commit -m \"Membuang karet-ban (persiapan untuk submodule)\" Untuk memperbarui proyek ketapel dengan menggunakan karet - ban sebagai submodule, gunakan perintah ini: 1 2 git submodule add https://github.com/<user>/karet-ban karet-ban git commit -m \"submodule karet-ban\" Seperti yang pernah kita lakukan sebelumnya ketika kita menambahkan kerikil , nah sekarang kita telah memiliki repositori-didalam-repositori. Tiga repositori telah terbentuk, yaitu: repositori \"induk\" ketapel , ditambah dua repositori \"sub\", kerikil dan karet - ban . Selain itu, jika kita melihat kembali sejarah ketapel , kita akan melihat commit awal yang telah kita buat pada karet - ban ketika itu masih sebagai folder - menghapus folder tidaklah menghapus history (sejarah). Terkadang hal ini bisa sedikit membingungkan - karena repositori karet - ban adalah \"anak\" yang merupakan versi lama yang telah disalin dan dimodifikasi dari commit ketapel yang lama, bahkan kita seperti mengalami d\u00e9ja vu . Sayangnya, setiap kolaborator yang telah melakukan clone ketapel pada saat ini hanya akan memiliki folder karet - ban kosong. Anda bisa mengingatkan kolaborator untuk menjalankan perintah ini untuk memastikan mereka memiliki semua konten submodule: 1 git submodule update --init --recursive Jika Anda juga ingin menambahkan karet - ban sebagai submodule ke proyek kaleng ajaib Anda cukup mengikuti prosedur yang sama yang digunakan sebelumnya ketika Anda menambahkan kerikil ke ke dalam proyek ketapel : 1 2 3 4 cd ~/kaleng-ajaib git submodule add https://github.com/<user>/karet-ban karet-ban git commit -m \"menambahkan submodule karet-ban\" git submodule update --init --recursive Bagaimana? Mudah bukan? Kesimpulan \u00b6 Sebelum Anda menambahkan repositori sebagai submodule, periksa terlebih dahulu untuk memperhatikan apakah Anda memiliki alternatif yang lebih baik. Submodule Git bekerja cukup baik untuk kasus-kasus sederhana, tetapi akhir-akhir ini ada peralatan yang lebih baik untuk mengelola dependensi daripada yang dapat ditawarkan oleh submodule Git. Bahasa modern seperti Go memiliki sistem pengelolaan dependensi didalam Git sejak awal dibuat. Yang lain, seperti Ruby rubygems, Node.js, npm , atau Cocoa's CocoaPods dan Carthage, telah ditambahkan fungsi terintegrasi oleh komunitas pemrograman. Bahkan pengembang front-end memiliki alat seperti Bower untuk mengelola perpustakaan dan kerangka kerja untuk sisi klien JavaScript dan CSS. Ingat bahwa Git tidak mengunduh konten submodule secara default. Jika Anda menambahkan submodule ke proyek yang ada, pastikan siapa pun yang bekerja di proyek tersebut tahu bahwa mereka perlu menjalankan perintah seperti git submodule update dan git clone --recursive untuk memastikan mereka mendapatkan keseluruhan isi proyeknya - ini termasuk penyebaran otomatis atau layanan pengujian yang mungkin terlibat dalam proyek! Kami menyarankan Anda menggunakan sesuatu seperti \"Scripts to Rule Them All\" untuk memastikan bahwa semua kolaborator dan layanan memiliki akses ke konten repositori yang sama di mana pun. Submodules mengharuskan Anda untuk menyeimbangkan konsistensi dan kenyamanan dengan cermat. Pengaturan yang digunakan di sini sangat mengutamakan konsistensi, dengan mengorbankan sedikit kenyamanan. Biasanya yang terbaik untuk mengelola proyek dengan submodule dengan dikunci menggunakan SHA tertentu, sehingga semua kolaborator menerima konten yang sama. Tetapi pengaturan ini juga menyulitkan pengembang di repositori \"induk\" untuk menyumbangkan perubahan kembali ke repositori submodule. Ingat bahwa kolaborator tidak akan secara otomatis melihat pembaruan pada submodul \u2014 jika Anda memperbarui submodule, Anda mungkin perlu mengingatkan teman Anda untuk menjalankan git submodule update atau mereka mungkin akan melihat perilaku yang tidak biasanya pada proyek tersebut. Mengelola repositori yang dinamis, berkembang dengan cepat pada submodul dapat dengan cepat memunculkan frustasi. Artikel ini difokuskan pada hubungan repositori sederhana antara orang tua dan anak. Artikel selanjutnya di masa depan akan merinci beberapa strategi untuk membantu mengelola alur kerja submodule yang lebih kompleks. Selamat belajar dan belajar lagi! Daftar Pustaka \u00b6 Working with submodules Using submodules in Git Git Tools - Submodules git-filter-branch","title":"Menggunakan Submodule Git"},{"location":"blog/2019/submodule-git/#menggunakan-submodule-pada-git","text":"Pada umumnya, setiap proyek perangkat lunak yang dikembangkan oleh seseorang, biasanya akan membutuhkan dan atau bergantung pada proyek lain, perpustakaan, atau kerangka kerja lainnya. Git menyediakan submodule untuk membantu masalah ini. Submodule memungkinkan Kita untuk memasukkan atau menanamkan satu atau lebih repositori sebagai sub-folder di dalam repositori yang sedang kita buat atau kembangkan. Untuk proyek yang komplek atau banyak, submodule bukanlah solusi terbaik, bekerja dengan submodule bisa saja menjadi sangat rumit, tetapi mari kita pelajari bagaimana menggunakan submodule pada Git terutama GitHub.","title":"Menggunakan Submodule pada Git"},{"location":"blog/2019/submodule-git/#menambahkan-submodule","text":"Sebagai contoh Anda sedang mengerjakan proyek yang disebut ketapel . Didalam proyek ketapel sudah tersedia folder kode kayu - cagak dan folder kode karet - ban . Disaat yang sama, di repositori yang lain, Anda punya proyek lain yang disebut kerikil dan itu hanya sebuah perpustakaan umum, tetapi Anda berpikir itu akan menjadi sempurna untuk proyek ketapel . Anda dapat menambahkan proyek kerikil sebagai submodule dari proyek ketapel . Gunakan perintah dibawah ini untuk menambahkan repositori proyek kerikil ke dalam repositori proyek ketapel : 1 git submodule add https://github.com/<user>/kerikil.git kerikil Penggunaan perintah diatas ketika Anda berada di dalam repositori proyek ketapel . Gambar 1. Penggunaan Perintah Submodule Git Setelah perintah tersebut digunakan, Anda akan memiliki folder kerikil di dalam repositori ketapel , tetapi jika Anda membuka folder kerikil , tetapi juga tergantung pada versi Git Anda, Anda mungkin tidak akan menemukan apa-apa. Versi Git yang yang terbaru akan mengunduh dan menempatkan kerikil secara otomatis, tetapi versi yang lebih lama akan meminta Anda untuk secara eksplisit memberitahu Git agar mengunduh konten dari kerikil . Gunakan perintah ini jika Anda menggunakan Git versi lama: 1 git submodule update --init --recursive Jika semuanya berjalan baik, Anda dapat menemukan perubahan dan Anda akan memiliki folder kerikil di dalam repositori ketapel dengan semua konten yang berasal dari repositori kerikil . Tampilan pada GitHub, ikon folder kerikil akan memiliki sedikit indikator yang menunjukkan bahwa itu adalah submodule: Gambar 2. Indikator Ikon Folder Submodule GitHub Dan ketika anda membuka folder kerikil maka Anda akan di bawa menuju repositori kerikil . Nah ini dia! Anda telah berhasil menyematkan repositori kerikil di dalam repositori ketapel . Anda dapat berinteraksi dengan semua konten dari kerikil , seolah-olah folder kerikil itu bagian terintegrasi di dalam repositori ketapel (dan karena memang begitu). Pada baris perintah (command-line), perintah Git yang digunakan didalam repositori ketapel (atau didalam folder lain, seperti karet-ban dan cagak-kayu) akan beroperasi pada \"repositori induk\" ketapel, tetapi perintah yang Anda gunakan pada folder kerikil hanya akan beroperasi pada repositori kerikil : 1 2 3 4 5 6 cd ~/ketapel git log # menampilkan log commit dari Proyek Ketapel cd ~/ketapel/karet-ban git log # masih menampilkan log commit dari Proyek Ketapel cd ~/ketapel/kerikil git log # menampilkan commit dari Proyek Kerikil","title":"Menambahkan Submodule"},{"location":"blog/2019/submodule-git/#bergabung-pada-sebuah-proyek-menggunakan-submodule","text":"Sekarang, misalkan Anda adalah seorang kolaborator baru yang akan bergabung dengan Proyek Ketapel. Tentunya Anda akan memulainya dengan menjalankan printah git clone untuk mengunduh konten dari repositori ketapel . Setelah itu, jika Anda membuka folder kerikil , Anda pasti tidak akan menemukan apa-apa. Sekali lagi, Git mengharuskan kita secara eksplisit untuk mengunduh konten submodule. Anda dapat menggunakan perintah git submodule update --init --recursive , tetapi jika Anda melakukan clone proyek ketapel untuk pertama kalinya, Anda dapat menggunakan perintah clone yang dimodifikasi untuk memastikan Anda mengunduh semuanya, termasuk submodule didalamnya. Gunakan perintah dibawah ini: 1 git clone --recursive <alamat url proyek>","title":"Bergabung pada Sebuah Proyek Menggunakan Submodule"},{"location":"blog/2019/submodule-git/#alihkan-ke-submodule","text":"Mungkin agak sulit untuk mengambil subfolder yang ada didalam sebuah repositori dan kemudian mengubahnya menjadi dependensi eksternal (sesuatu yang bisa digunakan oleh proyek lain). Mari kita lihat sebuah contoh berikut. Misal Anda akan memulai proyek baru - kaleng ajaib - yang ternyata di dalam proyek tersebut membutuhkan karet - ban , sedangkan karet - ban adalah sub folder dari proyek ketapel . Mari kita ambil karet - ban yang sudah Anda buat untuk proyek ketapel , membaginya / memisahkannya menjadi repositori yang berdiri sendiri, dan kemudian menanamkannya ke dalam kedua proyek tersebut (proyek ketapel dan proyek kaleng ajaib ) melalui submodule. Anda dapat mengambil semua dari folder karet - ban yang ada di dalam proyek ketapel dan mengekstraknya ke dalam repositori baru dengan tetap mempertahankan histori commit. Mari kita mulai dengan mengekstraksi isi folder karet - ban keluar dari proyek ketapel . Anda dapat menggunakan perintah git filter - branch , kemudian membiarkan apa saja kecuali hal-hal yang berhubungan dengan commit terkait karet - ban . Perintah git filter - branch akan menulis ulang histori repositori kita, sehingga terlihat seolah-olah folder karet - ban merupakan repositori yang berdiri sendiri selama ini. Untuk informasi lebih lanjut tentang git filter-branch, silahkan baca artikel ini . Langkah pertama adalah membuat salinan ketapel untuk dikerjakan \u2014 tujuan akhirnya adalah membuat folder karet - ban sebagai repositori yang berdiri sendiri, jadi biarkan ketapel apa adanya. Anda dapat menggunakan cp dan - r untuk menyalin seluruh folder ketapel secara rekursif ke folder baru karet - ban . 1 2 cd .. cp -r ketapel karet-ban Sekarang tampak karet - ban bagian lain dari ketapel , lalu sekarang, dari dalam repositori karet - ban , jalankan perintag git filter - branch : 1 2 3 cd karet-ban # pindah ke direktori karet-ban pwd # periksa dua kali sebelum memproses! git filter-branch --subdirectory-filter karet-ban -- --all Sampai di sini, Anda akan memiliki folder karet-ban, yang merupakan repositori yang mirip dengan Proyek ketapel , tetapi hanya memiliki file dan sejarah (history) dari folder karet - ban tersebut. Karena Anda menyalinnya dari ketapel , repositori baru ini masih akan memiliki cabang pelacakan jarak jauh yang Anda siapkan saat di ketapel . Sedangkan Anda tidak ingin mengembalikan karet - ban kembali ke ketapel . Anda harus mengarahkannya ke repositori baru. Buat repositori baru untuk karet - ban di GitHub, lalu perbarui remote untuk karet - ban . Dengan asumsi Anda memanggil remote origin, Anda bisa menuliskan perintah: 1 git remote set-url origin https://github.com/<user>/karet-ban Kemudian Anda dapat menerbitkan \"modul karet-ban generik\" yang baru dengan git push . Sekarang setelah Anda memisahkan karet - ban ke dalam repositori sendiri, Anda harus menghapus folder karet - ban lama dari repositori ketapel dengan perintah: 1 2 git rm -r karet-ban git commit -m \"Membuang karet-ban (persiapan untuk submodule)\" Untuk memperbarui proyek ketapel dengan menggunakan karet - ban sebagai submodule, gunakan perintah ini: 1 2 git submodule add https://github.com/<user>/karet-ban karet-ban git commit -m \"submodule karet-ban\" Seperti yang pernah kita lakukan sebelumnya ketika kita menambahkan kerikil , nah sekarang kita telah memiliki repositori-didalam-repositori. Tiga repositori telah terbentuk, yaitu: repositori \"induk\" ketapel , ditambah dua repositori \"sub\", kerikil dan karet - ban . Selain itu, jika kita melihat kembali sejarah ketapel , kita akan melihat commit awal yang telah kita buat pada karet - ban ketika itu masih sebagai folder - menghapus folder tidaklah menghapus history (sejarah). Terkadang hal ini bisa sedikit membingungkan - karena repositori karet - ban adalah \"anak\" yang merupakan versi lama yang telah disalin dan dimodifikasi dari commit ketapel yang lama, bahkan kita seperti mengalami d\u00e9ja vu . Sayangnya, setiap kolaborator yang telah melakukan clone ketapel pada saat ini hanya akan memiliki folder karet - ban kosong. Anda bisa mengingatkan kolaborator untuk menjalankan perintah ini untuk memastikan mereka memiliki semua konten submodule: 1 git submodule update --init --recursive Jika Anda juga ingin menambahkan karet - ban sebagai submodule ke proyek kaleng ajaib Anda cukup mengikuti prosedur yang sama yang digunakan sebelumnya ketika Anda menambahkan kerikil ke ke dalam proyek ketapel : 1 2 3 4 cd ~/kaleng-ajaib git submodule add https://github.com/<user>/karet-ban karet-ban git commit -m \"menambahkan submodule karet-ban\" git submodule update --init --recursive Bagaimana? Mudah bukan?","title":"Alihkan ke Submodule"},{"location":"blog/2019/submodule-git/#kesimpulan","text":"Sebelum Anda menambahkan repositori sebagai submodule, periksa terlebih dahulu untuk memperhatikan apakah Anda memiliki alternatif yang lebih baik. Submodule Git bekerja cukup baik untuk kasus-kasus sederhana, tetapi akhir-akhir ini ada peralatan yang lebih baik untuk mengelola dependensi daripada yang dapat ditawarkan oleh submodule Git. Bahasa modern seperti Go memiliki sistem pengelolaan dependensi didalam Git sejak awal dibuat. Yang lain, seperti Ruby rubygems, Node.js, npm , atau Cocoa's CocoaPods dan Carthage, telah ditambahkan fungsi terintegrasi oleh komunitas pemrograman. Bahkan pengembang front-end memiliki alat seperti Bower untuk mengelola perpustakaan dan kerangka kerja untuk sisi klien JavaScript dan CSS. Ingat bahwa Git tidak mengunduh konten submodule secara default. Jika Anda menambahkan submodule ke proyek yang ada, pastikan siapa pun yang bekerja di proyek tersebut tahu bahwa mereka perlu menjalankan perintah seperti git submodule update dan git clone --recursive untuk memastikan mereka mendapatkan keseluruhan isi proyeknya - ini termasuk penyebaran otomatis atau layanan pengujian yang mungkin terlibat dalam proyek! Kami menyarankan Anda menggunakan sesuatu seperti \"Scripts to Rule Them All\" untuk memastikan bahwa semua kolaborator dan layanan memiliki akses ke konten repositori yang sama di mana pun. Submodules mengharuskan Anda untuk menyeimbangkan konsistensi dan kenyamanan dengan cermat. Pengaturan yang digunakan di sini sangat mengutamakan konsistensi, dengan mengorbankan sedikit kenyamanan. Biasanya yang terbaik untuk mengelola proyek dengan submodule dengan dikunci menggunakan SHA tertentu, sehingga semua kolaborator menerima konten yang sama. Tetapi pengaturan ini juga menyulitkan pengembang di repositori \"induk\" untuk menyumbangkan perubahan kembali ke repositori submodule. Ingat bahwa kolaborator tidak akan secara otomatis melihat pembaruan pada submodul \u2014 jika Anda memperbarui submodule, Anda mungkin perlu mengingatkan teman Anda untuk menjalankan git submodule update atau mereka mungkin akan melihat perilaku yang tidak biasanya pada proyek tersebut. Mengelola repositori yang dinamis, berkembang dengan cepat pada submodul dapat dengan cepat memunculkan frustasi. Artikel ini difokuskan pada hubungan repositori sederhana antara orang tua dan anak. Artikel selanjutnya di masa depan akan merinci beberapa strategi untuk membantu mengelola alur kerja submodule yang lebih kompleks. Selamat belajar dan belajar lagi!","title":"Kesimpulan"},{"location":"blog/2019/submodule-git/#daftar-pustaka","text":"Working with submodules Using submodules in Git Git Tools - Submodules git-filter-branch","title":"Daftar Pustaka"},{"location":"blog/2019/untrack-files/","text":"Hapus jejak file yang sudah ditambahkan ke repositori git berdasarkan .gitignore \u00b6 Suatu saat Anda telah menambahkan / mengkomit beberapa file ke repositori git Anda dan kemudian ingin menambahkannya ke .gitignore; file-file ini akan tetap ada di indeks repositori Anda. Artikel ini akan membahas bagaimana cara menghilangkannya atau membersihkan repositori Anda. Step 1: Commit semua perubahan \u00b6 Sebelum melanjutkan, pastikan semua perubahan yang Anda lakukan telah di commit , termasuk file .gitignore . Step 2: Buang segala sesuatu dari repositori \u00b6 Untuk membersihkan repositori Anda, gunakan perintah: 1 git rm - r --cached . rm adalah perintah penghapusan - r memungkinkan penghapusan secara rekursif (menyeluruh) \u2013 cached hanya akan menghapus file dari indeks. Tetapi sebenarnya File Anda tetap ada di sana. . menunjukkan bahwa semua file tidak akan dilacak. Anda dapat menghapus file tertentu dengan perintah git rm --cached foo.txt . Perintah rm tanpa ampun dan tidak bisa dibatalkan. Jika Anda ingin mencoba apa yang dilakukan sebelumnya, tambahkan tanda - n atau --dry-run untuk menguji semuanya. Step 3: Tambahkan ulang segala sesuatu ke repositori \u00b6 1 git add . Step 4: Commit \u00b6 1 git commit - m \".gitignore fix\" Repositori Anda telah bersih :) Push perubahan ke repositori remote Anda untuk melihat perubahannya dan pastikan bahwa repositori Anda sekarang mengalami perubahan.","title":"Hapus Jejak File"},{"location":"blog/2019/untrack-files/#hapus-jejak-file-yang-sudah-ditambahkan-ke-repositori-git-berdasarkan-gitignore","text":"Suatu saat Anda telah menambahkan / mengkomit beberapa file ke repositori git Anda dan kemudian ingin menambahkannya ke .gitignore; file-file ini akan tetap ada di indeks repositori Anda. Artikel ini akan membahas bagaimana cara menghilangkannya atau membersihkan repositori Anda.","title":"Hapus jejak file yang sudah ditambahkan ke repositori git berdasarkan .gitignore"},{"location":"blog/2019/untrack-files/#step-1-commit-semua-perubahan","text":"Sebelum melanjutkan, pastikan semua perubahan yang Anda lakukan telah di commit , termasuk file .gitignore .","title":"Step 1: Commit semua perubahan"},{"location":"blog/2019/untrack-files/#step-2-buang-segala-sesuatu-dari-repositori","text":"Untuk membersihkan repositori Anda, gunakan perintah: 1 git rm - r --cached . rm adalah perintah penghapusan - r memungkinkan penghapusan secara rekursif (menyeluruh) \u2013 cached hanya akan menghapus file dari indeks. Tetapi sebenarnya File Anda tetap ada di sana. . menunjukkan bahwa semua file tidak akan dilacak. Anda dapat menghapus file tertentu dengan perintah git rm --cached foo.txt . Perintah rm tanpa ampun dan tidak bisa dibatalkan. Jika Anda ingin mencoba apa yang dilakukan sebelumnya, tambahkan tanda - n atau --dry-run untuk menguji semuanya.","title":"Step 2: Buang segala sesuatu dari repositori"},{"location":"blog/2019/untrack-files/#step-3-tambahkan-ulang-segala-sesuatu-ke-repositori","text":"1 git add .","title":"Step 3: Tambahkan ulang segala sesuatu ke repositori"},{"location":"blog/2019/untrack-files/#step-4-commit","text":"1 git commit - m \".gitignore fix\" Repositori Anda telah bersih :) Push perubahan ke repositori remote Anda untuk melihat perubahannya dan pastikan bahwa repositori Anda sekarang mengalami perubahan.","title":"Step 4: Commit"},{"location":"blog/ext/admonition/","text":"Admonition \u00b6 Admonition adalah ekstensi yang disertakan ke dalam pustaka standar Markdown yang memungkinkan untuk menambahkan konten samping bergaya blok ke dokumentasi Anda, misalnya ringkasan, catatan, petunjuk atau peringatan. Instalasi \u00b6 Tambahkan baris berikut ke dalam mkdocs . yml : 1 2 markdown_extensions : - admonition Penggunaan \u00b6 Blok Admonition mengikuti sintaksis sederhana: setiap blok dimulai dengan !!! , diikuti oleh satu kata kunci yang digunakan sebagai tipe kualifikasi blok. Isi blok kemudian mengikuti pada baris berikutnya, dijorok dengan empat spasi. Contoh: 1 2 3 4 !!! note Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Mengubah Judul \u00b6 Secara default, judul blok akan sama dengan tipe kualifikasi dalam titlecase. Namun, ini dapat diubah dengan menambahkan string yang dikutip setelah tipe kualifikasi. Contoh: 1 2 3 4 !!! note \"Phasellus posuere in sem ut cursus\" Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Menghapus Judul \u00b6 Mirip dengan pengaturan judul khusus , ikon dan judul dapat dihilangkan dengan memberikan string kosong setelah kualifikasi jenis: Contoh: 1 2 3 4 !!! note \"\" Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Blok kode tertanam \u00b6 Blok dapat berisi semua jenis konten teks, termasuk tajuk utama, daftar, paragraf, dan blok lainnya - kecuali blok kode, karena parser dari standar pustaka Markdown tidak memperhitungkannya. Namun, paket Ekstensi PyMdown menambahkan ekstensi yang disebut SuperFences , yang memungkinkan untuk membuat blok kode di dalam blok lain, masing-masing blok Admonition. Contoh: Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. mysql SELECT Employees . EmployeeID , Employees . Name , Employees . Salary , Manager . Name AS Manager FROM Employees LEFT JOIN Employees AS Manager ON Employees . ManagerID = Manager . EmployeeID WHERE Employees . EmployeeID = '087652' ; Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim. Blok yang dapat dilipat \u00b6 Detail ekstensi yang juga merupakan bagian dari paket Ekstensi PyMdown menambahkan dukungan untuk rendering blok Admonition yang dapat dilipat. Ini berguna untuk FAQ atau konten yang bersifat sekunder. Blok yang dapat dilipat diawali dengan tanda ??? bukan dengan tanda !!! . Contoh: 1 2 3 4 ??? note \"Phasellus posuere in sem ut cursus\" Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Dengan menambahkan tanda + langsung setelah penanda awal, blok dapat dirender terbuka secara default. Tipe \u00b6 Admonition mendukung tipe kualifikasi yang ditentukan pengguna yang dapat mempengaruhi gaya blok yang dimasukkan. Berikut ini adalah daftar tipe kualifikasi yang disediakan oleh theme Material, sedangkan tipe default, untuk tipe kualifikasi yang tidak diketahui, ditetapkan sebagai note . Note \u00b6 Contoh: 1 2 3 4 !!! note Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: note seealso Abstact/Abstrak \u00b6 Contoh: 1 2 3 4 !!! abstract Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Abstract Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: abstract summary tldr Info \u00b6 Contoh: 1 2 3 4 !!! info Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Info Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: info todo Tip \u00b6 Contoh: 1 2 3 4 !!! tip Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Tip Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: tip hint important Success/Sukses \u00b6 Contoh: 1 2 3 4 !!! success Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Success Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: success check done Question/Pertanyaan \u00b6 Contoh: 1 2 3 4 !!! question Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Question Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: question help faq Warning/Perhatian \u00b6 Contoh: 1 2 3 4 !!! warning Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Warning Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: warning caution attention Failure/Kegagalan \u00b6 Contoh: 1 2 3 4 !!! failure Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Failure Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: failure fail missing Danger/Bahaya \u00b6 Contoh: 1 2 3 4 !!! danger Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Danger Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: danger error Bug/Kesalahan \u00b6 Contoh: 1 2 3 4 !!! bug Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Bug Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: bug Example/Contoh \u00b6 Contoh: 1 2 3 4 !!! example Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Example Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: example snippet Quote/Kutipan \u00b6 Contoh: 1 2 3 4 !!! quote Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: quote cite","title":"Admonition"},{"location":"blog/ext/admonition/#admonition","text":"Admonition adalah ekstensi yang disertakan ke dalam pustaka standar Markdown yang memungkinkan untuk menambahkan konten samping bergaya blok ke dokumentasi Anda, misalnya ringkasan, catatan, petunjuk atau peringatan.","title":"Admonition"},{"location":"blog/ext/admonition/#instalasi","text":"Tambahkan baris berikut ke dalam mkdocs . yml : 1 2 markdown_extensions : - admonition","title":"Instalasi"},{"location":"blog/ext/admonition/#penggunaan","text":"Blok Admonition mengikuti sintaksis sederhana: setiap blok dimulai dengan !!! , diikuti oleh satu kata kunci yang digunakan sebagai tipe kualifikasi blok. Isi blok kemudian mengikuti pada baris berikutnya, dijorok dengan empat spasi. Contoh: 1 2 3 4 !!! note Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.","title":"Penggunaan"},{"location":"blog/ext/admonition/#mengubah-judul","text":"Secara default, judul blok akan sama dengan tipe kualifikasi dalam titlecase. Namun, ini dapat diubah dengan menambahkan string yang dikutip setelah tipe kualifikasi. Contoh: 1 2 3 4 !!! note \"Phasellus posuere in sem ut cursus\" Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.","title":"Mengubah Judul"},{"location":"blog/ext/admonition/#menghapus-judul","text":"Mirip dengan pengaturan judul khusus , ikon dan judul dapat dihilangkan dengan memberikan string kosong setelah kualifikasi jenis: Contoh: 1 2 3 4 !!! note \"\" Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.","title":"Menghapus Judul"},{"location":"blog/ext/admonition/#blok-kode-tertanam","text":"Blok dapat berisi semua jenis konten teks, termasuk tajuk utama, daftar, paragraf, dan blok lainnya - kecuali blok kode, karena parser dari standar pustaka Markdown tidak memperhitungkannya. Namun, paket Ekstensi PyMdown menambahkan ekstensi yang disebut SuperFences , yang memungkinkan untuk membuat blok kode di dalam blok lain, masing-masing blok Admonition. Contoh: Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. mysql SELECT Employees . EmployeeID , Employees . Name , Employees . Salary , Manager . Name AS Manager FROM Employees LEFT JOIN Employees AS Manager ON Employees . ManagerID = Manager . EmployeeID WHERE Employees . EmployeeID = '087652' ; Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim.","title":"Blok kode tertanam"},{"location":"blog/ext/admonition/#blok-yang-dapat-dilipat","text":"Detail ekstensi yang juga merupakan bagian dari paket Ekstensi PyMdown menambahkan dukungan untuk rendering blok Admonition yang dapat dilipat. Ini berguna untuk FAQ atau konten yang bersifat sekunder. Blok yang dapat dilipat diawali dengan tanda ??? bukan dengan tanda !!! . Contoh: 1 2 3 4 ??? note \"Phasellus posuere in sem ut cursus\" Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Phasellus posuere in sem ut cursus Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Dengan menambahkan tanda + langsung setelah penanda awal, blok dapat dirender terbuka secara default.","title":"Blok yang dapat dilipat"},{"location":"blog/ext/admonition/#tipe","text":"Admonition mendukung tipe kualifikasi yang ditentukan pengguna yang dapat mempengaruhi gaya blok yang dimasukkan. Berikut ini adalah daftar tipe kualifikasi yang disediakan oleh theme Material, sedangkan tipe default, untuk tipe kualifikasi yang tidak diketahui, ditetapkan sebagai note .","title":"Tipe"},{"location":"blog/ext/admonition/#note","text":"Contoh: 1 2 3 4 !!! note Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: note seealso","title":"Note"},{"location":"blog/ext/admonition/#abstactabstrak","text":"Contoh: 1 2 3 4 !!! abstract Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Abstract Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: abstract summary tldr","title":"Abstact/Abstrak"},{"location":"blog/ext/admonition/#info","text":"Contoh: 1 2 3 4 !!! info Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Info Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: info todo","title":"Info"},{"location":"blog/ext/admonition/#tip","text":"Contoh: 1 2 3 4 !!! tip Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Tip Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: tip hint important","title":"Tip"},{"location":"blog/ext/admonition/#successsukses","text":"Contoh: 1 2 3 4 !!! success Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Success Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: success check done","title":"Success/Sukses"},{"location":"blog/ext/admonition/#questionpertanyaan","text":"Contoh: 1 2 3 4 !!! question Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Question Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: question help faq","title":"Question/Pertanyaan"},{"location":"blog/ext/admonition/#warningperhatian","text":"Contoh: 1 2 3 4 !!! warning Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Warning Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: warning caution attention","title":"Warning/Perhatian"},{"location":"blog/ext/admonition/#failurekegagalan","text":"Contoh: 1 2 3 4 !!! failure Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Failure Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: failure fail missing","title":"Failure/Kegagalan"},{"location":"blog/ext/admonition/#dangerbahaya","text":"Contoh: 1 2 3 4 !!! danger Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Danger Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: danger error","title":"Danger/Bahaya"},{"location":"blog/ext/admonition/#bugkesalahan","text":"Contoh: 1 2 3 4 !!! bug Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Bug Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: bug","title":"Bug/Kesalahan"},{"location":"blog/ext/admonition/#examplecontoh","text":"Contoh: 1 2 3 4 !!! example Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Example Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: example snippet","title":"Example/Contoh"},{"location":"blog/ext/admonition/#quotekutipan","text":"Contoh: 1 2 3 4 !!! quote Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Kualifikasi: quote cite","title":"Quote/Kutipan"},{"location":"blog/ext/codehilite/","text":"CodeHilite \u00b6 CodeHilite adalah ekstensi yang menambahkan penyorotan sintaks ke blok kode dan termasuk dalam standar pustaka Markdown. Proses penyorotan dijalankan selama kompilasi file Markdown. Syntax highlighting tidak berfungsi? Mohon pastikan bahwa Pygments sudah diinstal. Lihat bagian selanjutnya untuk petunjuk lebih lanjut tentang cara mengatur Pygments atau cara menggunakan Docker image dilaman resmi dengan semua dependensi yang sudah diinstal sebelumnya. Instalasi \u00b6 CodeHilite mem-parsing blok kode dan membungkusnya dalam tag pre . Jika Pygments sudah diinstal, yang merupakan sintaksis highlighter generik dengan dukungan lebih dari 300 bahasa , CodeHilite juga akan menyoroti blok kode. Pygments dapat diinstal dengan perintah berikut: 1 pip install pygments Untuk mengaktifkan CodeHilite, tambahkan baris berikut ke dalam mkdocs . yml : 1 2 markdown_extensions : - codehilite Penggunaan \u00b6 Menentukan bahasa \u00b6 Ekstensi CodeHilite menggunakan sintaksis yang sama seperti blok kode Markdown reguler, tetapi perlu diketahui bahasa blok kode yang akan digunakan. Ini dapat dilakukan dengan tiga cara berbeda. Melalui Sintaks Markdown direkomendasikan \u00b6 Didalam Markdown, blok kode dapat dibuka dan ditutup dengan menulis tiga backtick (tombolnya menyatu dengan tilde atau ~ bukan tanda kutip tunggal) pada baris terpisah. Untuk menambahkan penyorotan kode ke blok-blok itu, cara termudah adalah dengan menentukan bahasa yang akan digunakan secara langsung setelah blok pembuka. Contoh: 1 2 3 `` ` python import tensorflow as tf `` ` Hasil: 1 import tensorflow as tf Melalui Shebang \u00b6 Atau, jika baris pertama blok kode berisi shebang, bahasa tersebut berasal dari jalur yang dirujuk dalam shebang. Ini hanya akan berfungsi untuk blok kode yang indentasinya menggunakan empat spasi, bukan untuk yang dienkapsulasi dengan tiga backtick. Contoh: 1 2 #!/usr/bin/python import tensorflow as tf Hasil: 1 2 #!/usr/bin/python import tensorflow as tf Melalui Tiga Titik Dua \u00b6 Jika baris pertama dimulai dengan tiga titik dua diikuti oleh pengenal bahasa, baris pertama akan diabaikan. Ini hanya akan berfungsi untuk blok kode yang indentasinya menggunakan empat spasi, bukan untuk yang dienkapsulasi dengan tiga backtick. Contoh: 1 2 ::: python import tensorflow as tf Hasil: 1 import tensorflow as tf Menambahkan Nomor Baris \u00b6 Nomor baris dapat ditambahkan dengan mengaktifkan penanda linenums didalam mkdocs . yml : 1 2 3 markdown_extensions : - codehilite : linenums : true Contoh: 1 2 3 4 5 6 7 8 ``` python \"\"\" Bubble sort \"\"\" def bubble_sort ( items ) : for i in range ( len ( items )) : for j in range ( len ( items ) - 1 - i ) : if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] ``` Hasil: 1 2 3 4 5 6 \"\"\" Bubble sort \"\"\" def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Pengelompokan blok kode \u00b6 Ekstensi SuperFences merupakan bagian dari paket Ekstensi PyMdown yang menambahkan dukungan untuk pengelompokan blok kode dengan tab. Ini sangat berguna untuk mendokumentasikan proyek dengan jilidan banyak bahasa. Contoh: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ``` bash tab = \" Bash \" # !/ bin / bash echo \" Hello world! \" ``` ``` c tab = \" C \" # include < stdio . h > int main ( void ) { printf ( \" Hello world! \\n \" ) ; } ``` ``` c ++ tab = \" C++ \" # include < iostream > int main () { std :: cout << \" Hello world! \" << std :: endl ; return 0 ; } ``` ``` c # tab = \" C# \" using System ; class Program { static void Main ( string [] args ) { Console . WriteLine ( \" Hello world! \" ) ; } } ``` Hasil: ``` bash tab=\"Bash\" !/bin/bash \u00b6 echo \"Hello world!\" 1 2 3 4 5 6 ``` c tab = \" C \" # include < stdio . h > int main ( void ) { printf ( \" Hello world! \\n \" ) ; } ``` c++ tab=\"C++\" include \u00b6 int main() { std::cout << \"Hello world!\" << std::endl; return 0; } 1 2 3 4 5 6 7 8 ``` c # tab = \"C#\" using System ; class Program { static void Main ( string [] args ) { Console . WriteLine ( \"Hello world!\" ); } } Menyoroti baris tertentu \u00b6 Baris khusus dapat disorot dengan melewati nomor baris ke argumen hl_lines yang ditempatkan tepat setelah pengidentifikasian bahasa. Hitungan baris dimulai dari 1. Contoh: 1 2 3 4 5 6 7 8 ``` python hl_lines = \" 3 4 \" \"\"\" Bubble sort \"\"\" def bubble_sort ( items ) : for i in range ( len ( items )) : for j in range ( len ( items ) - 1 - i ) : if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] ``` Hasil: 1 2 3 4 5 6 \"\"\" Bubble sort \"\"\" def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Bahasa yang didukung kutipan \u00b6 CodeHilite menggunakan Pygments , sebuah highlighter sintaksis generik dengan dukungan untuk lebih dari 300 bahasa , dibawah ini daftar contoh dari kutipan beberapa jenis bahasa saja. Bash \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #!/bin/bash for OPT in \" $@ \" do case \" $OPT \" in '-f' ) canonicalize = 1 ;; '-n' ) switchlf = \"-n\" ;; esac done # readlink -f function __readlink_f { target = \" $1 \" while test -n \" $target \" ; do filepath = \" $target \" cd ` dirname \" $filepath \" ` target = ` readlink \" $filepath \" ` done /bin/echo $switchlf ` pwd -P ` / ` basename \" $filepath \" ` } if [ ! \" $canonicalize \" ] ; then readlink $switchlf \" $@ \" else for file in \" $@ \" do case \" $file \" in -* ) ;; * ) __readlink_f \" $file \" ;; esac done fi exit $? C \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 extern size_t pb_varint_scan ( const uint8_t data [], size_t left ) { assert ( data && left ); left = left > 10 ? 10 : left ; #ifdef __SSE2__ /* Mapping: remaining bytes ==> bitmask */ static const int mask_map [] = { 0x0000 , 0x0001 , 0x0003 , 0x0007 , 0x000F , 0x001F , 0x003F , 0x007F , 0x00FF , 0x01FF , 0x03FF }; /* Load buffer into 128-bit integer and create high-bit mask */ __m128i temp = _mm_loadu_si128 (( const __m128i * ) data ); __m128i high = _mm_set1_epi8 ( 0x80 ); /* Intersect and extract mask with high-bits set */ int mask = _mm_movemask_epi8 ( _mm_and_si128 ( temp , high )); mask = ( mask & mask_map [ left ]) ^ mask_map [ left ]; /* Count trailing zeroes */ return mask ? __builtin_ctz ( mask ) + 1 : 0 ; #else /* Linear scan */ size_t size = 0 ; while ( data [ size ++ ] & 0x80 ) if ( !-- left ) return 0 ; return size ; #endif /* __SSE2__ */ } C++ \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Extension :: Extension ( const Descriptor * descriptor , const Descriptor * scope ) : descriptor_ ( descriptor ), scope_ ( scope ) { /* Extract full name for signature */ variables_ [ \"signature\" ] = descriptor_ -> full_name (); /* Prepare message symbol */ variables_ [ \"message\" ] = StringReplace ( variables_ [ \"signature\" ], \".\" , \"_\" , true ); LowerString ( & ( variables_ [ \"message\" ])); /* Suffix scope to identifiers, if given */ string suffix ( \"\" ); if ( scope_ ) { suffix = scope_ -> full_name (); /* Check if the base and extension types are in the same package */ if ( ! scope_ -> file () -> package (). compare ( descriptor_ -> file () -> package ())) suffix = StripPrefixString ( suffix , scope_ -> file () -> package () + \".\" ); /* Append to signature */ variables_ [ \"signature\" ] += \".[\" + suffix + \"]\" ; suffix = \"_\" + suffix ; } /* Prepare extension symbol */ variables_ [ \"extension\" ] = StringReplace ( suffix , \".\" , \"_\" , true ); LowerString ( & ( variables_ [ \"extension\" ])); } C# \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static void Send ( Socket socket , byte [] buffer , int offset , int size , int timeout ) { int startTickCount = Environment . TickCount ; int sent = 0 ; do { if ( Environment . TickCount > startTickCount + timeout ) throw new Exception ( \"Timeout.\" ); try { sent += socket . Send ( buffer , offset + sent , size - sent , SocketFlags . None ); } catch ( SocketException ex ) { if ( ex . SocketErrorCode == SocketError . WouldBlock || ex . SocketErrorCode == SocketError . IOPending || ex . SocketErrorCode == SocketError . NoBufferSpaceAvailable ) { /* Socket buffer is probably full, wait and try again */ Thread . Sleep ( 30 ); } else { throw ex ; } } } while ( sent < size ); } Clojure \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ( clojure-version ) ( defn partition-when [ f ] ( fn [ rf ] ( let [ a ( java.util.ArrayList. ) fval ( volatile! false )] ( fn ([] ( rf )) ([ result ] ( let [ result ( if ( .isEmpty a ) result ( let [ v ( vec ( .toArray a ))] ;; Clear first ( .clear a ) ( unreduced ( rf result v ))))] ( rf result ))) ([ result input ] ( if-not ( and ( f input ) @ fval ) ( do ( vreset! fval true ) ( .add a input ) result ) ( let [ v ( vec ( .toArray a ))] ( .clear a ) ( let [ ret ( rf result v )] ( when-not ( reduced? ret ) ( .add a input )) ret )))))))) ( into [] ( partition-when # ( .startsWith % \">>\" )) [ \"1d\" \"33\" \">> 1\" \">> 2\" \"22\" \">> 3\" ]) Diff \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Index: grunt.js =================================================================== --- grunt.js (revision 31200) +++ grunt.js (working copy) @@ -12,6 +12,7 @@ module.exports = function (grunt) { + console.log('hello world'); // Project configuration. grunt.initConfig({ lint: { @@ -19,10 +20,6 @@ 'packages/services.web/{!(test)/**/,}*.js', 'packages/error/**/*.js' ], - scripts: [ - 'grunt.js', - 'db/**/*.js' - ], browser: [ 'packages/web/server.js', 'packages/web/server/**/*.js', Docker \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 FROM ubuntu # Install vnc, xvfb in order to create a 'fake' display and firefox RUN apt-get update && apt-get install -y x11vnc xvfb firefox RUN mkdir ~/.vnc # Setup a password RUN x11vnc -storepasswd 1234 ~/.vnc/passwd # Autostart firefox (might not be the best way, but it does the trick) RUN bash -c 'echo \"firefox\" >> /.bashrc' EXPOSE 5900 CMD [ \"x11vnc\" , \"-forever\" , \"-usepw\" , \"-create\" ] Elixir \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 require Logger def accept ( port ) do { :ok , socket } = :gen_tcp . listen ( port , [ :binary , packet : :line , active : false , reuseaddr : true ]) Logger . info \"Accepting connections on port #{ port } \" loop_acceptor ( socket ) end defp loop_acceptor ( socket ) do { :ok , client } = :gen_tcp . accept ( socket ) serve ( client ) loop_acceptor ( socket ) end defp serve ( socket ) do socket |> read_line () |> write_line ( socket ) serve ( socket ) end defp read_line ( socket ) do { :ok , data } = :gen_tcp . recv ( socket , 0 ) data end defp write_line ( line , socket ) do :gen_tcp . send ( socket , line ) end Erlang \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 circular ( Defs ) -> [ { { Type , Base }, Fields } || { { Type , Base }, Fields } <- Defs , Type == msg , circular ( Base , Defs ) ]. circular ( Base , Defs ) -> Fields = proplists : get_value ({ msg , Base }, Defs ), circular ( Defs , Fields , [ Base ]). circular (_ Defs , [], _ Path ) -> false ; circular ( Defs , [ Field | Fields ], Path ) -> case Field #field.type of { msg , Type } -> case lists : member ( Type , Path ) of false -> Children = proplists : get_value ({ msg , Type }, Defs ), case circular ( Defs , Children , [ Type | Path ]) of false -> circular ( Defs , Fields , Path ); true -> true end ; true -> Type == lists : last ( Path ) andalso ( length ( Path ) == 1 orelse not is_tree ( Path )) end ; _ -> circular ( Defs , Fields , Path ) end . F# \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /// Asynchronously download retangles from the server /// and decode the JSON format to F# Rectangle record let [< Js >] getRectangles () : Async < Rectangle [] > = async { let req = XMLHttpRequest () req . Open ( \"POST\" , \"/get\" , true ) let! resp = req . AsyncSend () return JSON . parse ( resp ) } /// Repeatedly update rectangles after 0.5 sec let [< Js >] updateLoop () = async { while true do do ! Async . Sleep ( 500 ) let! rects = getRectangles () cleanRectangles () rects |> Array . iter createRectangle } Go \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \"fmt\" func counter ( id int , channel chan int , closer bool ) { for i := 0 ; i < 10000000 ; i ++ { fmt . Println ( \"process\" , id , \" send\" , i ) channel <- 1 } if closer { close ( channel ) } } func main () { channel := make ( chan int ) go counter ( 1 , channel , false ) go counter ( 2 , channel , true ) x := 0 // receiving data from channel for i := range channel { fmt . Println ( \"receiving\" ) x += i } fmt . Println ( x ) } HTML \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!doctype html> < html class = \"no-js\" lang = \"\" > < head > < meta charset = \"utf-8\" > < meta http-equiv = \"x-ua-compatible\" content = \"ie=edge\" > < title > HTML5 Boilerplate </ title > < meta name = \"description\" content = \"\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1\" > < link rel = \"apple-touch-icon\" href = \"apple-touch-icon.png\" > < link rel = \"stylesheet\" href = \"css/normalize.css\" > < link rel = \"stylesheet\" href = \"css/main.css\" > < script src = \"js/vendor/modernizr-2.8.3.min.js\" ></ script > </ head > < body > < p > Hello world! This is HTML5 Boilerplate. </ p > </ body > </ html > Java \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import java.util.LinkedList ; import java.lang.reflect.Array ; public class UnsortedHashSet < E > { private static final double LOAD_FACTOR_LIMIT = 0.7 ; private int size ; private LinkedList < E >[] con ; public UnsortedHashSet () { con = ( LinkedList < E >[])( new LinkedList [ 10 ]); } public boolean add ( E obj ) { int oldSize = size ; int index = Math . abs ( obj . hashCode ()) % con . length ; if ( con [ index ] == null ) con [ index ] = new LinkedList < E >(); if (! con [ index ]. contains ( obj )) { con [ index ]. add ( obj ); size ++; } if ( 1.0 * size / con . length > LOAD_FACTOR_LIMIT ) resize (); return oldSize != size ; } private void resize () { UnsortedHashSet < E > temp = new UnsortedHashSet < E >(); temp . con = ( LinkedList < E >[])( new LinkedList [ con . length * 2 + 1 ]); for ( int i = 0 ; i < con . length ; i ++) { if ( con [ i ] != null ) for ( E e : con [ i ]) temp . add ( e ); } con = temp . con ; } public int size () { return size ; } } JavaScript \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var Math = require ( 'lib/math' ); var _extends = function ( target ) { for ( var i = 1 ; i < arguments . length ; i ++ ) { var source = arguments [ i ]; for ( var key in source ) { target [ key ] = source [ key ]; } } return target ; }; var e = exports . e = 2.71828182846 ; exports [ 'default' ] = function ( x ) { return Math . exp ( x ); }; module . exports = _extends ( exports [ 'default' ], exports ); JSON \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"name\" : \"mkdocs-material\" , \"version\" : \"0.2.4\" , \"description\" : \"A Material Design theme for MkDocs\" , \"homepage\" : \"http://squidfunk.github.io/mkdocs-material/\" , \"authors\" : [ \"squidfunk <martin.donath@squidfunk.com>\" ], \"license\" : \"MIT\" , \"main\" : \"Gulpfile.js\" , \"scripts\" : { \"start\" : \"./node_modules/.bin/gulp watch --mkdocs\" , \"build\" : \"./node_modules/.bin/gulp build --production\" } ... } Julia \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 using MXNet mlp = @mx . chain mx . Variable ( : data ) => mx . FullyConnected ( name =: fc1 , num_hidden = 128 ) => mx . Activation ( name =: relu1 , act_type =: relu ) => mx . FullyConnected ( name =: fc2 , num_hidden = 64 ) => mx . Activation ( name =: relu2 , act_type =: relu ) => mx . FullyConnected ( name =: fc3 , num_hidden = 10 ) => mx . SoftmaxOutput ( name =: softmax ) # data provider batch_size = 100 include ( Pkg . dir ( \"MXNet\" , \"examples\" , \"mnist\" , \"mnist-data.jl\" )) train_provider , eval_provider = get_mnist_providers ( batch_size ) # setup model model = mx . FeedForward ( mlp , context = mx . cpu ()) # optimization algorithm optimizer = mx . SGD ( lr = 0.1 , momentum = 0.9 ) # fit parameters mx . fit ( model , optimizer , train_provider , n_epoch = 20 , eval_data = eval_provider ) Lua \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 local ffi = require ( \"ffi\" ) ffi . cdef [[ void Sleep(int ms); int poll(struct pollfd *fds, unsigned long nfds, int timeout); ]] local sleep if ffi . os == \"Windows\" then function sleep ( s ) ffi . C . Sleep ( s * 1000 ) end else function sleep ( s ) ffi . C . poll ( nil , 0 , s * 1000 ) end end for i = 1 , 160 do io.write ( \".\" ); io.flush () sleep ( 0.01 ) end io.write ( \" \\n \" ) MySQL \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 SELECT Employees . EmployeeID , Employees . Name , Employees . Salary , Manager . Name AS Manager FROM Employees LEFT JOIN Employees AS Manager ON Employees . ManagerID = Manager . EmployeeID WHERE Employees . EmployeeID = '087652' ; PHP \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <?php // src/AppBundle/Controller/LuckyController.php namespace AppBundle\\Controller ; use Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Route ; use Symfony\\Component\\HttpFoundation\\Response ; class LuckyController { /** * @Route(\"/lucky/number\") */ public function numberAction () { $number = mt_rand ( 0 , 100 ); return new Response ( '<html><body>Lucky number: ' . $number . '</body></html>' ); } } Protocol Buffers \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 syntax = \"proto2\" ; package caffe ; // Specifies the shape (dimensions) of a Blob. message BlobShape { repeated int64 dim = 1 [ packed = true ]; } message BlobProto { optional BlobShape shape = 7 ; repeated float data = 5 [ packed = true ]; repeated float diff = 6 [ packed = true ]; // 4D dimensions -- deprecated. Use \"shape\" instead. optional int32 num = 1 [ default = 0 ]; optional int32 channels = 2 [ default = 0 ]; optional int32 height = 3 [ default = 0 ]; optional int32 width = 4 [ default = 0 ]; } Python \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \"\"\" A very simple MNIST classifier. See extensive documentation at http://tensorflow.org/tutorials/mnist/beginners/index.md \"\"\" from __future__ import absolute_import from __future__ import division from __future__ import print_function # Import data from tensorflow.examples.tutorials.mnist import input_data import tensorflow as tf flags = tf . app . flags FLAGS = flags . FLAGS flags . DEFINE_string ( 'data_dir' , '/tmp/data/' , 'Directory for storing data' ) mnist = input_data . read_data_sets ( FLAGS . data_dir , one_hot = True ) sess = tf . InteractiveSession () # Create the model x = tf . placeholder ( tf . float32 , [ None , 784 ]) W = tf . Variable ( tf . zeros ([ 784 , 10 ])) b = tf . Variable ( tf . zeros ([ 10 ])) y = tf . nn . softmax ( tf . matmul ( x , W ) + b ) Ruby \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 require 'finity/event' require 'finity/machine' require 'finity/state' require 'finity/transition' require 'finity/version' module Finity class InvalidCallback < StandardError ; end class MissingCallback < StandardError ; end class InvalidState < StandardError ; end # Class methods to be injected into the including class upon inclusion. module ClassMethods # Instantiate a new state machine for the including class by accepting a # block with state and event (and subsequent transition) definitions. def finity options = {}, & block @finity ||= Machine . new self , options , & block end # Return the names of all registered states. def states @finity . states . map { | name , _ | name } end # Return the names of all registered events. def events @finity . events . map { | name , _ | name } end end # Inject methods into the including class upon inclusion. def self . included base base . extend ClassMethods end end XML \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE mainTag SYSTEM \"some.dtd\" [ENTITY % entity]> <?oxygen RNGSchema=\"some.rng\" type=\"xml\"?> <xs:main-Tag xmlns:xs= \"http://www.w3.org/2001/XMLSchema\" > <!-- This is a sample comment --> <childTag attribute= \"Quoted Value\" another-attribute= 'Single quoted value' a-third-attribute= '123' > <withTextContent> Some text content </withTextContent> <withEntityContent> Some text content with &lt; entities &gt; and mentioning uint8_t and int32_t </withEntityContent> <otherTag attribute= 'Single quoted Value' /> </childTag> <![CDATA[ some CData ]]> </main-Tag>","title":"Codehilite"},{"location":"blog/ext/codehilite/#codehilite","text":"CodeHilite adalah ekstensi yang menambahkan penyorotan sintaks ke blok kode dan termasuk dalam standar pustaka Markdown. Proses penyorotan dijalankan selama kompilasi file Markdown. Syntax highlighting tidak berfungsi? Mohon pastikan bahwa Pygments sudah diinstal. Lihat bagian selanjutnya untuk petunjuk lebih lanjut tentang cara mengatur Pygments atau cara menggunakan Docker image dilaman resmi dengan semua dependensi yang sudah diinstal sebelumnya.","title":"CodeHilite"},{"location":"blog/ext/codehilite/#instalasi","text":"CodeHilite mem-parsing blok kode dan membungkusnya dalam tag pre . Jika Pygments sudah diinstal, yang merupakan sintaksis highlighter generik dengan dukungan lebih dari 300 bahasa , CodeHilite juga akan menyoroti blok kode. Pygments dapat diinstal dengan perintah berikut: 1 pip install pygments Untuk mengaktifkan CodeHilite, tambahkan baris berikut ke dalam mkdocs . yml : 1 2 markdown_extensions : - codehilite","title":"Instalasi"},{"location":"blog/ext/codehilite/#penggunaan","text":"","title":"Penggunaan"},{"location":"blog/ext/codehilite/#menentukan-bahasa","text":"Ekstensi CodeHilite menggunakan sintaksis yang sama seperti blok kode Markdown reguler, tetapi perlu diketahui bahasa blok kode yang akan digunakan. Ini dapat dilakukan dengan tiga cara berbeda.","title":"Menentukan bahasa"},{"location":"blog/ext/codehilite/#melalui-sintaks-markdown-direkomendasikan","text":"Didalam Markdown, blok kode dapat dibuka dan ditutup dengan menulis tiga backtick (tombolnya menyatu dengan tilde atau ~ bukan tanda kutip tunggal) pada baris terpisah. Untuk menambahkan penyorotan kode ke blok-blok itu, cara termudah adalah dengan menentukan bahasa yang akan digunakan secara langsung setelah blok pembuka. Contoh: 1 2 3 `` ` python import tensorflow as tf `` ` Hasil: 1 import tensorflow as tf","title":"Melalui Sintaks Markdown direkomendasikan"},{"location":"blog/ext/codehilite/#melalui-shebang","text":"Atau, jika baris pertama blok kode berisi shebang, bahasa tersebut berasal dari jalur yang dirujuk dalam shebang. Ini hanya akan berfungsi untuk blok kode yang indentasinya menggunakan empat spasi, bukan untuk yang dienkapsulasi dengan tiga backtick. Contoh: 1 2 #!/usr/bin/python import tensorflow as tf Hasil: 1 2 #!/usr/bin/python import tensorflow as tf","title":"Melalui Shebang"},{"location":"blog/ext/codehilite/#melalui-tiga-titik-dua","text":"Jika baris pertama dimulai dengan tiga titik dua diikuti oleh pengenal bahasa, baris pertama akan diabaikan. Ini hanya akan berfungsi untuk blok kode yang indentasinya menggunakan empat spasi, bukan untuk yang dienkapsulasi dengan tiga backtick. Contoh: 1 2 ::: python import tensorflow as tf Hasil: 1 import tensorflow as tf","title":"Melalui Tiga Titik Dua"},{"location":"blog/ext/codehilite/#menambahkan-nomor-baris","text":"Nomor baris dapat ditambahkan dengan mengaktifkan penanda linenums didalam mkdocs . yml : 1 2 3 markdown_extensions : - codehilite : linenums : true Contoh: 1 2 3 4 5 6 7 8 ``` python \"\"\" Bubble sort \"\"\" def bubble_sort ( items ) : for i in range ( len ( items )) : for j in range ( len ( items ) - 1 - i ) : if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] ``` Hasil: 1 2 3 4 5 6 \"\"\" Bubble sort \"\"\" def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ]","title":"Menambahkan Nomor Baris"},{"location":"blog/ext/codehilite/#pengelompokan-blok-kode","text":"Ekstensi SuperFences merupakan bagian dari paket Ekstensi PyMdown yang menambahkan dukungan untuk pengelompokan blok kode dengan tab. Ini sangat berguna untuk mendokumentasikan proyek dengan jilidan banyak bahasa. Contoh: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ``` bash tab = \" Bash \" # !/ bin / bash echo \" Hello world! \" ``` ``` c tab = \" C \" # include < stdio . h > int main ( void ) { printf ( \" Hello world! \\n \" ) ; } ``` ``` c ++ tab = \" C++ \" # include < iostream > int main () { std :: cout << \" Hello world! \" << std :: endl ; return 0 ; } ``` ``` c # tab = \" C# \" using System ; class Program { static void Main ( string [] args ) { Console . WriteLine ( \" Hello world! \" ) ; } } ``` Hasil: ``` bash tab=\"Bash\"","title":"Pengelompokan blok kode"},{"location":"blog/ext/codehilite/#binbash","text":"echo \"Hello world!\" 1 2 3 4 5 6 ``` c tab = \" C \" # include < stdio . h > int main ( void ) { printf ( \" Hello world! \\n \" ) ; } ``` c++ tab=\"C++\"","title":"!/bin/bash"},{"location":"blog/ext/codehilite/#include","text":"int main() { std::cout << \"Hello world!\" << std::endl; return 0; } 1 2 3 4 5 6 7 8 ``` c # tab = \"C#\" using System ; class Program { static void Main ( string [] args ) { Console . WriteLine ( \"Hello world!\" ); } }","title":"include "},{"location":"blog/ext/codehilite/#menyoroti-baris-tertentu","text":"Baris khusus dapat disorot dengan melewati nomor baris ke argumen hl_lines yang ditempatkan tepat setelah pengidentifikasian bahasa. Hitungan baris dimulai dari 1. Contoh: 1 2 3 4 5 6 7 8 ``` python hl_lines = \" 3 4 \" \"\"\" Bubble sort \"\"\" def bubble_sort ( items ) : for i in range ( len ( items )) : for j in range ( len ( items ) - 1 - i ) : if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] ``` Hasil: 1 2 3 4 5 6 \"\"\" Bubble sort \"\"\" def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ]","title":"Menyoroti baris tertentu"},{"location":"blog/ext/codehilite/#bahasa-yang-didukung-kutipan","text":"CodeHilite menggunakan Pygments , sebuah highlighter sintaksis generik dengan dukungan untuk lebih dari 300 bahasa , dibawah ini daftar contoh dari kutipan beberapa jenis bahasa saja.","title":"Bahasa yang didukung kutipan"},{"location":"blog/ext/codehilite/#bash","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #!/bin/bash for OPT in \" $@ \" do case \" $OPT \" in '-f' ) canonicalize = 1 ;; '-n' ) switchlf = \"-n\" ;; esac done # readlink -f function __readlink_f { target = \" $1 \" while test -n \" $target \" ; do filepath = \" $target \" cd ` dirname \" $filepath \" ` target = ` readlink \" $filepath \" ` done /bin/echo $switchlf ` pwd -P ` / ` basename \" $filepath \" ` } if [ ! \" $canonicalize \" ] ; then readlink $switchlf \" $@ \" else for file in \" $@ \" do case \" $file \" in -* ) ;; * ) __readlink_f \" $file \" ;; esac done fi exit $?","title":"Bash"},{"location":"blog/ext/codehilite/#c","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 extern size_t pb_varint_scan ( const uint8_t data [], size_t left ) { assert ( data && left ); left = left > 10 ? 10 : left ; #ifdef __SSE2__ /* Mapping: remaining bytes ==> bitmask */ static const int mask_map [] = { 0x0000 , 0x0001 , 0x0003 , 0x0007 , 0x000F , 0x001F , 0x003F , 0x007F , 0x00FF , 0x01FF , 0x03FF }; /* Load buffer into 128-bit integer and create high-bit mask */ __m128i temp = _mm_loadu_si128 (( const __m128i * ) data ); __m128i high = _mm_set1_epi8 ( 0x80 ); /* Intersect and extract mask with high-bits set */ int mask = _mm_movemask_epi8 ( _mm_and_si128 ( temp , high )); mask = ( mask & mask_map [ left ]) ^ mask_map [ left ]; /* Count trailing zeroes */ return mask ? __builtin_ctz ( mask ) + 1 : 0 ; #else /* Linear scan */ size_t size = 0 ; while ( data [ size ++ ] & 0x80 ) if ( !-- left ) return 0 ; return size ; #endif /* __SSE2__ */ }","title":"C"},{"location":"blog/ext/codehilite/#c_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Extension :: Extension ( const Descriptor * descriptor , const Descriptor * scope ) : descriptor_ ( descriptor ), scope_ ( scope ) { /* Extract full name for signature */ variables_ [ \"signature\" ] = descriptor_ -> full_name (); /* Prepare message symbol */ variables_ [ \"message\" ] = StringReplace ( variables_ [ \"signature\" ], \".\" , \"_\" , true ); LowerString ( & ( variables_ [ \"message\" ])); /* Suffix scope to identifiers, if given */ string suffix ( \"\" ); if ( scope_ ) { suffix = scope_ -> full_name (); /* Check if the base and extension types are in the same package */ if ( ! scope_ -> file () -> package (). compare ( descriptor_ -> file () -> package ())) suffix = StripPrefixString ( suffix , scope_ -> file () -> package () + \".\" ); /* Append to signature */ variables_ [ \"signature\" ] += \".[\" + suffix + \"]\" ; suffix = \"_\" + suffix ; } /* Prepare extension symbol */ variables_ [ \"extension\" ] = StringReplace ( suffix , \".\" , \"_\" , true ); LowerString ( & ( variables_ [ \"extension\" ])); }","title":"C++"},{"location":"blog/ext/codehilite/#c_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static void Send ( Socket socket , byte [] buffer , int offset , int size , int timeout ) { int startTickCount = Environment . TickCount ; int sent = 0 ; do { if ( Environment . TickCount > startTickCount + timeout ) throw new Exception ( \"Timeout.\" ); try { sent += socket . Send ( buffer , offset + sent , size - sent , SocketFlags . None ); } catch ( SocketException ex ) { if ( ex . SocketErrorCode == SocketError . WouldBlock || ex . SocketErrorCode == SocketError . IOPending || ex . SocketErrorCode == SocketError . NoBufferSpaceAvailable ) { /* Socket buffer is probably full, wait and try again */ Thread . Sleep ( 30 ); } else { throw ex ; } } } while ( sent < size ); }","title":"C&#35;"},{"location":"blog/ext/codehilite/#clojure","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ( clojure-version ) ( defn partition-when [ f ] ( fn [ rf ] ( let [ a ( java.util.ArrayList. ) fval ( volatile! false )] ( fn ([] ( rf )) ([ result ] ( let [ result ( if ( .isEmpty a ) result ( let [ v ( vec ( .toArray a ))] ;; Clear first ( .clear a ) ( unreduced ( rf result v ))))] ( rf result ))) ([ result input ] ( if-not ( and ( f input ) @ fval ) ( do ( vreset! fval true ) ( .add a input ) result ) ( let [ v ( vec ( .toArray a ))] ( .clear a ) ( let [ ret ( rf result v )] ( when-not ( reduced? ret ) ( .add a input )) ret )))))))) ( into [] ( partition-when # ( .startsWith % \">>\" )) [ \"1d\" \"33\" \">> 1\" \">> 2\" \"22\" \">> 3\" ])","title":"Clojure"},{"location":"blog/ext/codehilite/#diff","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Index: grunt.js =================================================================== --- grunt.js (revision 31200) +++ grunt.js (working copy) @@ -12,6 +12,7 @@ module.exports = function (grunt) { + console.log('hello world'); // Project configuration. grunt.initConfig({ lint: { @@ -19,10 +20,6 @@ 'packages/services.web/{!(test)/**/,}*.js', 'packages/error/**/*.js' ], - scripts: [ - 'grunt.js', - 'db/**/*.js' - ], browser: [ 'packages/web/server.js', 'packages/web/server/**/*.js',","title":"Diff"},{"location":"blog/ext/codehilite/#docker","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 FROM ubuntu # Install vnc, xvfb in order to create a 'fake' display and firefox RUN apt-get update && apt-get install -y x11vnc xvfb firefox RUN mkdir ~/.vnc # Setup a password RUN x11vnc -storepasswd 1234 ~/.vnc/passwd # Autostart firefox (might not be the best way, but it does the trick) RUN bash -c 'echo \"firefox\" >> /.bashrc' EXPOSE 5900 CMD [ \"x11vnc\" , \"-forever\" , \"-usepw\" , \"-create\" ]","title":"Docker"},{"location":"blog/ext/codehilite/#elixir","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 require Logger def accept ( port ) do { :ok , socket } = :gen_tcp . listen ( port , [ :binary , packet : :line , active : false , reuseaddr : true ]) Logger . info \"Accepting connections on port #{ port } \" loop_acceptor ( socket ) end defp loop_acceptor ( socket ) do { :ok , client } = :gen_tcp . accept ( socket ) serve ( client ) loop_acceptor ( socket ) end defp serve ( socket ) do socket |> read_line () |> write_line ( socket ) serve ( socket ) end defp read_line ( socket ) do { :ok , data } = :gen_tcp . recv ( socket , 0 ) data end defp write_line ( line , socket ) do :gen_tcp . send ( socket , line ) end","title":"Elixir"},{"location":"blog/ext/codehilite/#erlang","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 circular ( Defs ) -> [ { { Type , Base }, Fields } || { { Type , Base }, Fields } <- Defs , Type == msg , circular ( Base , Defs ) ]. circular ( Base , Defs ) -> Fields = proplists : get_value ({ msg , Base }, Defs ), circular ( Defs , Fields , [ Base ]). circular (_ Defs , [], _ Path ) -> false ; circular ( Defs , [ Field | Fields ], Path ) -> case Field #field.type of { msg , Type } -> case lists : member ( Type , Path ) of false -> Children = proplists : get_value ({ msg , Type }, Defs ), case circular ( Defs , Children , [ Type | Path ]) of false -> circular ( Defs , Fields , Path ); true -> true end ; true -> Type == lists : last ( Path ) andalso ( length ( Path ) == 1 orelse not is_tree ( Path )) end ; _ -> circular ( Defs , Fields , Path ) end .","title":"Erlang"},{"location":"blog/ext/codehilite/#f","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /// Asynchronously download retangles from the server /// and decode the JSON format to F# Rectangle record let [< Js >] getRectangles () : Async < Rectangle [] > = async { let req = XMLHttpRequest () req . Open ( \"POST\" , \"/get\" , true ) let! resp = req . AsyncSend () return JSON . parse ( resp ) } /// Repeatedly update rectangles after 0.5 sec let [< Js >] updateLoop () = async { while true do do ! Async . Sleep ( 500 ) let! rects = getRectangles () cleanRectangles () rects |> Array . iter createRectangle }","title":"F&#35;"},{"location":"blog/ext/codehilite/#go","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \"fmt\" func counter ( id int , channel chan int , closer bool ) { for i := 0 ; i < 10000000 ; i ++ { fmt . Println ( \"process\" , id , \" send\" , i ) channel <- 1 } if closer { close ( channel ) } } func main () { channel := make ( chan int ) go counter ( 1 , channel , false ) go counter ( 2 , channel , true ) x := 0 // receiving data from channel for i := range channel { fmt . Println ( \"receiving\" ) x += i } fmt . Println ( x ) }","title":"Go"},{"location":"blog/ext/codehilite/#html","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!doctype html> < html class = \"no-js\" lang = \"\" > < head > < meta charset = \"utf-8\" > < meta http-equiv = \"x-ua-compatible\" content = \"ie=edge\" > < title > HTML5 Boilerplate </ title > < meta name = \"description\" content = \"\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1\" > < link rel = \"apple-touch-icon\" href = \"apple-touch-icon.png\" > < link rel = \"stylesheet\" href = \"css/normalize.css\" > < link rel = \"stylesheet\" href = \"css/main.css\" > < script src = \"js/vendor/modernizr-2.8.3.min.js\" ></ script > </ head > < body > < p > Hello world! This is HTML5 Boilerplate. </ p > </ body > </ html >","title":"HTML"},{"location":"blog/ext/codehilite/#java","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import java.util.LinkedList ; import java.lang.reflect.Array ; public class UnsortedHashSet < E > { private static final double LOAD_FACTOR_LIMIT = 0.7 ; private int size ; private LinkedList < E >[] con ; public UnsortedHashSet () { con = ( LinkedList < E >[])( new LinkedList [ 10 ]); } public boolean add ( E obj ) { int oldSize = size ; int index = Math . abs ( obj . hashCode ()) % con . length ; if ( con [ index ] == null ) con [ index ] = new LinkedList < E >(); if (! con [ index ]. contains ( obj )) { con [ index ]. add ( obj ); size ++; } if ( 1.0 * size / con . length > LOAD_FACTOR_LIMIT ) resize (); return oldSize != size ; } private void resize () { UnsortedHashSet < E > temp = new UnsortedHashSet < E >(); temp . con = ( LinkedList < E >[])( new LinkedList [ con . length * 2 + 1 ]); for ( int i = 0 ; i < con . length ; i ++) { if ( con [ i ] != null ) for ( E e : con [ i ]) temp . add ( e ); } con = temp . con ; } public int size () { return size ; } }","title":"Java"},{"location":"blog/ext/codehilite/#javascript","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var Math = require ( 'lib/math' ); var _extends = function ( target ) { for ( var i = 1 ; i < arguments . length ; i ++ ) { var source = arguments [ i ]; for ( var key in source ) { target [ key ] = source [ key ]; } } return target ; }; var e = exports . e = 2.71828182846 ; exports [ 'default' ] = function ( x ) { return Math . exp ( x ); }; module . exports = _extends ( exports [ 'default' ], exports );","title":"JavaScript"},{"location":"blog/ext/codehilite/#json","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"name\" : \"mkdocs-material\" , \"version\" : \"0.2.4\" , \"description\" : \"A Material Design theme for MkDocs\" , \"homepage\" : \"http://squidfunk.github.io/mkdocs-material/\" , \"authors\" : [ \"squidfunk <martin.donath@squidfunk.com>\" ], \"license\" : \"MIT\" , \"main\" : \"Gulpfile.js\" , \"scripts\" : { \"start\" : \"./node_modules/.bin/gulp watch --mkdocs\" , \"build\" : \"./node_modules/.bin/gulp build --production\" } ... }","title":"JSON"},{"location":"blog/ext/codehilite/#julia","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 using MXNet mlp = @mx . chain mx . Variable ( : data ) => mx . FullyConnected ( name =: fc1 , num_hidden = 128 ) => mx . Activation ( name =: relu1 , act_type =: relu ) => mx . FullyConnected ( name =: fc2 , num_hidden = 64 ) => mx . Activation ( name =: relu2 , act_type =: relu ) => mx . FullyConnected ( name =: fc3 , num_hidden = 10 ) => mx . SoftmaxOutput ( name =: softmax ) # data provider batch_size = 100 include ( Pkg . dir ( \"MXNet\" , \"examples\" , \"mnist\" , \"mnist-data.jl\" )) train_provider , eval_provider = get_mnist_providers ( batch_size ) # setup model model = mx . FeedForward ( mlp , context = mx . cpu ()) # optimization algorithm optimizer = mx . SGD ( lr = 0.1 , momentum = 0.9 ) # fit parameters mx . fit ( model , optimizer , train_provider , n_epoch = 20 , eval_data = eval_provider )","title":"Julia"},{"location":"blog/ext/codehilite/#lua","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 local ffi = require ( \"ffi\" ) ffi . cdef [[ void Sleep(int ms); int poll(struct pollfd *fds, unsigned long nfds, int timeout); ]] local sleep if ffi . os == \"Windows\" then function sleep ( s ) ffi . C . Sleep ( s * 1000 ) end else function sleep ( s ) ffi . C . poll ( nil , 0 , s * 1000 ) end end for i = 1 , 160 do io.write ( \".\" ); io.flush () sleep ( 0.01 ) end io.write ( \" \\n \" )","title":"Lua"},{"location":"blog/ext/codehilite/#mysql","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 SELECT Employees . EmployeeID , Employees . Name , Employees . Salary , Manager . Name AS Manager FROM Employees LEFT JOIN Employees AS Manager ON Employees . ManagerID = Manager . EmployeeID WHERE Employees . EmployeeID = '087652' ;","title":"MySQL"},{"location":"blog/ext/codehilite/#php","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <?php // src/AppBundle/Controller/LuckyController.php namespace AppBundle\\Controller ; use Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Route ; use Symfony\\Component\\HttpFoundation\\Response ; class LuckyController { /** * @Route(\"/lucky/number\") */ public function numberAction () { $number = mt_rand ( 0 , 100 ); return new Response ( '<html><body>Lucky number: ' . $number . '</body></html>' ); } }","title":"PHP"},{"location":"blog/ext/codehilite/#protocol-buffers","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 syntax = \"proto2\" ; package caffe ; // Specifies the shape (dimensions) of a Blob. message BlobShape { repeated int64 dim = 1 [ packed = true ]; } message BlobProto { optional BlobShape shape = 7 ; repeated float data = 5 [ packed = true ]; repeated float diff = 6 [ packed = true ]; // 4D dimensions -- deprecated. Use \"shape\" instead. optional int32 num = 1 [ default = 0 ]; optional int32 channels = 2 [ default = 0 ]; optional int32 height = 3 [ default = 0 ]; optional int32 width = 4 [ default = 0 ]; }","title":"Protocol Buffers"},{"location":"blog/ext/codehilite/#python","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \"\"\" A very simple MNIST classifier. See extensive documentation at http://tensorflow.org/tutorials/mnist/beginners/index.md \"\"\" from __future__ import absolute_import from __future__ import division from __future__ import print_function # Import data from tensorflow.examples.tutorials.mnist import input_data import tensorflow as tf flags = tf . app . flags FLAGS = flags . FLAGS flags . DEFINE_string ( 'data_dir' , '/tmp/data/' , 'Directory for storing data' ) mnist = input_data . read_data_sets ( FLAGS . data_dir , one_hot = True ) sess = tf . InteractiveSession () # Create the model x = tf . placeholder ( tf . float32 , [ None , 784 ]) W = tf . Variable ( tf . zeros ([ 784 , 10 ])) b = tf . Variable ( tf . zeros ([ 10 ])) y = tf . nn . softmax ( tf . matmul ( x , W ) + b )","title":"Python"},{"location":"blog/ext/codehilite/#ruby","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 require 'finity/event' require 'finity/machine' require 'finity/state' require 'finity/transition' require 'finity/version' module Finity class InvalidCallback < StandardError ; end class MissingCallback < StandardError ; end class InvalidState < StandardError ; end # Class methods to be injected into the including class upon inclusion. module ClassMethods # Instantiate a new state machine for the including class by accepting a # block with state and event (and subsequent transition) definitions. def finity options = {}, & block @finity ||= Machine . new self , options , & block end # Return the names of all registered states. def states @finity . states . map { | name , _ | name } end # Return the names of all registered events. def events @finity . events . map { | name , _ | name } end end # Inject methods into the including class upon inclusion. def self . included base base . extend ClassMethods end end","title":"Ruby"},{"location":"blog/ext/codehilite/#xml","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE mainTag SYSTEM \"some.dtd\" [ENTITY % entity]> <?oxygen RNGSchema=\"some.rng\" type=\"xml\"?> <xs:main-Tag xmlns:xs= \"http://www.w3.org/2001/XMLSchema\" > <!-- This is a sample comment --> <childTag attribute= \"Quoted Value\" another-attribute= 'Single quoted value' a-third-attribute= '123' > <withTextContent> Some text content </withTextContent> <withEntityContent> Some text content with &lt; entities &gt; and mentioning uint8_t and int32_t </withEntityContent> <otherTag attribute= 'Single quoted Value' /> </childTag> <![CDATA[ some CData ]]> </main-Tag>","title":"XML"},{"location":"blog/ext/footnotes/","text":"Footnotes atau Catatan Kaki \u00b6 Footnotes adalah ekstensi lain yang termasuk ke dalam standar pustaka Markdown. Seperti namanya, footnotes digunakan untuk menambahkan catatan kaki ke dalam dokumen. Instalasi \u00b6 Tambahkan baris berikut ke dalam mkdocs . yml : 1 2 markdown_extensions : - footnotes Penggunaan \u00b6 Markup untuk catatan kaki mirip dengan standar markup Markdown untuk tautan. Referensi dimasukkan ke dalam teks, yang kemudian dapat didefinisikan pada titik mana saja dalam dokumen. Memasukkan referensi \u00b6 Referensi catatan kaki diapit tanda kurung siku dan dimulai dengan tanda sisipan, diikuti oleh label arbitrer yang berisi pengidentifikasi angka [1, 2, 3, ...] atau nama [Granovetter et al. 1998]. Referensi yang dicantumkan selalu nomor berurutan yang di superscript. Contoh: 1 Lorem ipsum [ ^ 1 ] dolor sit amet , consectetur adipiscing elit .[ ^ 2 ] Hasil: Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 Memasukkan konten \u00b6 Konten catatan kaki juga dideklarasikan dengan label, yang harus cocok dengan label yang digunakan untuk referensi catatan kaki. Itu dapat dimasukkan pada posisi dimana saja di dalam dokumen dan selalu ditampilkan di bagian bawah halaman. Selanjutnya, backlink secara otomatis ditambahkan ke referensi catatan kaki. pada satu baris \u00b6 Pernyataan singkat dapat ditulis pada baris yang sama atau dalam satu baris. Contoh: 1 [ ^ 1 ]: Lorem ipsum dolor sit amet , consectetur adipiscing elit . Hasil: Lompat ke catatan kaki di bagian bawah halaman pada banyak baris \u00b6 Paragraf harus ditulis pada baris berikutnya. Seperti semua blok Markdown, konten harus diindentasi dengan empat spasi. Contoh: 1 2 3 4 [ ^ 2 ]: Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Lompat ke catatan kaki di bagian bawah halaman Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. \u21a9","title":"Footnotes"},{"location":"blog/ext/footnotes/#footnotes-atau-catatan-kaki","text":"Footnotes adalah ekstensi lain yang termasuk ke dalam standar pustaka Markdown. Seperti namanya, footnotes digunakan untuk menambahkan catatan kaki ke dalam dokumen.","title":"Footnotes atau Catatan Kaki"},{"location":"blog/ext/footnotes/#instalasi","text":"Tambahkan baris berikut ke dalam mkdocs . yml : 1 2 markdown_extensions : - footnotes","title":"Instalasi"},{"location":"blog/ext/footnotes/#penggunaan","text":"Markup untuk catatan kaki mirip dengan standar markup Markdown untuk tautan. Referensi dimasukkan ke dalam teks, yang kemudian dapat didefinisikan pada titik mana saja dalam dokumen.","title":"Penggunaan"},{"location":"blog/ext/footnotes/#memasukkan-referensi","text":"Referensi catatan kaki diapit tanda kurung siku dan dimulai dengan tanda sisipan, diikuti oleh label arbitrer yang berisi pengidentifikasi angka [1, 2, 3, ...] atau nama [Granovetter et al. 1998]. Referensi yang dicantumkan selalu nomor berurutan yang di superscript. Contoh: 1 Lorem ipsum [ ^ 1 ] dolor sit amet , consectetur adipiscing elit .[ ^ 2 ] Hasil: Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2","title":"Memasukkan referensi"},{"location":"blog/ext/footnotes/#memasukkan-konten","text":"Konten catatan kaki juga dideklarasikan dengan label, yang harus cocok dengan label yang digunakan untuk referensi catatan kaki. Itu dapat dimasukkan pada posisi dimana saja di dalam dokumen dan selalu ditampilkan di bagian bawah halaman. Selanjutnya, backlink secara otomatis ditambahkan ke referensi catatan kaki.","title":"Memasukkan konten"},{"location":"blog/ext/footnotes/#pada-satu-baris","text":"Pernyataan singkat dapat ditulis pada baris yang sama atau dalam satu baris. Contoh: 1 [ ^ 1 ]: Lorem ipsum dolor sit amet , consectetur adipiscing elit . Hasil: Lompat ke catatan kaki di bagian bawah halaman","title":"pada satu baris"},{"location":"blog/ext/footnotes/#pada-banyak-baris","text":"Paragraf harus ditulis pada baris berikutnya. Seperti semua blok Markdown, konten harus diindentasi dengan empat spasi. Contoh: 1 2 3 4 [ ^ 2 ]: Lorem ipsum dolor sit amet , consectetur adipiscing elit . Nulla et euismod nulla . Curabitur feugiat , tortor non consequat finibus , justo purus auctor massa , nec semper lorem quam in massa . Hasil: Lompat ke catatan kaki di bagian bawah halaman Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. \u21a9","title":"pada banyak baris"},{"location":"blog/ext/metadata/","text":"Metadata \u00b6 Ekstensi Metadata memungkinkan untuk menambahkan metadata ke dalam dokumen yang memberikan kontrol lebih besar atas tema dalam konteks halaman khusus. Instalasi \u00b6 Tambahkan baris berikut ke dalam mkdocs . yml : 1 2 markdown_extensions : - meta Penggunaan \u00b6 Metadata ditulis sebagai serangkaian pasangan nilai kunci pada awal dokumen Markdown, dibatasi oleh baris kosong yang mengakhiri konteks metadata. Secara alami, metadata terpisah dari dokumen sebelum merender konten halaman yang sebenarnya dan tersedia untuk tema. Contoh: 1 2 3 4 5 6 7 8 title : Lorem ipsum dolor sit amet description : Nullam urna elit , malesuada eget finibus ut , ac tortor . path : path /to/ file source : file . js # Headline ... Lihat bagian selanjutnya yang mencakup metadata yang didukung oleh Material. Mengatur teks hero \u00b6 Material menampilkan hero teks sederhana halaman-lokal melalui Metadata, seperti yang Anda lihat di halaman ini ketika Anda gulir ke atas. Pengaturannya sangatlah sederhana: 1 hero : Inilah Teks Hero pada Metadata Mentautkan sumber \u00b6 Ketika sebuah dokumen terkait dengan kumpulan file sumber tertentu dan repo_url didefinisikan di dalam proyek mkdocs . yml , file-file tersebut dapat dihubungkan dengan menggunakan kunci source : 1 source : file . js Nama file ditambahkan ke setingan repo_url di dalam mkdocs . yml , tetapi dapat diawali dengan path untuk memastikan arah jalur yang benar: Contoh: 1 2 path : tree /master/docs/ extensions source : metadata . md Hasil: Lihat bagian sumber untuk output yang dihasilkan. Mengarahkan ke halaman lain \u00b6 Terkadang kita perlu memindahkan dokumen di dalam navigasi dan mengarahkan pengguna dari URL lama ke URL yang baru. redirect tag meta memungkinkan untuk membuat pengalihan dari dokumen saat ini ke alamat yang ditentukan dalam tag. Misalnya, jika dokumen Anda berisi: 1 redirect : / new / url akses URL dokumen itu akan secara otomatis dialihkan ke / new / url . Penggantian \u00b6 Judul halaman \u00b6 Judul halaman dapat ditimpa pada tingkatan per-dokumen: 1 title : Lorem ipsum dolor sit amet Ini akan mengatur tag title di dalam dokumen head untuk halaman saat ini ke nilai yang ditentukan. Itu juga akan mengesampingkan settingan default Material untuk MkDocs yang menyisipkan judul situs menggunakan tanda hubung sebagai pemisah ke judul halaman. Deskripsi Halaman \u00b6 Deskripsi halaman juga dapat ditimpa pada tingkatan per-dokumen: 1 description : Nullam urna elit, malesuada eget finibus ut, ac tortor. Ini akan mengatur tag meta yang berisi deskripsi situs di dalam dokumen head untuk halaman saat ini ke nilai yang ditentukan. Disqus \u00b6 Komentar Disqus dapat diaktifkan pada level per-dokumen: 1 disqus : your - shortname Disqus dapat dinonaktifkan untuk halaman tertentu dengan mengaturnya ke nilai kosong: 1 disqus :","title":"Metadata"},{"location":"blog/ext/metadata/#metadata","text":"Ekstensi Metadata memungkinkan untuk menambahkan metadata ke dalam dokumen yang memberikan kontrol lebih besar atas tema dalam konteks halaman khusus.","title":"Metadata"},{"location":"blog/ext/metadata/#instalasi","text":"Tambahkan baris berikut ke dalam mkdocs . yml : 1 2 markdown_extensions : - meta","title":"Instalasi"},{"location":"blog/ext/metadata/#penggunaan","text":"Metadata ditulis sebagai serangkaian pasangan nilai kunci pada awal dokumen Markdown, dibatasi oleh baris kosong yang mengakhiri konteks metadata. Secara alami, metadata terpisah dari dokumen sebelum merender konten halaman yang sebenarnya dan tersedia untuk tema. Contoh: 1 2 3 4 5 6 7 8 title : Lorem ipsum dolor sit amet description : Nullam urna elit , malesuada eget finibus ut , ac tortor . path : path /to/ file source : file . js # Headline ... Lihat bagian selanjutnya yang mencakup metadata yang didukung oleh Material.","title":"Penggunaan"},{"location":"blog/ext/metadata/#mengatur-teks-hero","text":"Material menampilkan hero teks sederhana halaman-lokal melalui Metadata, seperti yang Anda lihat di halaman ini ketika Anda gulir ke atas. Pengaturannya sangatlah sederhana: 1 hero : Inilah Teks Hero pada Metadata","title":"Mengatur teks hero"},{"location":"blog/ext/metadata/#mentautkan-sumber","text":"Ketika sebuah dokumen terkait dengan kumpulan file sumber tertentu dan repo_url didefinisikan di dalam proyek mkdocs . yml , file-file tersebut dapat dihubungkan dengan menggunakan kunci source : 1 source : file . js Nama file ditambahkan ke setingan repo_url di dalam mkdocs . yml , tetapi dapat diawali dengan path untuk memastikan arah jalur yang benar: Contoh: 1 2 path : tree /master/docs/ extensions source : metadata . md Hasil: Lihat bagian sumber untuk output yang dihasilkan.","title":"Mentautkan sumber"},{"location":"blog/ext/metadata/#mengarahkan-ke-halaman-lain","text":"Terkadang kita perlu memindahkan dokumen di dalam navigasi dan mengarahkan pengguna dari URL lama ke URL yang baru. redirect tag meta memungkinkan untuk membuat pengalihan dari dokumen saat ini ke alamat yang ditentukan dalam tag. Misalnya, jika dokumen Anda berisi: 1 redirect : / new / url akses URL dokumen itu akan secara otomatis dialihkan ke / new / url .","title":"Mengarahkan ke halaman lain"},{"location":"blog/ext/metadata/#penggantian","text":"","title":"Penggantian"},{"location":"blog/ext/metadata/#judul-halaman","text":"Judul halaman dapat ditimpa pada tingkatan per-dokumen: 1 title : Lorem ipsum dolor sit amet Ini akan mengatur tag title di dalam dokumen head untuk halaman saat ini ke nilai yang ditentukan. Itu juga akan mengesampingkan settingan default Material untuk MkDocs yang menyisipkan judul situs menggunakan tanda hubung sebagai pemisah ke judul halaman.","title":"Judul halaman"},{"location":"blog/ext/metadata/#deskripsi-halaman","text":"Deskripsi halaman juga dapat ditimpa pada tingkatan per-dokumen: 1 description : Nullam urna elit, malesuada eget finibus ut, ac tortor. Ini akan mengatur tag meta yang berisi deskripsi situs di dalam dokumen head untuk halaman saat ini ke nilai yang ditentukan.","title":"Deskripsi Halaman"},{"location":"blog/ext/metadata/#disqus","text":"Komentar Disqus dapat diaktifkan pada level per-dokumen: 1 disqus : your - shortname Disqus dapat dinonaktifkan untuk halaman tertentu dengan mengaturnya ke nilai kosong: 1 disqus :","title":"Disqus"},{"location":"blog/ext/permalinks/","text":"Permalinks \u00b6 Permalinks adalah fitur ekstensi Daftar Isi , yang merupakan bagian dari standar pustaka Markdown. Ekstensi menyisipkan jangkar di akhir setiap judul, yang memungkinkan untuk langsung menautkan ke bagian dokumen. Instalasi \u00b6 Untuk mengaktifkan permalink, tambahkan kode berikut ini ke dalam mkdocs . yml : 1 2 3 markdown_extensions : - toc : permalink : true Ini akan menambahkan tautan yang mengandung simbol paragraf \u00b6 di akhir setiap judul (persis seperti pada halaman yang sedang Anda lihat), yang akan ditampilkan oleh tema Material pada saat mouse di posisi hover. Untuk mengubah teks permalink, sebuah string dapat disisipkan, misalnya: 1 2 3 markdown_extensions : - toc : permalink : Link Penggunaan \u00b6 Saat diaktifkan, permalink dimasukkan secara otomatis.","title":"Permalink"},{"location":"blog/ext/permalinks/#permalinks","text":"Permalinks adalah fitur ekstensi Daftar Isi , yang merupakan bagian dari standar pustaka Markdown. Ekstensi menyisipkan jangkar di akhir setiap judul, yang memungkinkan untuk langsung menautkan ke bagian dokumen.","title":"Permalinks"},{"location":"blog/ext/permalinks/#instalasi","text":"Untuk mengaktifkan permalink, tambahkan kode berikut ini ke dalam mkdocs . yml : 1 2 3 markdown_extensions : - toc : permalink : true Ini akan menambahkan tautan yang mengandung simbol paragraf \u00b6 di akhir setiap judul (persis seperti pada halaman yang sedang Anda lihat), yang akan ditampilkan oleh tema Material pada saat mouse di posisi hover. Untuk mengubah teks permalink, sebuah string dapat disisipkan, misalnya: 1 2 3 markdown_extensions : - toc : permalink : Link","title":"Instalasi"},{"location":"blog/ext/permalinks/#penggunaan","text":"Saat diaktifkan, permalink dimasukkan secara otomatis.","title":"Penggunaan"},{"location":"blog/ext/pymdown/","text":"PyMdown Extensions \u00b6 PyMdown Extensions is a collection of Markdown extensions that add some great features to the standard Markdown library. For this reason, the installation of this package is highly recommended as it's well-integrated with the Material theme. Installation \u00b6 The PyMdown Extensions package can be installed with the following command: 1 pip install pymdown-extensions The following list of extensions that are part of the PyMdown Extensions package are recommended to be used together with the Material theme: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 markdown_extensions : - pymdownx.betterem : smart_enable : all - pymdownx.caret - pymdownx.critic - pymdownx.details - pymdownx.emoji : emoji_generator : !!python/name:pymdownx.emoji.to_svg - pymdownx.inlinehilite - pymdownx.magiclink - pymdownx.mark - pymdownx.smartsymbols - pymdownx.superfences - pymdownx.tasklist : custom_checkbox : true - pymdownx.tilde Usage \u00b6 BetterEm \u00b6 BetterEm improves the handling of emphasis markup ( bold and italic ) within Markdown by providing a more sophisticated parser for better detecting start and end tokens. Read the documentation for usage notes . Caret \u00b6 Caret makes it possible to highlight inserted text . The portion of text that should be marked as added must be enclosed in two carets ^^ ... ^^ . Critic \u00b6 Critic implements Critic Markup , a Markdown extension that enables the tracking of changes (additions, deletions and comments) on documents. During compilation of the Markdown document, changes can be rendered (default), accepted or rejected. Text can be deleted and replacement text added . This can also be combined into one a single operation. Highlighting is also possible and comments can be added inline . Formatting can also be applied to blocks, by putting the opening and closing tags on separate lines and adding new lines between the tags and the content. Details \u00b6 Details adds collapsible Admonition-style blocks which can contain arbitrary content using the HTML5 details and summary tags. Additionally, all Admonition qualifiers can be used, e.g. note , question , warning etc.: How many Prolog programmers does it take to change a lightbulb? Yes. Emoji \u00b6 Emoji adds the ability to insert a :shit:-load of emojis that we use in our daily lives. See the EmojiOne demo for a list of all available emojis. Happy scrolling :tada: Legal disclaimer Material has no affiliation with EmojiOne which is released under CC BY 4.0 . When including EmojiOne images or CSS, please read the EmojiOne license to ensure proper usage and attribution. InlineHilite \u00b6 InlineHilite adds support for inline code highlighting. It's useful for short snippets included within body copy, e.g. var test = 0 ; and can be achived by prefixing inline code with a shebang and language identifier, e.g. #! js . MagicLink \u00b6 MagicLink detects links in Markdown and auto-generates the necessary markup, so no special syntax is required. It auto-links http [ s ] : // and ftp : // links, as well as references to email addresses. Mark \u00b6 Mark adds the ability to highlight text like it was marked with a text marker . The portion of text that should be highlighted must be enclosed in two equal signs == ... == . SmartSymbols \u00b6 SmartSymbols converts markup for special characters into their corresponding symbols, e.g. arrows (\u2190, \u2192, \u2194), trademark and copyright symbols (\u00a9, \u2122, \u00ae) and fractions (\u00bd, \u00bc, ...). SuperFences \u00b6 SuperFences provides the ability to nest code blocks under blockquotes, lists and other block elements, which the Fenced Code Blocks extension from the standard Markdown library doesn't parse correctly. SuperFences does also allow grouping code blocks with tabs . Tasklist \u00b6 Tasklist adds support for styled checkbox lists. This is useful for keeping track of tasks and showing what has been done and has yet to be done. Checkbox lists are like regular lists, but prefixed with [ ] for empty or [ x ] for filled checkboxes. Example: 1 2 3 4 5 6 7 8 9 10 * [ x ] Lorem ipsum dolor sit amet , consectetur adipiscing elit * [ x ] Nulla lobortis egestas semper * [ x ] Curabitur elit nibh , euismod et ullamcorper at , iaculis feugiat est * [ ] Vestibulum convallis sit amet nisi a tincidunt * [ x ] In hac habitasse platea dictumst * [ x ] In scelerisque nibh non dolor mollis congue sed et metus * [ x ] Sed egestas felis quis elit dapibus , ac aliquet turpis mattis * [ ] Praesent sed risus massa * [ ] Aenean pretium efficitur erat , donec pharetra , ligula non scelerisque * [ ] Nulla vel eros venenatis , imperdiet enim id , faucibus nisi Result: Lorem ipsum dolor sit amet, consectetur adipiscing elit Nulla lobortis egestas semper Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est Vestibulum convallis sit amet nisi a tincidunt In hac habitasse platea dictumst In scelerisque nibh non dolor mollis congue sed et metus Sed egestas felis quis elit dapibus, ac aliquet turpis mattis Praesent sed risus massa Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque Nulla vel eros venenatis, imperdiet enim id, faucibus nisi Tilde \u00b6 Tilde provides an easy way to strike through cross out text. The portion of text that should be erased must be enclosed in two tildes ~~ ... ~~ and the extension will take care of the rest.","title":"Pymdown"},{"location":"blog/ext/pymdown/#pymdown-extensions","text":"PyMdown Extensions is a collection of Markdown extensions that add some great features to the standard Markdown library. For this reason, the installation of this package is highly recommended as it's well-integrated with the Material theme.","title":"PyMdown Extensions"},{"location":"blog/ext/pymdown/#installation","text":"The PyMdown Extensions package can be installed with the following command: 1 pip install pymdown-extensions The following list of extensions that are part of the PyMdown Extensions package are recommended to be used together with the Material theme: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 markdown_extensions : - pymdownx.betterem : smart_enable : all - pymdownx.caret - pymdownx.critic - pymdownx.details - pymdownx.emoji : emoji_generator : !!python/name:pymdownx.emoji.to_svg - pymdownx.inlinehilite - pymdownx.magiclink - pymdownx.mark - pymdownx.smartsymbols - pymdownx.superfences - pymdownx.tasklist : custom_checkbox : true - pymdownx.tilde","title":"Installation"},{"location":"blog/ext/pymdown/#usage","text":"","title":"Usage"},{"location":"blog/ext/pymdown/#betterem","text":"BetterEm improves the handling of emphasis markup ( bold and italic ) within Markdown by providing a more sophisticated parser for better detecting start and end tokens. Read the documentation for usage notes .","title":"BetterEm"},{"location":"blog/ext/pymdown/#caret","text":"Caret makes it possible to highlight inserted text . The portion of text that should be marked as added must be enclosed in two carets ^^ ... ^^ .","title":"Caret"},{"location":"blog/ext/pymdown/#critic","text":"Critic implements Critic Markup , a Markdown extension that enables the tracking of changes (additions, deletions and comments) on documents. During compilation of the Markdown document, changes can be rendered (default), accepted or rejected. Text can be deleted and replacement text added . This can also be combined into one a single operation. Highlighting is also possible and comments can be added inline . Formatting can also be applied to blocks, by putting the opening and closing tags on separate lines and adding new lines between the tags and the content.","title":"Critic"},{"location":"blog/ext/pymdown/#details","text":"Details adds collapsible Admonition-style blocks which can contain arbitrary content using the HTML5 details and summary tags. Additionally, all Admonition qualifiers can be used, e.g. note , question , warning etc.: How many Prolog programmers does it take to change a lightbulb? Yes.","title":"Details"},{"location":"blog/ext/pymdown/#emoji","text":"Emoji adds the ability to insert a :shit:-load of emojis that we use in our daily lives. See the EmojiOne demo for a list of all available emojis. Happy scrolling :tada: Legal disclaimer Material has no affiliation with EmojiOne which is released under CC BY 4.0 . When including EmojiOne images or CSS, please read the EmojiOne license to ensure proper usage and attribution.","title":"Emoji"},{"location":"blog/ext/pymdown/#inlinehilite","text":"InlineHilite adds support for inline code highlighting. It's useful for short snippets included within body copy, e.g. var test = 0 ; and can be achived by prefixing inline code with a shebang and language identifier, e.g. #! js .","title":"InlineHilite"},{"location":"blog/ext/pymdown/#magiclink","text":"MagicLink detects links in Markdown and auto-generates the necessary markup, so no special syntax is required. It auto-links http [ s ] : // and ftp : // links, as well as references to email addresses.","title":"MagicLink"},{"location":"blog/ext/pymdown/#mark","text":"Mark adds the ability to highlight text like it was marked with a text marker . The portion of text that should be highlighted must be enclosed in two equal signs == ... == .","title":"Mark"},{"location":"blog/ext/pymdown/#smartsymbols","text":"SmartSymbols converts markup for special characters into their corresponding symbols, e.g. arrows (\u2190, \u2192, \u2194), trademark and copyright symbols (\u00a9, \u2122, \u00ae) and fractions (\u00bd, \u00bc, ...).","title":"SmartSymbols"},{"location":"blog/ext/pymdown/#superfences","text":"SuperFences provides the ability to nest code blocks under blockquotes, lists and other block elements, which the Fenced Code Blocks extension from the standard Markdown library doesn't parse correctly. SuperFences does also allow grouping code blocks with tabs .","title":"SuperFences"},{"location":"blog/ext/pymdown/#tasklist","text":"Tasklist adds support for styled checkbox lists. This is useful for keeping track of tasks and showing what has been done and has yet to be done. Checkbox lists are like regular lists, but prefixed with [ ] for empty or [ x ] for filled checkboxes. Example: 1 2 3 4 5 6 7 8 9 10 * [ x ] Lorem ipsum dolor sit amet , consectetur adipiscing elit * [ x ] Nulla lobortis egestas semper * [ x ] Curabitur elit nibh , euismod et ullamcorper at , iaculis feugiat est * [ ] Vestibulum convallis sit amet nisi a tincidunt * [ x ] In hac habitasse platea dictumst * [ x ] In scelerisque nibh non dolor mollis congue sed et metus * [ x ] Sed egestas felis quis elit dapibus , ac aliquet turpis mattis * [ ] Praesent sed risus massa * [ ] Aenean pretium efficitur erat , donec pharetra , ligula non scelerisque * [ ] Nulla vel eros venenatis , imperdiet enim id , faucibus nisi Result: Lorem ipsum dolor sit amet, consectetur adipiscing elit Nulla lobortis egestas semper Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est Vestibulum convallis sit amet nisi a tincidunt In hac habitasse platea dictumst In scelerisque nibh non dolor mollis congue sed et metus Sed egestas felis quis elit dapibus, ac aliquet turpis mattis Praesent sed risus massa Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque Nulla vel eros venenatis, imperdiet enim id, faucibus nisi","title":"Tasklist"},{"location":"blog/ext/pymdown/#tilde","text":"Tilde provides an easy way to strike through cross out text. The portion of text that should be erased must be enclosed in two tildes ~~ ... ~~ and the extension will take care of the rest.","title":"Tilde"},{"location":"engine/overheating-mesin/","text":"Penyebab Overheating Mesin \u00b6 Overheating atau panas berlebihan bisa mengakibatkan kegagalan kinerja mesin, bahkan lebih fatal lagi yaitu kerusakan komponen-komponen vital mesin akibat tumbukan, gesekan dan atau benturan. Hal ini disebabkan oleh pemuaian komponen mesin yang melebihi batas normal. Overheating merupakan hal yang harus dicegah. Pemahaman tentang penyebab terjadinya overheating tidaklah harus hanya dipahami oleh para mekanik, tapi juga supir atau pemilik mobil. Diagnosa pada mesin sejak dini dari cikal bakal terjadinya overheating akan mampu mencegah kejadian yang sangat fatal. Bahkan dalam kasus overheating parah, akan menguras jumlah 0 dalam buku rekening anda. Selamatkan buku rekening anda dengan belajar tetang penyebab terjadinya overheating pada mesin. Kenapa terjadi overheating? Apakah karena cuaca yang panas? Ataukah kecepatan mesin yang melebihi batas kemampuan? Berbagai pertanyaan akan muncul dalam benak jika berhadapan dengan overheating. Artikel kali ini akan mengupas hal-hal sederhana yang sering penyebab terjadinya overheating pada mesin. Identifikasi Terjadinya Overheating \u00b6 Dibawah ini akan diurutkan komponen yang mempengaruhi panas mesin, dari yang paling ringan hingga komponen yang tergolong berat untuk di identifikasi. 1. Tutup Radiator (Radiator Cap) Rusak \u00b6 Tutup radiator atau Radiator Cap merupakan bagian penting dari sistem pendinginan pada mesin. Radiator Cap berada pada bagian atas radiator yang berfungsi untuk memelihara tekanan didalam radiator agar tidak sampai mendidih dan menguap. Pada tutup radiator terdapat 2 buah katup yang berfungsi untuk memelihara volume air pendingin dan tekanan didalam radiator. Untuk itu periksalah secara berkala tutup radiator dari kemungkinan kerusakan pada bagian-bagian tutup radiator. 2. Sensor Temperatur Rusak \u00b6 Pada mesin-mesin modern yang sudah melibatkan ECM atau ECU, sensor suhu/temperatur dipasang di beberapa tempat. Sensor ini berfungsi untuk mengirimkan sinyal suhu pada ECM atau ECU. Jika sensor suhu ini mengalami kerusakan maka sinyal tidak dapat dikirim dengan tepat ke ECM/ECU untuk dapat menyesuaikan proses yang terjadi pada mesin sehingga mampu mencegah terjadinya overheating. Untuk itu jangan abaikan sensor suhu yang sudah tidak mampu bekerja dengan baik. Pada beberapa jenis kendaraan, sensor suhu digunakan juga untuk mengaktifkan kipas pendingin radiator. 3. Sirip Radiator Tersumbat \u00b6 Semakin lebar sirip-sirip radiator maka semakin mudah proses pelepasan panas dari radiator ke udara luar yang mengalir diantara tabung-tabung radiator. Jika pelepasan panas dapat berjalan lancar tentunya temperatur mesin dapat diperlihara dalam batasan suhu yang stabil/normal. Dapat dibayang seandainya sirip-sirip pendingin pada radiator tersumbat karena benda-benda kecil semacam serangga, kerikil dan lain sebagainya dan atau sirip pendingin penyok sehingga dapat meningkatkan kecenderungan terjadinya overheating pada mesin. 4. Campuran Air Pendingin Salah \u00b6 Seandainya semua sistem pendinginan dapat bekerja dengan baik sekalipun, tetapi tetap saja sistem pendinginan tidak akan bekerja efektif dan maksimal jika cairan pendingin yang bersirkulasi tidak dalam campuran yang tepat dan ideal. Cairan pendingin adalah campuran air dengan anti beku ( anti-freeze ) atau ethylene glycol . Bahan tambah ( additive ) anti-freeze berfungsi untuk mencegah air pendingin membeku pada saat suhu mencapai 0 o C dan mencegah air mendidih pada saat suhu mencapai 100 o C. Selain itu anti-freeze juga akan membantu mendinginkan air saat air mencapai titik didihnya yaitu 100 o C dan bahkan membantu air pendingin saat suhu belum mencapai temperatur normal. Kombinasi campuran air pendingin yang ideal adalah 50% anti-beku dan 50% air. Pada beberapa kasus terutama pada saat musim dingin jumlah anti-freeze bisa ditingkatkan hingga 70%. 5. Kipas Radiator tidak Berfungsi \u00b6 Kipas radiator terletak dibelakang radiator yang berfungsi untuk membantu aliran udara dari depan radiator melintasi sirip-sirip radiator sehingga proses pelepasan panas dari radiator keudara luar dapat berjalan lancar dan maksimal. Walaupun saat kendaraan berjalan cepat kipas radiator tidaklah terlalu dibutuhkan, makanya pada beberapa mesin mobil modern kipas radiator secara otomatis tidak berputar (mati). Kipas radiator sangat dibutuhkan terutama saat putaran idle dan putaran lambat ketika itu udara dingin tidak begitu baik mengalir melewati gril dan radiator. Periksalah bilah-bilah kipas radiator dan motor (pada mesin tertentu) untuk memastikan pastikan bahwa udara mengalir melewati radiator dengan baik. 6. Pompa Air Macet \u00b6 Pompa air terletak dibelakang kipas radiator. Pompa radiator berfungsi untuk men-sirkulasikan air pendingin melewati matel air ( water-jacket ), menyerap panas dari hasil pembakaran yang kemudian dialirkan menuju radiator untuk proses pelepasan panas. Periksalah pompa radiator dari kemungkinan terjadi kerusakan pada gasket dan atau korosi. 7. Thermostat Macet \u00b6 Thermostat berada pada sekitar aliran air pendingin, ada yang terdapat pada bagian atas mesin atau dibawah pompa air. Untuk Indonesia thermostat sudah jarang disertakan pada mesin oleh para perusahaan mobil Indonesia. Thermostat berfungsi sebagai stopper atau pintu yang mengatur sirkulasi air pendingin, pada saat mesin belum mencapai temperatur ideal maka thermostat akan menutup aliran air dari mantel air (water-jacket) ke radiator sehingga air pendingin hanya akan ber-sirkulasi di sekitar rongga-rongga mesin. Selanjutnya jika temperatur mesin mencapai suhu ideal maka thermostat akan membuka dan mengalirkan air pendingin menuju radiator. 8. Radiator Hose Tersumbat \u00b6 Pada umumnya sistem pendinginan hanya memiliki dua buah saluran (hose) yaitu upper hose (saluran atas) dan lower hose (saluran bawah). Upper hose mengalirkan air panas dari mesin menuju ke radiator sedangkan lower hose mengalirkan air dingin dari radiator menuju ke mesin. Periksalah saluran-saluran ini dari kemungkinan cacat, bocor, dan menyusut. Pada kasus tertentu terjadi penyusutan saluran radiator, hal tersebut karena kerusakan pada tutup radiator, tutup radiator yang rusak menciptakan kevakuman didalam radiator sehingga saluran radiator yang terbuat dari bahan lentur (karet) akan terhisap dan menyusut. 9. Kekurangan Cairan Pendingin \u00b6 Cairan pendingin adalah darah dari sistem pendinginan, untuk itu keberadaannya merupakan hal mutlak yang tidak bisa di tawar. Jangan berhadap mesin dapat berjalan jauh jika sistem pendinginan kekurangan cairan. Untuk itu pastikan volume cairan pendingin dalam jumlah cukup, kita dapat memeriksanya melalui radiator atau melalui tangki cadangan ( reservoir tank ). Akan lebih baik kita memeriksa jumlah cairan pendingin secara berkala setiap hari atau setiap akan menggunakan kendaaraan melalui reservoir tank. 10. Sabuk Penggerak (Driving Belt) Kendur \u00b6 Sabuk penggerak atau sering disebut driving belt atau fan belt digunakan untuk meneruskan putaran dari poros engkol ( crankshaft ) ke pompa air ( water pump ). Jika driving belt kendur maka putaran dari pulley poros engkol tidak akan diteruskan dengan baik ke pompa air (water pump) sehingga putaran pompa air tidak akan maksimal, akibatnya sirkulasi cairan pendingin tidak berjalan lancar dan terjadilah overheating. 11. Kebocoran Saluran Pendinginan \u00b6 Radiator dan water jacket dihubungkan dengan upper hose dan lower hose yang terbuat dari bahan karet. Saluran ini sangat rawan mengalami kebocoran terutama pada sambungannya yang hanya diikat menggunakan klem. Pada saat cairan pendingin panas maka volume air bertambah dan terjadilah kompresi (tekanan naik) dan kemudian menyusut lagi saat mesin berhenti bekerja. Perubahan inilah yang membuat saluran pendinginan kembang kempis, mengembang saat panas dan menyusut saat dingin. Hal ini membuat sambungan-sambungan saluran pendinginan yang terbuat dari bahan karet mengalami pergeseran dan bahkan klem-an yang mengikat saluran menjadi kendur. Periksalah secara berkala ikatan klem antara saluran pendingin dengan blok mesin dan radiator. Selain penyebab diatas ada pula beberapa faktor yang bisa memicu terjadinya overheating, diantaranya; gaya mengemudi yang berlebihan, cuaca yang terlalu panas, dan kondisi jalan yang macet. Selamat bekerja, perhatikan baik-baik kelengkapan keselamatan kerja dan semoga artikel ini membantu memperlancar pekerjaan anda.","title":"Penyebab Overheating"},{"location":"engine/overheating-mesin/#penyebab-overheating-mesin","text":"Overheating atau panas berlebihan bisa mengakibatkan kegagalan kinerja mesin, bahkan lebih fatal lagi yaitu kerusakan komponen-komponen vital mesin akibat tumbukan, gesekan dan atau benturan. Hal ini disebabkan oleh pemuaian komponen mesin yang melebihi batas normal. Overheating merupakan hal yang harus dicegah. Pemahaman tentang penyebab terjadinya overheating tidaklah harus hanya dipahami oleh para mekanik, tapi juga supir atau pemilik mobil. Diagnosa pada mesin sejak dini dari cikal bakal terjadinya overheating akan mampu mencegah kejadian yang sangat fatal. Bahkan dalam kasus overheating parah, akan menguras jumlah 0 dalam buku rekening anda. Selamatkan buku rekening anda dengan belajar tetang penyebab terjadinya overheating pada mesin. Kenapa terjadi overheating? Apakah karena cuaca yang panas? Ataukah kecepatan mesin yang melebihi batas kemampuan? Berbagai pertanyaan akan muncul dalam benak jika berhadapan dengan overheating. Artikel kali ini akan mengupas hal-hal sederhana yang sering penyebab terjadinya overheating pada mesin.","title":"Penyebab Overheating Mesin"},{"location":"engine/overheating-mesin/#identifikasi-terjadinya-overheating","text":"Dibawah ini akan diurutkan komponen yang mempengaruhi panas mesin, dari yang paling ringan hingga komponen yang tergolong berat untuk di identifikasi.","title":"Identifikasi Terjadinya Overheating"},{"location":"engine/overheating-mesin/#1-tutup-radiator-radiator-cap-rusak","text":"Tutup radiator atau Radiator Cap merupakan bagian penting dari sistem pendinginan pada mesin. Radiator Cap berada pada bagian atas radiator yang berfungsi untuk memelihara tekanan didalam radiator agar tidak sampai mendidih dan menguap. Pada tutup radiator terdapat 2 buah katup yang berfungsi untuk memelihara volume air pendingin dan tekanan didalam radiator. Untuk itu periksalah secara berkala tutup radiator dari kemungkinan kerusakan pada bagian-bagian tutup radiator.","title":"1. Tutup Radiator (Radiator Cap) Rusak"},{"location":"engine/overheating-mesin/#2-sensor-temperatur-rusak","text":"Pada mesin-mesin modern yang sudah melibatkan ECM atau ECU, sensor suhu/temperatur dipasang di beberapa tempat. Sensor ini berfungsi untuk mengirimkan sinyal suhu pada ECM atau ECU. Jika sensor suhu ini mengalami kerusakan maka sinyal tidak dapat dikirim dengan tepat ke ECM/ECU untuk dapat menyesuaikan proses yang terjadi pada mesin sehingga mampu mencegah terjadinya overheating. Untuk itu jangan abaikan sensor suhu yang sudah tidak mampu bekerja dengan baik. Pada beberapa jenis kendaraan, sensor suhu digunakan juga untuk mengaktifkan kipas pendingin radiator.","title":"2. Sensor Temperatur Rusak"},{"location":"engine/overheating-mesin/#3-sirip-radiator-tersumbat","text":"Semakin lebar sirip-sirip radiator maka semakin mudah proses pelepasan panas dari radiator ke udara luar yang mengalir diantara tabung-tabung radiator. Jika pelepasan panas dapat berjalan lancar tentunya temperatur mesin dapat diperlihara dalam batasan suhu yang stabil/normal. Dapat dibayang seandainya sirip-sirip pendingin pada radiator tersumbat karena benda-benda kecil semacam serangga, kerikil dan lain sebagainya dan atau sirip pendingin penyok sehingga dapat meningkatkan kecenderungan terjadinya overheating pada mesin.","title":"3. Sirip Radiator Tersumbat"},{"location":"engine/overheating-mesin/#4-campuran-air-pendingin-salah","text":"Seandainya semua sistem pendinginan dapat bekerja dengan baik sekalipun, tetapi tetap saja sistem pendinginan tidak akan bekerja efektif dan maksimal jika cairan pendingin yang bersirkulasi tidak dalam campuran yang tepat dan ideal. Cairan pendingin adalah campuran air dengan anti beku ( anti-freeze ) atau ethylene glycol . Bahan tambah ( additive ) anti-freeze berfungsi untuk mencegah air pendingin membeku pada saat suhu mencapai 0 o C dan mencegah air mendidih pada saat suhu mencapai 100 o C. Selain itu anti-freeze juga akan membantu mendinginkan air saat air mencapai titik didihnya yaitu 100 o C dan bahkan membantu air pendingin saat suhu belum mencapai temperatur normal. Kombinasi campuran air pendingin yang ideal adalah 50% anti-beku dan 50% air. Pada beberapa kasus terutama pada saat musim dingin jumlah anti-freeze bisa ditingkatkan hingga 70%.","title":"4. Campuran Air Pendingin Salah"},{"location":"engine/overheating-mesin/#5-kipas-radiator-tidak-berfungsi","text":"Kipas radiator terletak dibelakang radiator yang berfungsi untuk membantu aliran udara dari depan radiator melintasi sirip-sirip radiator sehingga proses pelepasan panas dari radiator keudara luar dapat berjalan lancar dan maksimal. Walaupun saat kendaraan berjalan cepat kipas radiator tidaklah terlalu dibutuhkan, makanya pada beberapa mesin mobil modern kipas radiator secara otomatis tidak berputar (mati). Kipas radiator sangat dibutuhkan terutama saat putaran idle dan putaran lambat ketika itu udara dingin tidak begitu baik mengalir melewati gril dan radiator. Periksalah bilah-bilah kipas radiator dan motor (pada mesin tertentu) untuk memastikan pastikan bahwa udara mengalir melewati radiator dengan baik.","title":"5. Kipas Radiator tidak Berfungsi"},{"location":"engine/overheating-mesin/#6-pompa-air-macet","text":"Pompa air terletak dibelakang kipas radiator. Pompa radiator berfungsi untuk men-sirkulasikan air pendingin melewati matel air ( water-jacket ), menyerap panas dari hasil pembakaran yang kemudian dialirkan menuju radiator untuk proses pelepasan panas. Periksalah pompa radiator dari kemungkinan terjadi kerusakan pada gasket dan atau korosi.","title":"6. Pompa Air Macet"},{"location":"engine/overheating-mesin/#7-thermostat-macet","text":"Thermostat berada pada sekitar aliran air pendingin, ada yang terdapat pada bagian atas mesin atau dibawah pompa air. Untuk Indonesia thermostat sudah jarang disertakan pada mesin oleh para perusahaan mobil Indonesia. Thermostat berfungsi sebagai stopper atau pintu yang mengatur sirkulasi air pendingin, pada saat mesin belum mencapai temperatur ideal maka thermostat akan menutup aliran air dari mantel air (water-jacket) ke radiator sehingga air pendingin hanya akan ber-sirkulasi di sekitar rongga-rongga mesin. Selanjutnya jika temperatur mesin mencapai suhu ideal maka thermostat akan membuka dan mengalirkan air pendingin menuju radiator.","title":"7. Thermostat Macet"},{"location":"engine/overheating-mesin/#8-radiator-hose-tersumbat","text":"Pada umumnya sistem pendinginan hanya memiliki dua buah saluran (hose) yaitu upper hose (saluran atas) dan lower hose (saluran bawah). Upper hose mengalirkan air panas dari mesin menuju ke radiator sedangkan lower hose mengalirkan air dingin dari radiator menuju ke mesin. Periksalah saluran-saluran ini dari kemungkinan cacat, bocor, dan menyusut. Pada kasus tertentu terjadi penyusutan saluran radiator, hal tersebut karena kerusakan pada tutup radiator, tutup radiator yang rusak menciptakan kevakuman didalam radiator sehingga saluran radiator yang terbuat dari bahan lentur (karet) akan terhisap dan menyusut.","title":"8. Radiator Hose Tersumbat"},{"location":"engine/overheating-mesin/#9-kekurangan-cairan-pendingin","text":"Cairan pendingin adalah darah dari sistem pendinginan, untuk itu keberadaannya merupakan hal mutlak yang tidak bisa di tawar. Jangan berhadap mesin dapat berjalan jauh jika sistem pendinginan kekurangan cairan. Untuk itu pastikan volume cairan pendingin dalam jumlah cukup, kita dapat memeriksanya melalui radiator atau melalui tangki cadangan ( reservoir tank ). Akan lebih baik kita memeriksa jumlah cairan pendingin secara berkala setiap hari atau setiap akan menggunakan kendaaraan melalui reservoir tank.","title":"9. Kekurangan Cairan Pendingin"},{"location":"engine/overheating-mesin/#10-sabuk-penggerak-driving-belt-kendur","text":"Sabuk penggerak atau sering disebut driving belt atau fan belt digunakan untuk meneruskan putaran dari poros engkol ( crankshaft ) ke pompa air ( water pump ). Jika driving belt kendur maka putaran dari pulley poros engkol tidak akan diteruskan dengan baik ke pompa air (water pump) sehingga putaran pompa air tidak akan maksimal, akibatnya sirkulasi cairan pendingin tidak berjalan lancar dan terjadilah overheating.","title":"10. Sabuk Penggerak (Driving Belt) Kendur"},{"location":"engine/overheating-mesin/#11-kebocoran-saluran-pendinginan","text":"Radiator dan water jacket dihubungkan dengan upper hose dan lower hose yang terbuat dari bahan karet. Saluran ini sangat rawan mengalami kebocoran terutama pada sambungannya yang hanya diikat menggunakan klem. Pada saat cairan pendingin panas maka volume air bertambah dan terjadilah kompresi (tekanan naik) dan kemudian menyusut lagi saat mesin berhenti bekerja. Perubahan inilah yang membuat saluran pendinginan kembang kempis, mengembang saat panas dan menyusut saat dingin. Hal ini membuat sambungan-sambungan saluran pendinginan yang terbuat dari bahan karet mengalami pergeseran dan bahkan klem-an yang mengikat saluran menjadi kendur. Periksalah secara berkala ikatan klem antara saluran pendingin dengan blok mesin dan radiator. Selain penyebab diatas ada pula beberapa faktor yang bisa memicu terjadinya overheating, diantaranya; gaya mengemudi yang berlebihan, cuaca yang terlalu panas, dan kondisi jalan yang macet. Selamat bekerja, perhatikan baik-baik kelengkapan keselamatan kerja dan semoga artikel ini membantu memperlancar pekerjaan anda.","title":"11. Kebocoran Saluran Pendinginan"},{"location":"engine/periksa-radiator-cap/","text":"Memeriksa Tutup Radiator (Radiator Cap Test) \u00b6 Tutup Radiator atau sering di sebut Radiator Cap bukanlah sekedar sebuah tutup, tapi juga memiliki peranan penting dalam sistem pendinginan mesin kendaraan. Tutup radiator berfungsi untuk mengatur tekanan dan volume air pendingin didalam radiator. Karena peranan yang penting inilah maka perlu dilakukan pemeriksaan tutup radiator secara berkala baik secara visual maupun menggunakan alat khusus (SST). Jangan pernah remehkan benda kecil ini karena bisa berakibat fatal, salah satu akibat kerusakan pada tutup radiator adalah terjadinya overheating (panas berlebihan) pada mesin, hal ini tentu akan merusak komponen-komponen mesin. Sebelum kita menggunakan kendaraan biasanya kita melakukan pemeriksaan pada beberapa bagian penting mesin salah satunya adalah pemeriksaan volume air pendingin. Saat kita melakukan pemeriksaan air pendingin akan lebih baik sekaligus melakukan pemeriksaan tutup radiator. Tutup radiator merupakan salah satu komponen sistem pendinginan yang tidak boleh diabaikan kondisinya. Kondisi tutup radiator yang baik akan membuat sistem pendinginan bekerja dengan baik pula. Namun kondisi tutup radiator yang jelek akan memicu terjadinya overheating . Lalu apa peranan tutup radiator dan bagaimana cara memeriksanya? Peranan Tutup Radiator \u00b6 Ketika cairan pendingin menjadi panas, maka volume cairan pendingin akan mengembang, menyebabkan cairan menjadi bertekanan tinggi. Ketika memasuki radiator, tekanan meningkat bahkan lebih tinggi karena memasuki ruangan tertutup di dalam radiator. Tutup radiator bertindak sebagai katup pelepas tekanan yang telah diatur untuk membuka pada titik tekanan maksimum. Biasanya tekanan tutup radiator telah diatur dengan tekanan maksimum 13 PSI atau 0,9 Bar. Ketika tekanan cairan di dalam radiator melebihi 13 psi, maka cairan akan memaksa pressure relief valve terbuka, yang memungkinkan panas terlepas dan cairan pendingin meluap ke dalam tangki cadangan ( recervoir tank ) yang biasanya terletak pada sisi luar radiator. Setelah radiator dan cairan menjadi dingin, cairan pendingin dalam tangki cadangan akan terhisap kembali ke dalam pompa melalui vacuum relief valve , dan melanjutkan proses sirkulasi sistem pendinginan. Pemeriksaan Secara Visual \u00b6 Kondisi tutup radiator akan mempengaruhi kinerja sistem pendinginan. Hal ini karena tutup radiator bukanlah sekedar sebuah tutup, tapi berperan pula dalam membantu memaksimalkan pelepasan panas dan sirkulasi sistem pendinginan. Oleh karena itu, pemeriksaan secara rutin terhadap tutup radiator haruslah dilakukan terutama oleh pemilik kendaraan. Pemeriksaan kondisi tutup radiator tidaklah sulit dan dibawah ini dijelaskan cara pemeriksaan tutup radiator secara visual tanpa memerlukan alat khusus. 1. Pemeriksaan Sil Tutup Radiator (Radiator Cap Seal) \u00b6 Sil tutup radiator atau sering dikenal dengan nama Black Rubber Gasket merupakan perapat yang terbuat dari karet untuk membantu tutup radiator menutup rapat radiator. Pemeriksaan sil tutup radiator cukup mudah. Periksa kelenturan karet pada sil bagian luar ( Outer Cap Seal atau Upper Seal ) dan dan sil karet bagian dalam ( Inner Cap Seal atau Main Rubber Seal ) seperti terlihat pada gambar. Perhatikan kedua sil tersebut dari kemungkinan sobek, kemudian tekan kedua sil tersebut menggunakan kuku dan pastikan bahwa karet kembali rata. Jika pada karet terbentuk cekungan maka karet tutup radiator harus diganti karena karet tutup radiator sudah keras sehingga tidak mampu menutup radiator dengan sempurna. Gambar 1. Black Rubber Gasket 2. Pemeriksaan Pressure Relief Valve (Katup Pembebas Tekanan) \u00b6 Tekan pressure relief valve menggunakan kedua jempol, kemudian lepas. Pastikan bahwa katup kembali ke posisi semula dan jika katup tidak bisa kembali berarti pegas pressure relief valve sudah tidak lentur atau bahkan macet. Ganti tutup radiator jika pressure relief valve tidak mampu bekerja dengan baik, hal ini akan mengakibatkan tekanan didalam sirkulasi sistem pendinginan meningkat dan akan membahayakan sambungan-sambungan saluran air pendingin, perpak kepala silinder, upper hose, lower hose dan radiator. Bahkan pada beberapa kasus tekanan air yang telalu tinggi didalam sistem pendinginan mampu memecahkan radiator, upper hose dan lowe hose. Gambar 2. Pemeriksaan Katup Pembebas Tekanan 3. Pemeriksaan Vacuum Relief Valve (Katup Vakum) \u00b6 Tarik katup vakum ( Vacuum Reluef Valve ) kemudian lepas, pastikan bahwa katup vakum kembali pada posisi semula dengan posisi katup menutup sempurna pada Inner Cap Seal. Jika katup vakum tidak kembali ke posisi semula atau kembali tapi posisinya tidak sempurna maka tutup radiator harus diganti. Katup vakum yang jelek akan membuat air didalam radiator selalu berkurang setelah mesin digunakan. Setiap pagi periksa jumlah air pendingin pada radiator, jika jumlah carian pendingin berkurang didalam radiator padahal didalam tangki cadangan ( reservoir tank ) carian masih penuh itu berarti katup vakum tidak bekerja dengan baik atau bahkan macet. Gambar 3. Pemeriksaan Katup Vakum Pemeriksaan dengan Alat SST \u00b6 Setelah melakukan pemeriksaan tutup radiator secara visual maka selanjutnya kita akan melakukan pemeriksaan tutup radiator menggunakan alat khusus SST ( Special Service Tools ) seperti langkah-langkah dibawah ini. Langkah 1 - Mempersiapkan SST \u00b6 Siapkan alat Universal Radiator Pressure Cooling System Leak Tester untuk memeriksa tutup radiator seperti gambar dibawah ini. Gambar 4. SST Sistem Pendinginan Langkah 2 - Buka Tutup Radiator \u00b6 Buka tutup radiator. Hati-hati jika mesin dalam keadaan masin panas, tunggulah hingga dingin atau kompres dengan lap basah untuk menurunkan temperature air pendingin. Gambar 5. Buka Tutup Radiator Langkah 3 - Memilih Adapter \u00b6 Pilihlah adapter yang tepat sesuai dengan ukuran tutup radiator. Pasang tutup radiator pada adapter kemudian pasang adapter pada handpump (pompa tangan). Gambar 6. Adapter SST Langkah 4 - Periksa Tutup Radiator \u00b6 Pompa tutup radiator dan perhatikan jarum tekanan (pressure gauge) pada pompa tangan. Pressure gauge harus menunjukan kisaran tekanan 0.9 Bar atau 13 PSI. Jika tekanan lebih dari atau kurang dari spesifikasi maka gantilah tutup radiator. Jika tekanan hasil pemeriksaan melebihi spesifikasi berarti katup pembebas tekanan bermasalah. Sedangkan jika tekanan kurang dari spesifikasi kemungkinan terdapat kebocoran baik pada sil maupun pada katup vakum. Gambar 7. Pemeriksaan Tutup Radiator Pemeriksaan menggunakan SST Universal Radiator Pressure Cooling System Leak Tester sudah cukup mewakili kondisi tutup radiator secara keseluruhan. Daftar Pustaka \u00b6 How does a radiator cap work? How to Test Radiator Cap How to Check and Add Radiator Fluid","title":"Memeriksa Tutup Radiator"},{"location":"engine/periksa-radiator-cap/#memeriksa-tutup-radiator-radiator-cap-test","text":"Tutup Radiator atau sering di sebut Radiator Cap bukanlah sekedar sebuah tutup, tapi juga memiliki peranan penting dalam sistem pendinginan mesin kendaraan. Tutup radiator berfungsi untuk mengatur tekanan dan volume air pendingin didalam radiator. Karena peranan yang penting inilah maka perlu dilakukan pemeriksaan tutup radiator secara berkala baik secara visual maupun menggunakan alat khusus (SST). Jangan pernah remehkan benda kecil ini karena bisa berakibat fatal, salah satu akibat kerusakan pada tutup radiator adalah terjadinya overheating (panas berlebihan) pada mesin, hal ini tentu akan merusak komponen-komponen mesin. Sebelum kita menggunakan kendaraan biasanya kita melakukan pemeriksaan pada beberapa bagian penting mesin salah satunya adalah pemeriksaan volume air pendingin. Saat kita melakukan pemeriksaan air pendingin akan lebih baik sekaligus melakukan pemeriksaan tutup radiator. Tutup radiator merupakan salah satu komponen sistem pendinginan yang tidak boleh diabaikan kondisinya. Kondisi tutup radiator yang baik akan membuat sistem pendinginan bekerja dengan baik pula. Namun kondisi tutup radiator yang jelek akan memicu terjadinya overheating . Lalu apa peranan tutup radiator dan bagaimana cara memeriksanya?","title":"Memeriksa Tutup Radiator (Radiator Cap Test)"},{"location":"engine/periksa-radiator-cap/#peranan-tutup-radiator","text":"Ketika cairan pendingin menjadi panas, maka volume cairan pendingin akan mengembang, menyebabkan cairan menjadi bertekanan tinggi. Ketika memasuki radiator, tekanan meningkat bahkan lebih tinggi karena memasuki ruangan tertutup di dalam radiator. Tutup radiator bertindak sebagai katup pelepas tekanan yang telah diatur untuk membuka pada titik tekanan maksimum. Biasanya tekanan tutup radiator telah diatur dengan tekanan maksimum 13 PSI atau 0,9 Bar. Ketika tekanan cairan di dalam radiator melebihi 13 psi, maka cairan akan memaksa pressure relief valve terbuka, yang memungkinkan panas terlepas dan cairan pendingin meluap ke dalam tangki cadangan ( recervoir tank ) yang biasanya terletak pada sisi luar radiator. Setelah radiator dan cairan menjadi dingin, cairan pendingin dalam tangki cadangan akan terhisap kembali ke dalam pompa melalui vacuum relief valve , dan melanjutkan proses sirkulasi sistem pendinginan.","title":"Peranan Tutup Radiator"},{"location":"engine/periksa-radiator-cap/#pemeriksaan-secara-visual","text":"Kondisi tutup radiator akan mempengaruhi kinerja sistem pendinginan. Hal ini karena tutup radiator bukanlah sekedar sebuah tutup, tapi berperan pula dalam membantu memaksimalkan pelepasan panas dan sirkulasi sistem pendinginan. Oleh karena itu, pemeriksaan secara rutin terhadap tutup radiator haruslah dilakukan terutama oleh pemilik kendaraan. Pemeriksaan kondisi tutup radiator tidaklah sulit dan dibawah ini dijelaskan cara pemeriksaan tutup radiator secara visual tanpa memerlukan alat khusus.","title":"Pemeriksaan Secara Visual"},{"location":"engine/periksa-radiator-cap/#1-pemeriksaan-sil-tutup-radiator-radiator-cap-seal","text":"Sil tutup radiator atau sering dikenal dengan nama Black Rubber Gasket merupakan perapat yang terbuat dari karet untuk membantu tutup radiator menutup rapat radiator. Pemeriksaan sil tutup radiator cukup mudah. Periksa kelenturan karet pada sil bagian luar ( Outer Cap Seal atau Upper Seal ) dan dan sil karet bagian dalam ( Inner Cap Seal atau Main Rubber Seal ) seperti terlihat pada gambar. Perhatikan kedua sil tersebut dari kemungkinan sobek, kemudian tekan kedua sil tersebut menggunakan kuku dan pastikan bahwa karet kembali rata. Jika pada karet terbentuk cekungan maka karet tutup radiator harus diganti karena karet tutup radiator sudah keras sehingga tidak mampu menutup radiator dengan sempurna. Gambar 1. Black Rubber Gasket","title":"1. Pemeriksaan Sil Tutup Radiator (Radiator Cap Seal)"},{"location":"engine/periksa-radiator-cap/#2-pemeriksaan-pressure-relief-valve-katup-pembebas-tekanan","text":"Tekan pressure relief valve menggunakan kedua jempol, kemudian lepas. Pastikan bahwa katup kembali ke posisi semula dan jika katup tidak bisa kembali berarti pegas pressure relief valve sudah tidak lentur atau bahkan macet. Ganti tutup radiator jika pressure relief valve tidak mampu bekerja dengan baik, hal ini akan mengakibatkan tekanan didalam sirkulasi sistem pendinginan meningkat dan akan membahayakan sambungan-sambungan saluran air pendingin, perpak kepala silinder, upper hose, lower hose dan radiator. Bahkan pada beberapa kasus tekanan air yang telalu tinggi didalam sistem pendinginan mampu memecahkan radiator, upper hose dan lowe hose. Gambar 2. Pemeriksaan Katup Pembebas Tekanan","title":"2. Pemeriksaan Pressure Relief Valve (Katup Pembebas Tekanan)"},{"location":"engine/periksa-radiator-cap/#3-pemeriksaan-vacuum-relief-valve-katup-vakum","text":"Tarik katup vakum ( Vacuum Reluef Valve ) kemudian lepas, pastikan bahwa katup vakum kembali pada posisi semula dengan posisi katup menutup sempurna pada Inner Cap Seal. Jika katup vakum tidak kembali ke posisi semula atau kembali tapi posisinya tidak sempurna maka tutup radiator harus diganti. Katup vakum yang jelek akan membuat air didalam radiator selalu berkurang setelah mesin digunakan. Setiap pagi periksa jumlah air pendingin pada radiator, jika jumlah carian pendingin berkurang didalam radiator padahal didalam tangki cadangan ( reservoir tank ) carian masih penuh itu berarti katup vakum tidak bekerja dengan baik atau bahkan macet. Gambar 3. Pemeriksaan Katup Vakum","title":"3. Pemeriksaan Vacuum Relief Valve (Katup Vakum)"},{"location":"engine/periksa-radiator-cap/#pemeriksaan-dengan-alat-sst","text":"Setelah melakukan pemeriksaan tutup radiator secara visual maka selanjutnya kita akan melakukan pemeriksaan tutup radiator menggunakan alat khusus SST ( Special Service Tools ) seperti langkah-langkah dibawah ini.","title":"Pemeriksaan dengan Alat SST"},{"location":"engine/periksa-radiator-cap/#langkah-1-mempersiapkan-sst","text":"Siapkan alat Universal Radiator Pressure Cooling System Leak Tester untuk memeriksa tutup radiator seperti gambar dibawah ini. Gambar 4. SST Sistem Pendinginan","title":"Langkah 1 - Mempersiapkan SST"},{"location":"engine/periksa-radiator-cap/#langkah-2-buka-tutup-radiator","text":"Buka tutup radiator. Hati-hati jika mesin dalam keadaan masin panas, tunggulah hingga dingin atau kompres dengan lap basah untuk menurunkan temperature air pendingin. Gambar 5. Buka Tutup Radiator","title":"Langkah 2 - Buka Tutup Radiator"},{"location":"engine/periksa-radiator-cap/#langkah-3-memilih-adapter","text":"Pilihlah adapter yang tepat sesuai dengan ukuran tutup radiator. Pasang tutup radiator pada adapter kemudian pasang adapter pada handpump (pompa tangan). Gambar 6. Adapter SST","title":"Langkah 3 - Memilih Adapter"},{"location":"engine/periksa-radiator-cap/#langkah-4-periksa-tutup-radiator","text":"Pompa tutup radiator dan perhatikan jarum tekanan (pressure gauge) pada pompa tangan. Pressure gauge harus menunjukan kisaran tekanan 0.9 Bar atau 13 PSI. Jika tekanan lebih dari atau kurang dari spesifikasi maka gantilah tutup radiator. Jika tekanan hasil pemeriksaan melebihi spesifikasi berarti katup pembebas tekanan bermasalah. Sedangkan jika tekanan kurang dari spesifikasi kemungkinan terdapat kebocoran baik pada sil maupun pada katup vakum. Gambar 7. Pemeriksaan Tutup Radiator Pemeriksaan menggunakan SST Universal Radiator Pressure Cooling System Leak Tester sudah cukup mewakili kondisi tutup radiator secara keseluruhan.","title":"Langkah 4 - Periksa Tutup Radiator"},{"location":"engine/periksa-radiator-cap/#daftar-pustaka","text":"How does a radiator cap work? How to Test Radiator Cap How to Check and Add Radiator Fluid","title":"Daftar Pustaka"},{"location":"ototronik/dwell/","text":"Dwell Sistem Pengapian \u00b6 Dwell Angle (Sudut Dwell) adalah jumlah derajat poros cam distributor ketika kontak poin tertutup. Dwell Angle atau Sudut Dwell bernilai tetap pada berbagai tingkat kecepatan putaran mesin. Dwell Time (Waktu Dwell) adalah sejumlah waktu yang diperlukan untuk mengisi tegangan pada kumparan induktif hingga mencapai tingkat energi maksimum. Dwell Time atau waktu dwell akan bervariasi sesuai dengan perubahan putaran mesin. Memahami Dwell pada Sistem Pengapian \u00b6 Sistem Pengapian atau Ignition System merupakan salah satu bagian penting yang secara langsung mempengaruhi kinerja mesin. Percikan bunga api pada busi digunakan untuk membakar campuran udara dan bahan bakar yang telah dikompresikan diruang bakar. Kualitas percikan bunga api yang jelek menyebabkan campuran udara dan bahan bakar tidak mampu terbakar dengan sempurna. Pembakaran tidak sempurna merupakan kasus yang terus diteliti, karena hal ini merupakan masalah serius yang menjadi penyebab utama penurunan performa mesin, konsumsi bahan bakar menjadi boros, dan gas buang sisa pembakaran yang berbahaya. Untuk menghasilkan percikan bunga api yang baik tidak hanya di perlukan komponen pengapian yang berkualitas, namun faktor-faktor yang mempengaruhi kinerja sistem pengapian juga berperan dalam menentukan kualitas percikan bunga api. Dwell merupakan faktor penting yang menunjang pada kualitas percikan bunga api. Akhir-akhir ini, pembahasan tentang Dwell sudah mulai memudar bahkan hampir menghilang dari pembahasan materi sistem pengapian. Gambar 1. Dwell Meter Dwell Angle pada Sistem Pengapian Konvensional \u00b6 Dwell Angle pada mulanya dibahas pada sistem pengapian konvensional yang secara spesifik berkaitan erat dengan kontak poin atau platina. Sistem pengapian konvensional adalah sistem pengapian tertua yang menjadi cikal bakal lahirnya sistem pengapian modern. Sistem pengapian konvensional identik dengan distributor dan kontak poin. Pada mesin yang berbasis distributor generasi lama, cam pada distributor digunakan untuk membuka dan menutup sebuah kontak poin. Kontak poin dihubungkan untuk mengalirkan tegangan dari baterai ke dalam kumparan ignition coil (kumparan primer). Ketika kontak poin menutup, kumparan primer diisi tegangan. Ketika kontak poin terbuka, tegangan pada kumparan primer dikosongkan, dan terjadi induksi terhadap kumparan sekunder. Tegangan tinggi yang dihasilkan kumparan sekunder dialirkan ke busi melalui distributor. Dari sinilah lahir penamaan \" Dwell Angle \" atau dalam bahasa Indonesia diterjemahkan menjadi \"Sudut Dwell\". Dwell Angle atau sudut dwell adalah jumlah derajat poros cam distributor ketika kontak poin tertutup. Dwell angle sering diartikan sebagai sudut tutup kontak poin ( Breaker Point Closed Angle ), hal ini karena pada mulanya hanya tersedia pada sistem pengapian konvensional. Gambar 2. Sudut Dwell pada Cam Distributor Sudut Dwell sebenarnya bukan untuk mendefinisikan keadaan kontak poin, tetapi untuk mendefinisikan proses pengisian dan pengosongan tegangan pada kumparan primer. Kontak poin digunakan untuk mengatur proses pengisian dan pengosongan pada kumparan primer. Oleh karena itu, Dwell Angle akan bernilai tetap pada berbagai tingkat kecepatan putaran mesin. Misal; Pada mesin 4 langkah 4 silinder, sudut dwell biasanya telah ditetapkan oleh pabrikan sebesar 52 - 56 derajat. Nilai ini akan tetap pada putaran mesin rendah maupun putaran mesin tinggi. Sistem pengapian konvensional dengan kontak poin memiliki banyak kelemahan, diantaranya: Perawatan kontak poin harus dilakukan secara berkala. Kontak poin atau platina akan mengalami keausan karena terjadi kontak fisik pada area kontak poinnya. Sehingga perlu dilakukan penggantian secara rutin. Terjadi penurunan kualitas percikan bunga api pada saat terjadi pertambahan putaran mesin. Semakin tinggi putaran mesin, semakin jelek kualitas percikan bunga api. Kelemahan-kelamahan diatas memicu para pakar otomotif untuk mengembangkan sistem pengapian yang lebih handal dan lebih baik hingga lahirlah sistem pengapian elektronik. Dwell Time pada Sistem Pengapian Elektronik \u00b6 Dwell Angle pada sistem pengapian konvensional akan bernilai tetap pada berbagai tingkat kecepatan putaran mesin. Sedangkan pada sistem pengapian elektronik tidak akan lagi ditemukan Dwell Angle , hal ini karena jenis pengaturan proses pengisian dan pengosongan kumparan induktif sudah tidak menggunakan kontak poin. Pengaturan proses pengisian dan pengosongan kumparan induktif digantikan oleh komponen-komponen elektronika. Penamaan Dwell Angle menjadi tidak relevan dengan prinsip kerja sistem pengapian elektronik, sehingga penamaan Dwell Angle berubah menjadi \" Dwell Time \". Dwell Time adalah sejumlah waktu yang diperlukan untuk mengisi tegangan pada kumparan induktif hingga mencapai tingkat energi maksimum. Pada mesin dengan pengontrol modern, dwell didefinisikan dalam milisecond (ms) atau milidetik. Kumparan ignition coil pada umumnya memiliki dwell antara 2 milidetik hingga 5 milidetik. Pada sistem pengapian elektronik, pengaturan dwell jauh lebih baik daripada mesin berbasis distributor. Dwell Time atau waktu dwell akan bervariasi sesuai dengan perubahan putaran mesin. Ketika putaran mesin meningkat, dwell mengalami penurunan waktu. Pada saat putaran mesin tinggi sistem pengapian induktif berbasis distributor kontak poin tidak akan memiliki \"waktu\" dwell yang cukup untuk mengisi penuh ignition coil. Hal ini akan mengakibatkan percikan bunga api menjadi lemah di putaran tinggi dan dapat menyebabkan menurunnya optimalisasi performa mesin. Hal ini menjadi penyebab lahirnya sistem pengapian elektronik yang mampu mengisi ignition coil dengan cepat pada putaran tinggi. Sistem pengapian pengosongan induktif ( Inductive Discharge ) modern telah mampu mengatasi penurunan performa mesin karena masalah dwell, yaitu dengan menggunakan ignition coil yang dipasang per silinder atau ignition coil pada masing-masing spark plug (busi). Pengaruh Dwell Terhadap Kinerja Mesin \u00b6 Dwell sangat penting untuk kinerja mesin. Ketika melakukan perawatan berkala mesin kebanyakan orang/mekanik akan terfokus pada ignition timing atau waktu pengapian dan tidak memberi perhatian yang cukup pada masalah dwell. Dwell adalah hal yang paling sering diabaikan bahkan terlupakan. Padahal dwell diperlukan untuk mengontrol sejumlah energi yang tersimpan dalam kumparan pengapian. Terlalu cepat dwell (untuk sistem pengapian elektronik) atau terlalu kecil dwell (untuk sistem pengapian konvensional) maka proses pengisian kumparan induktif akan menjadi rendah, hal ini menghasilkan percikan bunga api busi yang lemah. Terlalu lama dwell (untuk sistem pengapian elektronik) atau terlalu besar dwell (untuk sistem pengapian konvensional) maka kumparan induktif akan menjadi lebih panas. Overheating (panas berlebihan) pada kumparan akan menyebabkan pengisian kumparan menjadi lebih mudah jatuh (breakdown), dan tidak akan mampu menyimpan banyak energi, hal ini juga menyebabkan hasil percikan bunga api lemah. Pengaruh Tegangan Terhadap Dwell Time \u00b6 Dwell Time yang diperlukan tergantung pada tegangan baterai. Jika tegangan baterai meningkat, Dwell Time dapat diturunkan. Jika tegangan baterai berkurang, Dwell Time perlu ditingkatkan. Banyak ECU memiliki tabel trim (penyesuai) yang akan menyesuaikan dwell berdasarkan tegangan baterai. Jika ECU tidak mampu menyesuaikan dwell berdasarkan perubahan tegangan baterai, maka akan ada dua hal yang bisa terjadi, yaitu: Jika tegangan baterai menurun, jumlah energi dalam kumparan akan menurun dan mengakibatkan percikan bunga api lemah Jika baterai tegangan meningkat, kumparan akan terlalu panas - Maka hal ini pun tidak akan mencapai kualitas percikan api yang lebih kuat. Gambar 3. Grafik Pengisian Kumparan Induktif Grafik diatas adalah contoh dari waktu pengisian kumparan induktif. Anda dapat melihat bahwa Dwell Time meningkat secara signifikan di bawah 12V. Ketika terisi penuh kumparan induktif akan menghasilkan 0,9 milidetik durasi percikan dengan 25 mJ energi percikan, 26 kV tegangan jatuh dan 62 mA arus puncak. Dwell dan Ignition Coil \u00b6 Jangan pernah mencoba-coba ignition coil. Pastikan Anda mengetahui secara persis berapa banyak Dwell Time yang diperlukan kumparan induktif (Ignition Coil) untuk mengoptimalkan kinerjanya. Pabrikan biasanya menerbitkan lembar data untuk kumparan induktif yang memberikan informasi tentang dwell v.s. tegangan. Jika tidak ditemukan lembar data, cobalah lakukan pengukuran dwell dengan osiloskop. Hubungkan osiloskop ke sisi primer koil dan ukurlah waktu yang dibutuhkan untuk mengisi kumparan induktif pada tingkat tegangan yang berbeda. Juga diperlukan pengukuran arus, bukan pengukuran tegangan (Perhatian: Berhati-hatilah saat terjadi pengosongan kumparan induktif). Gambar 4. Contoh Spesifikasi Ignition Coil Pengisian kumparan induktif tidak boleh melampaui 100% dari kapasitas energi. Jika kumparan memiliki Dwell Time 2 milidetik pada 12 Volt dan kemudian dinaikan dwell-nya untuk 5 milidetik pada 12 Volt ini hanya akan menyebabkan kumparan induktif terlalu panas. Kumparan overheating lebih rentan terhadap kerusakan internal dan akan menghasilkan percikan lemah. Capacitive Discharge Ignition dan Dwell \u00b6 Dwell Time digunakan untuk mendefinisikan proses pengisian kumparan induktif. Sedangkan sistem pengapian elektronik tipe CDI ( Capacitive Discharge Ignition ) memiliki prinsip berbeda. Pada sistem Capacitive Discharge proses pengisian terjadi pada kapasitor bukan pada kumparan induktif. Pengisian kapasitor menggunakan tegangan tinggi hingga 400 Volt. Sehingga proses pengisian kapasitor akan lebih cepat jika dibandingkan proses pengisian kumparan induktif dengan tegangan 12 Volt. Proses pengisian kapasitor dengan tegangan 400 Volt membutuhkan waktu kurang lebih 500 mikrodetik hingga 1 milidetik, sedangkan proses pengisian kumparan induktif membutuhkan waktu antara 2 milidetik hingga 5 milidetik. Gambar 5. Sirkuit Sistem Pengapian CDI Pada umumnya sistem pengapian Capacitive Discharge melakukan pra-pengisian ( pre-charge ) kapasitor dan menunggu pemicu dari ECU dalam melakukan pengosongan ( discharge ) kapasitor. Sistem Capacitive Discharge biasanya menggunakan output dwell untuk menentukan kapan harus di mulai pengisian kapasitor. Periksa produsen pembuat Capacitive Discharg e untuk menentukan bagaimana sistem pengapian dipicu. Satu hal yang harus diperhatikan adalah waktu antara pengisian dengan terjadinya percikan bunga api pada sistem Capacitive Discharge Multi-Spark . Karena beberapa sistem pengapian Capacitive Discharge menghasilkan multi-spark dibawah putaran spesifikasi. Kapasitor membutuhkan waktu pengisian yang cukup antar percikan bunga api yang terjadi, hal ini terkadang menyebabkan waktu pengapian menjadi terlambat. Mengetahui Kemampuan Ignition Coil \u00b6 Pada umumnya Ignition Coil membutuhkan waktu pengisian maksimum kumparan induktif antara 2 milidetik hingga 5 milidetik. Dengan waktu tersebut, Ignition Coil mampu menghasilkan 200 hingga 500 kali percikan bunga api dalam setiap detik atau 12.000 hingga 18.000 kali percikan bunga api dalam setiap menit. Bagaimana kita mengetahui kemampuan Ignition Coil? Misal ; Lembar Data Ignition Coil menunjukan waktu dwell 5 milidetik. 1 detik sama dengan 1 . 000 milidetik sehingga dalam setiap detik terjadi pengisian kumparan induktif sebanyak 200 kali . 1 . 000 milidetik / 5 milidetik menghasilkan 200 kali . Setiap menit berarti 200 x 60 , dihasilkan 12 . 000 kali pengisian kumparan induktif atau percikan bunga api. Untuk mengetahui kemampuan maksimum Ignition Coil terhadap putaran mesin maka menggunakan rumus: Rumus (Percikan dalam setiap menit x 2) / Jumlah silinder Jika digunakan pada mesin 4 langkah 4 silinder maka: Rumus (12.000 x 2 ) / 4 = 6.000 RPM Dari perhitungan diatas, kita dapat mengetahui bahwa Ignition Coil dengan Dwell Time 5 milidetik hanya mampu bekerja maksimum hingga 6.000 RPM. Kesimpulan \u00b6 Dari pembahasan diatas diketahui bahwa dwell bukanlah faktor yang bisa dikesampingkan, seharusnya justru menjadi faktor yang harus diperhatikan dengan baik agar mesin mampu menghasilkan performa yang optimal. Dwell yang tidak sempurna menghasilkan kualitas percikan bunga api yang jelek, dan pengapian yang jelek akan menurunkan performa mesin karena pembakaran yang tidak sempurna pada ruang bakar, efeknya antara lain: konsumsi bahan bakar boros; tenaga mesin menurun; gas buang yang berbahaya dan; detonasi yang memicu keausan komponen mesin. Demikian artikel yang cukup panjang membahas tentang dwell pada sistem pengapian mesin. Bahasan diatas disusun untuk menggugah kembali materi-materi yang hampir terlupakan namun sebenarnya memiliki peranan penting dalam menghasilkan performa mesin yang maksimal. Bahasan diatas mungkin masih sangat terbatas dan belum mencakup secara keseluruhan pertanyaan-pertanyaan yang terkait dengan dwell pada sistem pengapian. Maka dari itu, penulis berencana membahas lebih detail tentang Dwell Time pada sistem pengapian elektronik dan Dwell Angle pada sistem pengapian konvensional pada artikel terpisah serta bagaimana melakukan pemeliharaan dan perawatan terhadap dwell. Daftar Pustaka \u00b6 Ignition System, Wikipedia Ignition Coil Dwell Time, AutoSpeed Ignition Theory, ICE Ignition FAQ Dwell, SPDISpark All About Ignition Coil, Federal Mogul Sistem Kelistrikan dan Bahan Bakar Otomotip, Direktorat Pendidikan Menengah dan Kejuruan 1979 Capacitive Discharge Ignition, STMicroelectronics","title":"Dwell Sistem Pengapian"},{"location":"ototronik/dwell/#dwell-sistem-pengapian","text":"Dwell Angle (Sudut Dwell) adalah jumlah derajat poros cam distributor ketika kontak poin tertutup. Dwell Angle atau Sudut Dwell bernilai tetap pada berbagai tingkat kecepatan putaran mesin. Dwell Time (Waktu Dwell) adalah sejumlah waktu yang diperlukan untuk mengisi tegangan pada kumparan induktif hingga mencapai tingkat energi maksimum. Dwell Time atau waktu dwell akan bervariasi sesuai dengan perubahan putaran mesin.","title":"Dwell Sistem Pengapian"},{"location":"ototronik/dwell/#memahami-dwell-pada-sistem-pengapian","text":"Sistem Pengapian atau Ignition System merupakan salah satu bagian penting yang secara langsung mempengaruhi kinerja mesin. Percikan bunga api pada busi digunakan untuk membakar campuran udara dan bahan bakar yang telah dikompresikan diruang bakar. Kualitas percikan bunga api yang jelek menyebabkan campuran udara dan bahan bakar tidak mampu terbakar dengan sempurna. Pembakaran tidak sempurna merupakan kasus yang terus diteliti, karena hal ini merupakan masalah serius yang menjadi penyebab utama penurunan performa mesin, konsumsi bahan bakar menjadi boros, dan gas buang sisa pembakaran yang berbahaya. Untuk menghasilkan percikan bunga api yang baik tidak hanya di perlukan komponen pengapian yang berkualitas, namun faktor-faktor yang mempengaruhi kinerja sistem pengapian juga berperan dalam menentukan kualitas percikan bunga api. Dwell merupakan faktor penting yang menunjang pada kualitas percikan bunga api. Akhir-akhir ini, pembahasan tentang Dwell sudah mulai memudar bahkan hampir menghilang dari pembahasan materi sistem pengapian. Gambar 1. Dwell Meter","title":"Memahami Dwell pada Sistem Pengapian"},{"location":"ototronik/dwell/#dwell-angle-pada-sistem-pengapian-konvensional","text":"Dwell Angle pada mulanya dibahas pada sistem pengapian konvensional yang secara spesifik berkaitan erat dengan kontak poin atau platina. Sistem pengapian konvensional adalah sistem pengapian tertua yang menjadi cikal bakal lahirnya sistem pengapian modern. Sistem pengapian konvensional identik dengan distributor dan kontak poin. Pada mesin yang berbasis distributor generasi lama, cam pada distributor digunakan untuk membuka dan menutup sebuah kontak poin. Kontak poin dihubungkan untuk mengalirkan tegangan dari baterai ke dalam kumparan ignition coil (kumparan primer). Ketika kontak poin menutup, kumparan primer diisi tegangan. Ketika kontak poin terbuka, tegangan pada kumparan primer dikosongkan, dan terjadi induksi terhadap kumparan sekunder. Tegangan tinggi yang dihasilkan kumparan sekunder dialirkan ke busi melalui distributor. Dari sinilah lahir penamaan \" Dwell Angle \" atau dalam bahasa Indonesia diterjemahkan menjadi \"Sudut Dwell\". Dwell Angle atau sudut dwell adalah jumlah derajat poros cam distributor ketika kontak poin tertutup. Dwell angle sering diartikan sebagai sudut tutup kontak poin ( Breaker Point Closed Angle ), hal ini karena pada mulanya hanya tersedia pada sistem pengapian konvensional. Gambar 2. Sudut Dwell pada Cam Distributor Sudut Dwell sebenarnya bukan untuk mendefinisikan keadaan kontak poin, tetapi untuk mendefinisikan proses pengisian dan pengosongan tegangan pada kumparan primer. Kontak poin digunakan untuk mengatur proses pengisian dan pengosongan pada kumparan primer. Oleh karena itu, Dwell Angle akan bernilai tetap pada berbagai tingkat kecepatan putaran mesin. Misal; Pada mesin 4 langkah 4 silinder, sudut dwell biasanya telah ditetapkan oleh pabrikan sebesar 52 - 56 derajat. Nilai ini akan tetap pada putaran mesin rendah maupun putaran mesin tinggi. Sistem pengapian konvensional dengan kontak poin memiliki banyak kelemahan, diantaranya: Perawatan kontak poin harus dilakukan secara berkala. Kontak poin atau platina akan mengalami keausan karena terjadi kontak fisik pada area kontak poinnya. Sehingga perlu dilakukan penggantian secara rutin. Terjadi penurunan kualitas percikan bunga api pada saat terjadi pertambahan putaran mesin. Semakin tinggi putaran mesin, semakin jelek kualitas percikan bunga api. Kelemahan-kelamahan diatas memicu para pakar otomotif untuk mengembangkan sistem pengapian yang lebih handal dan lebih baik hingga lahirlah sistem pengapian elektronik.","title":"Dwell Angle pada Sistem Pengapian Konvensional"},{"location":"ototronik/dwell/#dwell-time-pada-sistem-pengapian-elektronik","text":"Dwell Angle pada sistem pengapian konvensional akan bernilai tetap pada berbagai tingkat kecepatan putaran mesin. Sedangkan pada sistem pengapian elektronik tidak akan lagi ditemukan Dwell Angle , hal ini karena jenis pengaturan proses pengisian dan pengosongan kumparan induktif sudah tidak menggunakan kontak poin. Pengaturan proses pengisian dan pengosongan kumparan induktif digantikan oleh komponen-komponen elektronika. Penamaan Dwell Angle menjadi tidak relevan dengan prinsip kerja sistem pengapian elektronik, sehingga penamaan Dwell Angle berubah menjadi \" Dwell Time \". Dwell Time adalah sejumlah waktu yang diperlukan untuk mengisi tegangan pada kumparan induktif hingga mencapai tingkat energi maksimum. Pada mesin dengan pengontrol modern, dwell didefinisikan dalam milisecond (ms) atau milidetik. Kumparan ignition coil pada umumnya memiliki dwell antara 2 milidetik hingga 5 milidetik. Pada sistem pengapian elektronik, pengaturan dwell jauh lebih baik daripada mesin berbasis distributor. Dwell Time atau waktu dwell akan bervariasi sesuai dengan perubahan putaran mesin. Ketika putaran mesin meningkat, dwell mengalami penurunan waktu. Pada saat putaran mesin tinggi sistem pengapian induktif berbasis distributor kontak poin tidak akan memiliki \"waktu\" dwell yang cukup untuk mengisi penuh ignition coil. Hal ini akan mengakibatkan percikan bunga api menjadi lemah di putaran tinggi dan dapat menyebabkan menurunnya optimalisasi performa mesin. Hal ini menjadi penyebab lahirnya sistem pengapian elektronik yang mampu mengisi ignition coil dengan cepat pada putaran tinggi. Sistem pengapian pengosongan induktif ( Inductive Discharge ) modern telah mampu mengatasi penurunan performa mesin karena masalah dwell, yaitu dengan menggunakan ignition coil yang dipasang per silinder atau ignition coil pada masing-masing spark plug (busi).","title":"Dwell Time pada Sistem Pengapian Elektronik"},{"location":"ototronik/dwell/#pengaruh-dwell-terhadap-kinerja-mesin","text":"Dwell sangat penting untuk kinerja mesin. Ketika melakukan perawatan berkala mesin kebanyakan orang/mekanik akan terfokus pada ignition timing atau waktu pengapian dan tidak memberi perhatian yang cukup pada masalah dwell. Dwell adalah hal yang paling sering diabaikan bahkan terlupakan. Padahal dwell diperlukan untuk mengontrol sejumlah energi yang tersimpan dalam kumparan pengapian. Terlalu cepat dwell (untuk sistem pengapian elektronik) atau terlalu kecil dwell (untuk sistem pengapian konvensional) maka proses pengisian kumparan induktif akan menjadi rendah, hal ini menghasilkan percikan bunga api busi yang lemah. Terlalu lama dwell (untuk sistem pengapian elektronik) atau terlalu besar dwell (untuk sistem pengapian konvensional) maka kumparan induktif akan menjadi lebih panas. Overheating (panas berlebihan) pada kumparan akan menyebabkan pengisian kumparan menjadi lebih mudah jatuh (breakdown), dan tidak akan mampu menyimpan banyak energi, hal ini juga menyebabkan hasil percikan bunga api lemah.","title":"Pengaruh Dwell Terhadap Kinerja Mesin"},{"location":"ototronik/dwell/#pengaruh-tegangan-terhadap-dwell-time","text":"Dwell Time yang diperlukan tergantung pada tegangan baterai. Jika tegangan baterai meningkat, Dwell Time dapat diturunkan. Jika tegangan baterai berkurang, Dwell Time perlu ditingkatkan. Banyak ECU memiliki tabel trim (penyesuai) yang akan menyesuaikan dwell berdasarkan tegangan baterai. Jika ECU tidak mampu menyesuaikan dwell berdasarkan perubahan tegangan baterai, maka akan ada dua hal yang bisa terjadi, yaitu: Jika tegangan baterai menurun, jumlah energi dalam kumparan akan menurun dan mengakibatkan percikan bunga api lemah Jika baterai tegangan meningkat, kumparan akan terlalu panas - Maka hal ini pun tidak akan mencapai kualitas percikan api yang lebih kuat. Gambar 3. Grafik Pengisian Kumparan Induktif Grafik diatas adalah contoh dari waktu pengisian kumparan induktif. Anda dapat melihat bahwa Dwell Time meningkat secara signifikan di bawah 12V. Ketika terisi penuh kumparan induktif akan menghasilkan 0,9 milidetik durasi percikan dengan 25 mJ energi percikan, 26 kV tegangan jatuh dan 62 mA arus puncak.","title":"Pengaruh Tegangan Terhadap Dwell Time"},{"location":"ototronik/dwell/#dwell-dan-ignition-coil","text":"Jangan pernah mencoba-coba ignition coil. Pastikan Anda mengetahui secara persis berapa banyak Dwell Time yang diperlukan kumparan induktif (Ignition Coil) untuk mengoptimalkan kinerjanya. Pabrikan biasanya menerbitkan lembar data untuk kumparan induktif yang memberikan informasi tentang dwell v.s. tegangan. Jika tidak ditemukan lembar data, cobalah lakukan pengukuran dwell dengan osiloskop. Hubungkan osiloskop ke sisi primer koil dan ukurlah waktu yang dibutuhkan untuk mengisi kumparan induktif pada tingkat tegangan yang berbeda. Juga diperlukan pengukuran arus, bukan pengukuran tegangan (Perhatian: Berhati-hatilah saat terjadi pengosongan kumparan induktif). Gambar 4. Contoh Spesifikasi Ignition Coil Pengisian kumparan induktif tidak boleh melampaui 100% dari kapasitas energi. Jika kumparan memiliki Dwell Time 2 milidetik pada 12 Volt dan kemudian dinaikan dwell-nya untuk 5 milidetik pada 12 Volt ini hanya akan menyebabkan kumparan induktif terlalu panas. Kumparan overheating lebih rentan terhadap kerusakan internal dan akan menghasilkan percikan lemah.","title":"Dwell dan Ignition Coil"},{"location":"ototronik/dwell/#capacitive-discharge-ignition-dan-dwell","text":"Dwell Time digunakan untuk mendefinisikan proses pengisian kumparan induktif. Sedangkan sistem pengapian elektronik tipe CDI ( Capacitive Discharge Ignition ) memiliki prinsip berbeda. Pada sistem Capacitive Discharge proses pengisian terjadi pada kapasitor bukan pada kumparan induktif. Pengisian kapasitor menggunakan tegangan tinggi hingga 400 Volt. Sehingga proses pengisian kapasitor akan lebih cepat jika dibandingkan proses pengisian kumparan induktif dengan tegangan 12 Volt. Proses pengisian kapasitor dengan tegangan 400 Volt membutuhkan waktu kurang lebih 500 mikrodetik hingga 1 milidetik, sedangkan proses pengisian kumparan induktif membutuhkan waktu antara 2 milidetik hingga 5 milidetik. Gambar 5. Sirkuit Sistem Pengapian CDI Pada umumnya sistem pengapian Capacitive Discharge melakukan pra-pengisian ( pre-charge ) kapasitor dan menunggu pemicu dari ECU dalam melakukan pengosongan ( discharge ) kapasitor. Sistem Capacitive Discharge biasanya menggunakan output dwell untuk menentukan kapan harus di mulai pengisian kapasitor. Periksa produsen pembuat Capacitive Discharg e untuk menentukan bagaimana sistem pengapian dipicu. Satu hal yang harus diperhatikan adalah waktu antara pengisian dengan terjadinya percikan bunga api pada sistem Capacitive Discharge Multi-Spark . Karena beberapa sistem pengapian Capacitive Discharge menghasilkan multi-spark dibawah putaran spesifikasi. Kapasitor membutuhkan waktu pengisian yang cukup antar percikan bunga api yang terjadi, hal ini terkadang menyebabkan waktu pengapian menjadi terlambat.","title":"Capacitive Discharge Ignition dan Dwell"},{"location":"ototronik/dwell/#mengetahui-kemampuan-ignition-coil","text":"Pada umumnya Ignition Coil membutuhkan waktu pengisian maksimum kumparan induktif antara 2 milidetik hingga 5 milidetik. Dengan waktu tersebut, Ignition Coil mampu menghasilkan 200 hingga 500 kali percikan bunga api dalam setiap detik atau 12.000 hingga 18.000 kali percikan bunga api dalam setiap menit. Bagaimana kita mengetahui kemampuan Ignition Coil? Misal ; Lembar Data Ignition Coil menunjukan waktu dwell 5 milidetik. 1 detik sama dengan 1 . 000 milidetik sehingga dalam setiap detik terjadi pengisian kumparan induktif sebanyak 200 kali . 1 . 000 milidetik / 5 milidetik menghasilkan 200 kali . Setiap menit berarti 200 x 60 , dihasilkan 12 . 000 kali pengisian kumparan induktif atau percikan bunga api. Untuk mengetahui kemampuan maksimum Ignition Coil terhadap putaran mesin maka menggunakan rumus: Rumus (Percikan dalam setiap menit x 2) / Jumlah silinder Jika digunakan pada mesin 4 langkah 4 silinder maka: Rumus (12.000 x 2 ) / 4 = 6.000 RPM Dari perhitungan diatas, kita dapat mengetahui bahwa Ignition Coil dengan Dwell Time 5 milidetik hanya mampu bekerja maksimum hingga 6.000 RPM.","title":"Mengetahui Kemampuan Ignition Coil"},{"location":"ototronik/dwell/#kesimpulan","text":"Dari pembahasan diatas diketahui bahwa dwell bukanlah faktor yang bisa dikesampingkan, seharusnya justru menjadi faktor yang harus diperhatikan dengan baik agar mesin mampu menghasilkan performa yang optimal. Dwell yang tidak sempurna menghasilkan kualitas percikan bunga api yang jelek, dan pengapian yang jelek akan menurunkan performa mesin karena pembakaran yang tidak sempurna pada ruang bakar, efeknya antara lain: konsumsi bahan bakar boros; tenaga mesin menurun; gas buang yang berbahaya dan; detonasi yang memicu keausan komponen mesin. Demikian artikel yang cukup panjang membahas tentang dwell pada sistem pengapian mesin. Bahasan diatas disusun untuk menggugah kembali materi-materi yang hampir terlupakan namun sebenarnya memiliki peranan penting dalam menghasilkan performa mesin yang maksimal. Bahasan diatas mungkin masih sangat terbatas dan belum mencakup secara keseluruhan pertanyaan-pertanyaan yang terkait dengan dwell pada sistem pengapian. Maka dari itu, penulis berencana membahas lebih detail tentang Dwell Time pada sistem pengapian elektronik dan Dwell Angle pada sistem pengapian konvensional pada artikel terpisah serta bagaimana melakukan pemeliharaan dan perawatan terhadap dwell.","title":"Kesimpulan"},{"location":"ototronik/dwell/#daftar-pustaka","text":"Ignition System, Wikipedia Ignition Coil Dwell Time, AutoSpeed Ignition Theory, ICE Ignition FAQ Dwell, SPDISpark All About Ignition Coil, Federal Mogul Sistem Kelistrikan dan Bahan Bakar Otomotip, Direktorat Pendidikan Menengah dan Kejuruan 1979 Capacitive Discharge Ignition, STMicroelectronics","title":"Daftar Pustaka"},{"location":"ototronik/id-regulator-mekanik/","text":"Identifikasi Terminal Regulator Mekanik \u00b6 Suatu hari dibalik telephone selular \" Mas, kabel-kabel terminal regulator mobilku dimakan tikus, hampir terputus semua. Sebagian kabel terlepas dari titik kontak solderannya. Bagaimana ini menyambungkannya? Pusing kalau urusan terminal regulator mekanik \". Terminal Regulator Mekanik itu hanya ada 6 kabel untuk regulator mekanik tipe umum (general), namun menentukan kabel-kabel terminal tersebut ternyata cukup membingungkan. Bagi anda yang masih kebingungan untuk menentukan terminal regulator mekanik, artikel ini mudah-mudahan dapat membantu. Karena ternyata menentukan terminal regulator mekanik itu mudah dan cepat jika kita tahu patokannya. Mari kita lanjutkan membacanya... Mengidentifikasi Terminal Regulator Mekanik \u00b6 Untuk memudahkan dalam menentukan terminal regulator mekanik sebaiknya ikuti langkah-langkah dibawah ini, namun akan lebih mudah lagi jika artikel sebelumnya yang membahas tentang Prinsip Kerja Regulator Mekanik dipahami, minimal memahami gambar terutama aliran tegangannya. Gambar dibawah ini merupakan acuan yang harus saling terkait satu sama lain untuk memudahkan dalam menentukan terminal regulator mekanik. Gambar telah disesuaikan antara gambar diagram aliran tegangan, gambar regulator mekanik aslinya, dan gambar regulator mekanik yang diperjelas. Gambar 1. Diagram Aliran Tegangan Gambar 2. Bagian Bawah Regulator Mekanik Gambar 3. Bagian Bawah Regulator Diperjelas Peganglah regulator, lihat bagian bawahnya dan ikuti langkah dibawah ini: 1. Membagi Dua Bagian Regulator \u00b6 Regulator secara garis besar dibagi menjadi dua bagian utama yaitu; Voltage Relay dan Voltage Regulator. Perhatikan Gambar 2 dan Gambar 3, disana terlihat bahwa yang memiliki resistor hanyalah voltage regulator (lihat Gambar 1). Ambil garis tengah ilusi secara vertikal untuk memisahkan antara voltage regulator dengan voltage relay. Pada Gambar 3 terlihat garis vertikal terputus-putus berwarna merah sebagai garis ilusi untuk memisahkan bagian utama regulator mekanik. 2. Menentukan Titik Kontak \u00b6 Setelah regulator mekanik dibagi menjadi dua bagian utama selanjutnya adalah menentukan titik kontak. Perhatikan gambar dibawah ini: Gambar 4. Titik Kontak Regulator Mekanik Setiap bagian utama regulator (voltage relay dan voltage regulator) memiliki 3 titik kontak (lihat gambar 1). 3 titik kontak pada voltage relay yaitu titik kontak A, titik kontak B dan titik kontak C. 3 titik kontak pada voltage regulator yaitu titik kontak 1, titik kontak 2 dan titik kontak 3. Ketiga titik kontak baik yang terdapat pada voltage relay maupun pada voltage regulator saling berhadapan dan salah satu dari masing-masing bagian utama, titik kontaknya dihubungkan ke massa bodi. Namun ada titik kontak yang memiliki ukuran lebih besar dari yang lainnya. Pada gambar 3 terlihat bahwa ada 2 titik kontak yang memiliki ukuran lebih besar dari yang lainnya yaitu titik kontak 2 dan titik kontak B, satu titik kontak terdapat pada voltage relay dan satu titik kontak terdapat pada voltage regulator. Sedangkan 5 titik kontak lainnya memiliki ukuran yang lebih kecil (titik kontak 1, 3, A, C, dan X). 3. Terminal Voltage Regulator \u00b6 Lihat Gambar 3 dan perhatikan baik-baik titik kontak pada bagian voltage regulator (abaikan dulu voltage relay). Pada bagian voltage regulator hanya ada 3 titik kontak yaitu titik kontak 1, titik kontak 2 dan titik kontak 3. Titik kontak 2 memiliki ukuran lebih besar dari titik kontak 1 dan 3, hal ini karena titik kontak 2 merupakan inti besi dari lilitan voltage regulator. Titik kontak 2 adalah bagian tengah dari 3 titik kontak yang saling berhadapan (lihat Gambar 1 dan Gambar 4) dan merupakan titik kontak yang bergerak pada saat regulator bekerja, terkadang berhubungan dengan titik kontak 1 dan atau berhubungan dengan titik kontak 3. Pada Gambar 1 terlihat bahwa titik kontak 2 (bagian tengah) merupakan terminal F, maka dapat dipastikan bahwa titik kontak yang paling besar (titik kontak 2) pada voltage regulator adalah terminal F (pada Gambar 3 kabel berwarna kuning). Titik kontak 2 merupakan salah satu ujung resistor, sedangkan ujung resistor yang satu lagi merupakan titik kontak 1. Perhatikan Gambar 1 bahwa ujung resistor yang satu lagi menuju terminal IG, maka dapat dipastikan bahwa titik kontak 1 yang merupakan ujung resistor adalah terminal IG. Ujung-ujung resistor berhubungan dengan titik kontak 1 dan titik kontak 2, sehingga mudah untuk diingat bahwa ujung resistor yang berhubungan titik kontak 2 (yang memiliki titik kontak lebih besar) merupakan terminal F sedangkan ujung resistor yang berhubungan dengan titik kontak 1 merupakan terminal IG. Satu titik kontak tersisa pada voltage regulator dan saya yakin anda sudah bisa menebak titik kontak ini. Ya... Titik kontak 3 dihubungkan ke massa bodi maka dapat dipastikan bahwa titik kontak ini adalah terminal E. Pastikan langkah ini dipahami, sehingga kita bisa dengan mudah menentukan 3 terminal pada 3 titik kontak di voltage regulator. Jika yakin sudah paham, lanjutkan langkah berikutnya... 4. Terminal Voltage Relay \u00b6 Pada bagian voltage relay terdapat 4 titik kontak yaitu; titik kontak A, titik kontak B, titik kontak C dan titik kontak X. Titik kontak B memiliki ukuran yang lebih besar dari titik kontak lainnya, hal ini karena titik kontak B merupakan inti besi dari lilitan voltage relay. Titik kontak B merupakan titik kontak bagian tengah dari 3 titik kontak yang saling berdekatan pada voltage relay. Titik kontak B merupakan bagian yang bergerak pada voltage relay. Pada Gambar 1 terlihat bahwa titik kontak B menuju ke terminal L, maka dapat dipastikan bahwa titik kontak B atau titik kontak yang paling besar pada voltage relay adalah terminal L. Titik kontak C sejajar dengan titik kontak A jika ditarik garis lurus. Namun harus diingat bahwa disetiap 3 titik kontak yang saling berdekatan selalu ada satu titik kontak yang dihubungkan ke massa bodi. Pada gambar 3 terlihat bahwa titik kontak A dihubungkan ke massa bodi maka titik kontak A adalah terminal E, tetapi karena terminal E sudah diambil dari salah satu titik kontak voltage regulator, maka titik kontak A tidak perlu lagi dikeluarkan sebagai terminal E. Lalu titik kontak C sebagai terminal apa? Jika melihat Gambar 1 maka kita dapat menemukan jawabannya. Jika titik kontak B adalah terminal L, titik kontak A adalah massa bodi maka titik kontak C dapat dipastikan sebagai terminal B. Tersisa satu titik kontak lagi yaitu titik kontak X. Titik kontak X merupakan bagian yang agak jauh dari 3 titik kontak yang saling berdekatan pada voltage relay. Bisakah anda menebak titik kontak X sebagai terminal apa? Ya betul... Titik kontak X adalah terminal N (Netral). Perhatikan Gambar 1 bahwa masih ada satu lagi terminal pada regulator yang belum dibahas, maka dapat dipastikan bahwa titik kontak X adalah terminal N. Kesimpulan \u00b6 4 langkah diatas merupakan cara terbaik, termudah dan tercepat untuk menentukan terminal pada regulator mekanik bagi penulis secara pribadi. Langkah-langkah diatas merupakan pengalaman pribadi penulis yang sering digunakan dilapangan saat berhubungan dengan terminal regulator mekanik. Hal ini karena sering ditemukan regulator mekanik pada kendaraan yang dibuang soketnya. Namun bukan berarti cara diatas adalah hal baku yang wajib diikuti, cara diatas jelas tidak sesuai dengan SOP (standar operasional prosedur). Cara diatas hanya untuk memudahkan saat bekerja saja. Jika anda telah memiliki cara sendiri yang lebih cepat maka tidak usah mengikuti cara-cara diatas. Semoga artikel diatas bermanfaat dan dapat mempercepat pekerjaan anda. Selamat bekerja dan ingat! Selalu gunakan alat keselamatan kerja pada saat bekerja... Salam hangat dari Ciamis, Jawa Barat, Indonesia...","title":"Identifikasi Regulator Mekanik"},{"location":"ototronik/id-regulator-mekanik/#identifikasi-terminal-regulator-mekanik","text":"Suatu hari dibalik telephone selular \" Mas, kabel-kabel terminal regulator mobilku dimakan tikus, hampir terputus semua. Sebagian kabel terlepas dari titik kontak solderannya. Bagaimana ini menyambungkannya? Pusing kalau urusan terminal regulator mekanik \". Terminal Regulator Mekanik itu hanya ada 6 kabel untuk regulator mekanik tipe umum (general), namun menentukan kabel-kabel terminal tersebut ternyata cukup membingungkan. Bagi anda yang masih kebingungan untuk menentukan terminal regulator mekanik, artikel ini mudah-mudahan dapat membantu. Karena ternyata menentukan terminal regulator mekanik itu mudah dan cepat jika kita tahu patokannya. Mari kita lanjutkan membacanya...","title":"Identifikasi Terminal Regulator Mekanik"},{"location":"ototronik/id-regulator-mekanik/#mengidentifikasi-terminal-regulator-mekanik","text":"Untuk memudahkan dalam menentukan terminal regulator mekanik sebaiknya ikuti langkah-langkah dibawah ini, namun akan lebih mudah lagi jika artikel sebelumnya yang membahas tentang Prinsip Kerja Regulator Mekanik dipahami, minimal memahami gambar terutama aliran tegangannya. Gambar dibawah ini merupakan acuan yang harus saling terkait satu sama lain untuk memudahkan dalam menentukan terminal regulator mekanik. Gambar telah disesuaikan antara gambar diagram aliran tegangan, gambar regulator mekanik aslinya, dan gambar regulator mekanik yang diperjelas. Gambar 1. Diagram Aliran Tegangan Gambar 2. Bagian Bawah Regulator Mekanik Gambar 3. Bagian Bawah Regulator Diperjelas Peganglah regulator, lihat bagian bawahnya dan ikuti langkah dibawah ini:","title":"Mengidentifikasi Terminal Regulator Mekanik"},{"location":"ototronik/id-regulator-mekanik/#1-membagi-dua-bagian-regulator","text":"Regulator secara garis besar dibagi menjadi dua bagian utama yaitu; Voltage Relay dan Voltage Regulator. Perhatikan Gambar 2 dan Gambar 3, disana terlihat bahwa yang memiliki resistor hanyalah voltage regulator (lihat Gambar 1). Ambil garis tengah ilusi secara vertikal untuk memisahkan antara voltage regulator dengan voltage relay. Pada Gambar 3 terlihat garis vertikal terputus-putus berwarna merah sebagai garis ilusi untuk memisahkan bagian utama regulator mekanik.","title":"1. Membagi Dua Bagian Regulator"},{"location":"ototronik/id-regulator-mekanik/#2-menentukan-titik-kontak","text":"Setelah regulator mekanik dibagi menjadi dua bagian utama selanjutnya adalah menentukan titik kontak. Perhatikan gambar dibawah ini: Gambar 4. Titik Kontak Regulator Mekanik Setiap bagian utama regulator (voltage relay dan voltage regulator) memiliki 3 titik kontak (lihat gambar 1). 3 titik kontak pada voltage relay yaitu titik kontak A, titik kontak B dan titik kontak C. 3 titik kontak pada voltage regulator yaitu titik kontak 1, titik kontak 2 dan titik kontak 3. Ketiga titik kontak baik yang terdapat pada voltage relay maupun pada voltage regulator saling berhadapan dan salah satu dari masing-masing bagian utama, titik kontaknya dihubungkan ke massa bodi. Namun ada titik kontak yang memiliki ukuran lebih besar dari yang lainnya. Pada gambar 3 terlihat bahwa ada 2 titik kontak yang memiliki ukuran lebih besar dari yang lainnya yaitu titik kontak 2 dan titik kontak B, satu titik kontak terdapat pada voltage relay dan satu titik kontak terdapat pada voltage regulator. Sedangkan 5 titik kontak lainnya memiliki ukuran yang lebih kecil (titik kontak 1, 3, A, C, dan X).","title":"2. Menentukan Titik Kontak"},{"location":"ototronik/id-regulator-mekanik/#3-terminal-voltage-regulator","text":"Lihat Gambar 3 dan perhatikan baik-baik titik kontak pada bagian voltage regulator (abaikan dulu voltage relay). Pada bagian voltage regulator hanya ada 3 titik kontak yaitu titik kontak 1, titik kontak 2 dan titik kontak 3. Titik kontak 2 memiliki ukuran lebih besar dari titik kontak 1 dan 3, hal ini karena titik kontak 2 merupakan inti besi dari lilitan voltage regulator. Titik kontak 2 adalah bagian tengah dari 3 titik kontak yang saling berhadapan (lihat Gambar 1 dan Gambar 4) dan merupakan titik kontak yang bergerak pada saat regulator bekerja, terkadang berhubungan dengan titik kontak 1 dan atau berhubungan dengan titik kontak 3. Pada Gambar 1 terlihat bahwa titik kontak 2 (bagian tengah) merupakan terminal F, maka dapat dipastikan bahwa titik kontak yang paling besar (titik kontak 2) pada voltage regulator adalah terminal F (pada Gambar 3 kabel berwarna kuning). Titik kontak 2 merupakan salah satu ujung resistor, sedangkan ujung resistor yang satu lagi merupakan titik kontak 1. Perhatikan Gambar 1 bahwa ujung resistor yang satu lagi menuju terminal IG, maka dapat dipastikan bahwa titik kontak 1 yang merupakan ujung resistor adalah terminal IG. Ujung-ujung resistor berhubungan dengan titik kontak 1 dan titik kontak 2, sehingga mudah untuk diingat bahwa ujung resistor yang berhubungan titik kontak 2 (yang memiliki titik kontak lebih besar) merupakan terminal F sedangkan ujung resistor yang berhubungan dengan titik kontak 1 merupakan terminal IG. Satu titik kontak tersisa pada voltage regulator dan saya yakin anda sudah bisa menebak titik kontak ini. Ya... Titik kontak 3 dihubungkan ke massa bodi maka dapat dipastikan bahwa titik kontak ini adalah terminal E. Pastikan langkah ini dipahami, sehingga kita bisa dengan mudah menentukan 3 terminal pada 3 titik kontak di voltage regulator. Jika yakin sudah paham, lanjutkan langkah berikutnya...","title":"3. Terminal Voltage Regulator"},{"location":"ototronik/id-regulator-mekanik/#4-terminal-voltage-relay","text":"Pada bagian voltage relay terdapat 4 titik kontak yaitu; titik kontak A, titik kontak B, titik kontak C dan titik kontak X. Titik kontak B memiliki ukuran yang lebih besar dari titik kontak lainnya, hal ini karena titik kontak B merupakan inti besi dari lilitan voltage relay. Titik kontak B merupakan titik kontak bagian tengah dari 3 titik kontak yang saling berdekatan pada voltage relay. Titik kontak B merupakan bagian yang bergerak pada voltage relay. Pada Gambar 1 terlihat bahwa titik kontak B menuju ke terminal L, maka dapat dipastikan bahwa titik kontak B atau titik kontak yang paling besar pada voltage relay adalah terminal L. Titik kontak C sejajar dengan titik kontak A jika ditarik garis lurus. Namun harus diingat bahwa disetiap 3 titik kontak yang saling berdekatan selalu ada satu titik kontak yang dihubungkan ke massa bodi. Pada gambar 3 terlihat bahwa titik kontak A dihubungkan ke massa bodi maka titik kontak A adalah terminal E, tetapi karena terminal E sudah diambil dari salah satu titik kontak voltage regulator, maka titik kontak A tidak perlu lagi dikeluarkan sebagai terminal E. Lalu titik kontak C sebagai terminal apa? Jika melihat Gambar 1 maka kita dapat menemukan jawabannya. Jika titik kontak B adalah terminal L, titik kontak A adalah massa bodi maka titik kontak C dapat dipastikan sebagai terminal B. Tersisa satu titik kontak lagi yaitu titik kontak X. Titik kontak X merupakan bagian yang agak jauh dari 3 titik kontak yang saling berdekatan pada voltage relay. Bisakah anda menebak titik kontak X sebagai terminal apa? Ya betul... Titik kontak X adalah terminal N (Netral). Perhatikan Gambar 1 bahwa masih ada satu lagi terminal pada regulator yang belum dibahas, maka dapat dipastikan bahwa titik kontak X adalah terminal N.","title":"4. Terminal Voltage Relay"},{"location":"ototronik/id-regulator-mekanik/#kesimpulan","text":"4 langkah diatas merupakan cara terbaik, termudah dan tercepat untuk menentukan terminal pada regulator mekanik bagi penulis secara pribadi. Langkah-langkah diatas merupakan pengalaman pribadi penulis yang sering digunakan dilapangan saat berhubungan dengan terminal regulator mekanik. Hal ini karena sering ditemukan regulator mekanik pada kendaraan yang dibuang soketnya. Namun bukan berarti cara diatas adalah hal baku yang wajib diikuti, cara diatas jelas tidak sesuai dengan SOP (standar operasional prosedur). Cara diatas hanya untuk memudahkan saat bekerja saja. Jika anda telah memiliki cara sendiri yang lebih cepat maka tidak usah mengikuti cara-cara diatas. Semoga artikel diatas bermanfaat dan dapat mempercepat pekerjaan anda. Selamat bekerja dan ingat! Selalu gunakan alat keselamatan kerja pada saat bekerja... Salam hangat dari Ciamis, Jawa Barat, Indonesia...","title":"Kesimpulan"},{"location":"ototronik/mil-pgmfi/","text":"Kedipan MIL Honda PGM-FI \u00b6 Malfunction Indicator Light atau disingkat MIL adalah lampu indikator dasbor yang berfungsi untuk memberitahu kepada pengguna atau mekanik tentang keadaan sepeda motor. MIL juga dikenal dengan istilah lain yaitu CEL atau Check Engine Lamp . Kedipan atau blink MIL dengan pola tertentu menunjukan kegagalan fungsi suatu input/sensor dan atau suatu output/aktuator. MIL merupakan bagian tak terpisahkan dari teknologi PGM-FI ( Programmed Fuel Injection ). Sedangkan Engine Control Module atau ECM adalah otak pengendali semua data yang masuk dari sensor, pengolah data, pengatur, hingga pengambil keputusan pada sepeda motor. MIL - DTC PGM-FI Honda \u00b6 Perkembangan teknologi otomotif terutama sepeda motor semakin hari semakin canggih. Kecanggihan ini sebagai konsekwensi untuk menciptakan sepeda motor yang nyaman, irit, ramah lingkungan dan murah baik dari segi harga maupun murah dari segi perawatan. Konsumen pun dimanjakan dengan begitu banyak pilihan merk dan varian sepeda motor, hal ini memudahkan konsumen untuk memilih sepeda motor yang sesuai dengan kebutuhan. Salah satu produsen sepeda motor dunia yang sangat bersemangat untuk memperkenalkan produk buatan mereka adalah perusahaan Honda dibawah bendera PT Astra Honda Motor. Gambar 1. MIL dan DTC PGM-FI Honda memperkenalkan teknologi unggulannya pada hampir semua varian sepeda motor yang mereka buat yaitu teknologi PGM-FI. PGM-FI adalah singkatan dari Programmed Fuel Injection yang merupakan teknologi canggih dengan konsentrasi pada efisiensi penggunaan bahan bakar, sisa pembakaran dan tenaga mesin yang maksimal namun tetap ramah penggunaannya ( user-friendly ). Teknologi PGM-FI mampu menciptakan sepeda motor dengan beberapa keunggulan diantaranya: Efisiensi mesin tinggi Daya mesin tinggi Hemat bahan bakar Gas buang yang ramah lingkungan Teknologi PGM-FI tidak bisa dipungkiri telah menggeser dominasi sistem bahan bakar karburasi yang banyak sekali kelemahan, baik dari sisi jumlah konsumsi bahan bakar hingga kualitas emisi gas buang yang tidak memenuhi standar internasional. Untuk mempelajari tahap demi tahap tentang PGM-FI maka artikel kali ini akan membahas beberapa hal yang merupakan tahap awal pengenalan teknologi PGM-FI. Engine Control Module \u00b6 Seperti sudah menjadi hukum alam bahwa teknologi semakin canggih akan membuat para penggunanya nyaman dan tenang. Namun dibalik semua itu justru menghadirkan tingkat kerumitan tersendiri. Penggunaan teknologi PGM-FI membawa konsekwensi logis yang cukup berat bagi para mekanik sepeda motor. Para mekanik seperti menanggung beban yang sangat berat ketika harus berhadapan dengan teknologi tingkat tinggi sekelas PGM-FI. Hal ini karena teknologi PGM-FI membutuhkan suatu pengendali yang mampu memproses data dari berbagai sensor masukan dan mengambil keputusan untuk memerintahkan pada output aktuator sehingga menghasilkan mesin yang sempurna. Data diproses pada sebuah otak untuk menghasilkan kesimpulan tepat dalam mengendalikan mesin. Pengolah dan pengambil keputusan ini disebut dengan ECM atau Engine Control Module. Gambar 2. Engine Control Module Malfunction Indicator Light \u00b6 PGM-FI dilengkapi dengan sebuah self-diagnosis sytem yaitu suatu sistem yang mampu melakukan diagnosa pada dirinya sendiri ketika ditemukan keadaan yang tidak normal. Self-Diagnosis System terintegrasi didalam ECM. Keadaan yang tidak normal pada sepeda motor ini akan dikirim oleh ECM ke sebuah lampu indikator gangguan yang tersimpan didalam dasbor. Lampu indikator gangguan ini disebut dengan MIL ( Malfunction Indicator Light ) atau CEL ( Check Engine Lamp ). Setiap kunci kontak dihubungkan, ECM akan memeriksa kondisi sepeda motor dan jika ditemukan keadaan tidak normal maka MIL akan berkedip dengan pola tertentu yang kemudian kode kegagalan ini akan disimpan pada sebuah memori yang dapat dihapus. Gambar 3. Simbol MIL pada Dasbor Malfunction Code (Kode Kegagalan) \u00b6 Ketika sepeda motor mengalami masalah maka kode kegagalan fungsi tersebut akan ditunjukan dengan dua cara yang disesuaikan dengan status kegagalan. Kode kegagalan sekarang yaitu kode kegagalan yang akan ditampilkan melalui kedipan MIL pada dasbor ketika ECM mendeteksi suatu persoalan yang terjadi sekarang. MIL akan berkedip dengan pola tertentu sesuai dengan kode kegagalan sekarang, sehingga kita dapat dengan mudah membaca pola kedipannya dan mengetahui kegagalan fungsi pada kendaraan dengan mengacu pada tabel DTC Index . Kode kegagalan tersimpan yaitu kode kegagalan yang tersimpan pada memori. Kegagalan ini tidak akan ditampilkan pada MIL oleh ECM karena kode kegagalan tersebut tidak terjadi sekarang. Kode kegagalan pada masa lalu akan tersimpan didalam memori sehingga kita membutuhkan cara khusus untuk menampilkan kode kegagalan tersebut dan kemudian menghapus kode kegagalan dari memori. Pola Kedipan MIL \u00b6 MIL pada dasbor akan memudahkah pengguna maupun mekanik untuk mendiagnosa keadaan sepeda motor. MIL akan berkedip dengan pola tertentu sesuai dengan kode kegagalan yang terdeteksi oleh ECM. Pada saat kunci kontak diputar pada posisi \"ON\" perhatikan MIL. Gambar 4. Pola Kedipan MIL Jika ECM tidak mendeteksi masalah sekarang maka MIL akan menyala terus beberapa detik dan kemudian mati tanpa terjadi kedipan, namun pada beberapa tipe, MIL justru akan menyala terus ketika tidak terjadi kegagalan fungsi pada sistem PGM-FI. Jika ECM mendeteksi masalah sekarang maka MIL akan menyala terus beberapa detik dan kemudian mati, setelah itu MIL berkedip dengan pola tertentu sesuai dengan kode kegagalannya. MIL memiliki 2 pola kedipan, yaitu kedipan pendek dan kedipan panjang. Kedipan pendek berlangsung selama 0,3 detik. Sedangkan kedipan panjang berlangsung selama 1,3 detik. Satu kedipan panjang sama dengan sepuluh kedipan pendek. Contoh Pola Kedipan MIL \u00b6 Pola Kedipan Normal \u00b6 Setelah Ignition Switch diputar ke posisi \"ON\" MIL akan menyala beberapa saat kemudian mati. Setelah itu MIL tidak menyala lagi. Dari contoh video di atas dapat disimpulkan bahwa ECM tidak mendeteksi kegagalan fungsi saat sekarang. Pola 7 Kedipan \u00b6 Setelah Ignition Switch diputar ke posisi \"ON\" MIL akan menyala beberapa saat kemudian mati. Setelah beberapa saat mati, MIL berkedip pendek sebanyak 7 kali. Setelah 7 kedipan pendek maka MIL akan padam beberapa saat, sekitar 2,8 detik. Kemudian akan berkedip pendek sebanyak 7 kedipan lagi dan seterusnya. Perhatikan video dibawah ini: Dari contoh video diatas dapat disimpulkan sebagai berikut: Hanya ada satu kegagalan fungsi karena MIL berkedip pendek sebanyak 7 kali saja, dan setelah jeda diikuti kedipan yang sama. Jika melihat jumlah kedipan MIL maka kode kegagalannya adalah 7. Jika melihat ke tabel DTC Indeks bahwa kode 7 adalah kegagalan fungsi pada Sensor EOT (Engine Oil Temperature) Pola 12 Kedipan \u00b6 Setelah Ignition Switch diputar ke posisi \"ON\" MIL akan menyala beberapa saat kemudian mati. Setelah beberapa saat mati, MIL berkedip panjang sebanyak 1 kali diikuti 2 kedipan pendek. Setelah itu MIL akan padam beberapa saat, sekitar 2,8 detik. Kemudian akan berkedip panjang sebanyak 1 kali diikuti 2 kedipan pendek lagi dan seterusnya. Perhatikan video dibawah ini: Dari contoh video diatas dapat disimpulkan sebagai berikut: Hanya ada satu kegagalan fungsi karena MIL berkedip panjang sebanyak 1 kali diikuti 2 kedipan pendek saja, dan setelah jeda diikuti kedipan yang sama. Jika melihat jumlah kedipan MIL maka kode kegagalannya adalah 12. Karena satu kedipan panjang ekuivalen dengan 10 kedipan pendek, dan diikuti 2 kedipan pendek. Maka kode menjadi 10 + 2 = 12. Jika melihat ke tabel DTC Indeks bahwa kode 12 adalah kegagalan fungsi pada Injektor. Fail-Safe Function \u00b6 PGM-FI dilengkapi dengan sistem Fail-Safe Function yaitu suatu fungsi yang mampu menjalankan mesin dalam keadaan minimal walaupun ada persoalan pada sistem (ada sensor yang bermasalah walau ditemukan oleh ECM). Jika saat dihidupkan self-diagnosis function pada ECM menemukan masalah pada sistem maka mesin tetap bisa bekerja karena dipelihara oleh sebuah nilai awal ( default ) yang terprogram pada pemetaan program simulasi. Namun, jika self-diagnosis function ternyata mendeteksi kegagalan fungsi pada injektor, sensor CKP, sensor CMP, yang terbaru Ignition Coil maka fail-safe function akan mematikan mesin untuk melindunginya dari kemungkinan kerusakan yang lebih parah. DTC dan MIL Index \u00b6 Dibawah ini adalah tabel indeks DTC yang digunakan sebagai acuan untuk mengambil kesimpulan kode permasalahan sistem PGM-FI yang terdeteksi oleh Self-Diagnosis Function, gejala yang terasa dan nilai awal dari Fail-Safe Function. DTC-MIL Self-Diagnosis Gejala 1 Sensor MAP Mesin beroperasi normal 7 Sensor EOT/ECT Sulit hidup pada suhu rendah 8 Sensor TP Akselerasi mesin buruk 9 Sensor IAT Mesin beroperasi normal 11 Sensor VS Mesin beroperasi normal 12 Injektor Mesin tidak dapat dihidupkan 21 Sensor O 2 Mesin beroperasi normal 29 IACV Mesin mati terus, sulit dihidupkan, putaran stasioner kasar 33 EEPROM Mesin beroperasi normal atau bahkan mesin mati 52 Sensor CKP Mesin tidak dapat dihidupkan 54 Sensor BAS Mesin beroperasi normal atau bahkan mesin mati Referensi \u00b6 PGM-FI Troubleshooting Tips, American Honda Motor Co., Inc. PGM-FI XL700V Service Manual, American Honda Motor Co., Inc. ANF125 Service Manual, American Honda Motor Co., Inc. Buku Pedoman Reparasi CV-Matic, PT Astra Honda Motor MIL Trouble Code Honda, Al Tech","title":"Kedipan MIL Honda PGM-FI"},{"location":"ototronik/mil-pgmfi/#kedipan-mil-honda-pgm-fi","text":"Malfunction Indicator Light atau disingkat MIL adalah lampu indikator dasbor yang berfungsi untuk memberitahu kepada pengguna atau mekanik tentang keadaan sepeda motor. MIL juga dikenal dengan istilah lain yaitu CEL atau Check Engine Lamp . Kedipan atau blink MIL dengan pola tertentu menunjukan kegagalan fungsi suatu input/sensor dan atau suatu output/aktuator. MIL merupakan bagian tak terpisahkan dari teknologi PGM-FI ( Programmed Fuel Injection ). Sedangkan Engine Control Module atau ECM adalah otak pengendali semua data yang masuk dari sensor, pengolah data, pengatur, hingga pengambil keputusan pada sepeda motor.","title":"Kedipan MIL Honda PGM-FI"},{"location":"ototronik/mil-pgmfi/#mil-dtc-pgm-fi-honda","text":"Perkembangan teknologi otomotif terutama sepeda motor semakin hari semakin canggih. Kecanggihan ini sebagai konsekwensi untuk menciptakan sepeda motor yang nyaman, irit, ramah lingkungan dan murah baik dari segi harga maupun murah dari segi perawatan. Konsumen pun dimanjakan dengan begitu banyak pilihan merk dan varian sepeda motor, hal ini memudahkan konsumen untuk memilih sepeda motor yang sesuai dengan kebutuhan. Salah satu produsen sepeda motor dunia yang sangat bersemangat untuk memperkenalkan produk buatan mereka adalah perusahaan Honda dibawah bendera PT Astra Honda Motor. Gambar 1. MIL dan DTC PGM-FI Honda memperkenalkan teknologi unggulannya pada hampir semua varian sepeda motor yang mereka buat yaitu teknologi PGM-FI. PGM-FI adalah singkatan dari Programmed Fuel Injection yang merupakan teknologi canggih dengan konsentrasi pada efisiensi penggunaan bahan bakar, sisa pembakaran dan tenaga mesin yang maksimal namun tetap ramah penggunaannya ( user-friendly ). Teknologi PGM-FI mampu menciptakan sepeda motor dengan beberapa keunggulan diantaranya: Efisiensi mesin tinggi Daya mesin tinggi Hemat bahan bakar Gas buang yang ramah lingkungan Teknologi PGM-FI tidak bisa dipungkiri telah menggeser dominasi sistem bahan bakar karburasi yang banyak sekali kelemahan, baik dari sisi jumlah konsumsi bahan bakar hingga kualitas emisi gas buang yang tidak memenuhi standar internasional. Untuk mempelajari tahap demi tahap tentang PGM-FI maka artikel kali ini akan membahas beberapa hal yang merupakan tahap awal pengenalan teknologi PGM-FI.","title":"MIL - DTC PGM-FI Honda"},{"location":"ototronik/mil-pgmfi/#engine-control-module","text":"Seperti sudah menjadi hukum alam bahwa teknologi semakin canggih akan membuat para penggunanya nyaman dan tenang. Namun dibalik semua itu justru menghadirkan tingkat kerumitan tersendiri. Penggunaan teknologi PGM-FI membawa konsekwensi logis yang cukup berat bagi para mekanik sepeda motor. Para mekanik seperti menanggung beban yang sangat berat ketika harus berhadapan dengan teknologi tingkat tinggi sekelas PGM-FI. Hal ini karena teknologi PGM-FI membutuhkan suatu pengendali yang mampu memproses data dari berbagai sensor masukan dan mengambil keputusan untuk memerintahkan pada output aktuator sehingga menghasilkan mesin yang sempurna. Data diproses pada sebuah otak untuk menghasilkan kesimpulan tepat dalam mengendalikan mesin. Pengolah dan pengambil keputusan ini disebut dengan ECM atau Engine Control Module. Gambar 2. Engine Control Module","title":"Engine Control Module"},{"location":"ototronik/mil-pgmfi/#malfunction-indicator-light","text":"PGM-FI dilengkapi dengan sebuah self-diagnosis sytem yaitu suatu sistem yang mampu melakukan diagnosa pada dirinya sendiri ketika ditemukan keadaan yang tidak normal. Self-Diagnosis System terintegrasi didalam ECM. Keadaan yang tidak normal pada sepeda motor ini akan dikirim oleh ECM ke sebuah lampu indikator gangguan yang tersimpan didalam dasbor. Lampu indikator gangguan ini disebut dengan MIL ( Malfunction Indicator Light ) atau CEL ( Check Engine Lamp ). Setiap kunci kontak dihubungkan, ECM akan memeriksa kondisi sepeda motor dan jika ditemukan keadaan tidak normal maka MIL akan berkedip dengan pola tertentu yang kemudian kode kegagalan ini akan disimpan pada sebuah memori yang dapat dihapus. Gambar 3. Simbol MIL pada Dasbor","title":"Malfunction Indicator Light"},{"location":"ototronik/mil-pgmfi/#malfunction-code-kode-kegagalan","text":"Ketika sepeda motor mengalami masalah maka kode kegagalan fungsi tersebut akan ditunjukan dengan dua cara yang disesuaikan dengan status kegagalan. Kode kegagalan sekarang yaitu kode kegagalan yang akan ditampilkan melalui kedipan MIL pada dasbor ketika ECM mendeteksi suatu persoalan yang terjadi sekarang. MIL akan berkedip dengan pola tertentu sesuai dengan kode kegagalan sekarang, sehingga kita dapat dengan mudah membaca pola kedipannya dan mengetahui kegagalan fungsi pada kendaraan dengan mengacu pada tabel DTC Index . Kode kegagalan tersimpan yaitu kode kegagalan yang tersimpan pada memori. Kegagalan ini tidak akan ditampilkan pada MIL oleh ECM karena kode kegagalan tersebut tidak terjadi sekarang. Kode kegagalan pada masa lalu akan tersimpan didalam memori sehingga kita membutuhkan cara khusus untuk menampilkan kode kegagalan tersebut dan kemudian menghapus kode kegagalan dari memori.","title":"Malfunction Code (Kode Kegagalan)"},{"location":"ototronik/mil-pgmfi/#pola-kedipan-mil","text":"MIL pada dasbor akan memudahkah pengguna maupun mekanik untuk mendiagnosa keadaan sepeda motor. MIL akan berkedip dengan pola tertentu sesuai dengan kode kegagalan yang terdeteksi oleh ECM. Pada saat kunci kontak diputar pada posisi \"ON\" perhatikan MIL. Gambar 4. Pola Kedipan MIL Jika ECM tidak mendeteksi masalah sekarang maka MIL akan menyala terus beberapa detik dan kemudian mati tanpa terjadi kedipan, namun pada beberapa tipe, MIL justru akan menyala terus ketika tidak terjadi kegagalan fungsi pada sistem PGM-FI. Jika ECM mendeteksi masalah sekarang maka MIL akan menyala terus beberapa detik dan kemudian mati, setelah itu MIL berkedip dengan pola tertentu sesuai dengan kode kegagalannya. MIL memiliki 2 pola kedipan, yaitu kedipan pendek dan kedipan panjang. Kedipan pendek berlangsung selama 0,3 detik. Sedangkan kedipan panjang berlangsung selama 1,3 detik. Satu kedipan panjang sama dengan sepuluh kedipan pendek.","title":"Pola Kedipan MIL"},{"location":"ototronik/mil-pgmfi/#contoh-pola-kedipan-mil","text":"","title":"Contoh Pola Kedipan MIL"},{"location":"ototronik/mil-pgmfi/#pola-kedipan-normal","text":"Setelah Ignition Switch diputar ke posisi \"ON\" MIL akan menyala beberapa saat kemudian mati. Setelah itu MIL tidak menyala lagi. Dari contoh video di atas dapat disimpulkan bahwa ECM tidak mendeteksi kegagalan fungsi saat sekarang.","title":"Pola Kedipan Normal"},{"location":"ototronik/mil-pgmfi/#pola-7-kedipan","text":"Setelah Ignition Switch diputar ke posisi \"ON\" MIL akan menyala beberapa saat kemudian mati. Setelah beberapa saat mati, MIL berkedip pendek sebanyak 7 kali. Setelah 7 kedipan pendek maka MIL akan padam beberapa saat, sekitar 2,8 detik. Kemudian akan berkedip pendek sebanyak 7 kedipan lagi dan seterusnya. Perhatikan video dibawah ini: Dari contoh video diatas dapat disimpulkan sebagai berikut: Hanya ada satu kegagalan fungsi karena MIL berkedip pendek sebanyak 7 kali saja, dan setelah jeda diikuti kedipan yang sama. Jika melihat jumlah kedipan MIL maka kode kegagalannya adalah 7. Jika melihat ke tabel DTC Indeks bahwa kode 7 adalah kegagalan fungsi pada Sensor EOT (Engine Oil Temperature)","title":"Pola 7 Kedipan"},{"location":"ototronik/mil-pgmfi/#pola-12-kedipan","text":"Setelah Ignition Switch diputar ke posisi \"ON\" MIL akan menyala beberapa saat kemudian mati. Setelah beberapa saat mati, MIL berkedip panjang sebanyak 1 kali diikuti 2 kedipan pendek. Setelah itu MIL akan padam beberapa saat, sekitar 2,8 detik. Kemudian akan berkedip panjang sebanyak 1 kali diikuti 2 kedipan pendek lagi dan seterusnya. Perhatikan video dibawah ini: Dari contoh video diatas dapat disimpulkan sebagai berikut: Hanya ada satu kegagalan fungsi karena MIL berkedip panjang sebanyak 1 kali diikuti 2 kedipan pendek saja, dan setelah jeda diikuti kedipan yang sama. Jika melihat jumlah kedipan MIL maka kode kegagalannya adalah 12. Karena satu kedipan panjang ekuivalen dengan 10 kedipan pendek, dan diikuti 2 kedipan pendek. Maka kode menjadi 10 + 2 = 12. Jika melihat ke tabel DTC Indeks bahwa kode 12 adalah kegagalan fungsi pada Injektor.","title":"Pola 12 Kedipan"},{"location":"ototronik/mil-pgmfi/#fail-safe-function","text":"PGM-FI dilengkapi dengan sistem Fail-Safe Function yaitu suatu fungsi yang mampu menjalankan mesin dalam keadaan minimal walaupun ada persoalan pada sistem (ada sensor yang bermasalah walau ditemukan oleh ECM). Jika saat dihidupkan self-diagnosis function pada ECM menemukan masalah pada sistem maka mesin tetap bisa bekerja karena dipelihara oleh sebuah nilai awal ( default ) yang terprogram pada pemetaan program simulasi. Namun, jika self-diagnosis function ternyata mendeteksi kegagalan fungsi pada injektor, sensor CKP, sensor CMP, yang terbaru Ignition Coil maka fail-safe function akan mematikan mesin untuk melindunginya dari kemungkinan kerusakan yang lebih parah.","title":"Fail-Safe Function"},{"location":"ototronik/mil-pgmfi/#dtc-dan-mil-index","text":"Dibawah ini adalah tabel indeks DTC yang digunakan sebagai acuan untuk mengambil kesimpulan kode permasalahan sistem PGM-FI yang terdeteksi oleh Self-Diagnosis Function, gejala yang terasa dan nilai awal dari Fail-Safe Function. DTC-MIL Self-Diagnosis Gejala 1 Sensor MAP Mesin beroperasi normal 7 Sensor EOT/ECT Sulit hidup pada suhu rendah 8 Sensor TP Akselerasi mesin buruk 9 Sensor IAT Mesin beroperasi normal 11 Sensor VS Mesin beroperasi normal 12 Injektor Mesin tidak dapat dihidupkan 21 Sensor O 2 Mesin beroperasi normal 29 IACV Mesin mati terus, sulit dihidupkan, putaran stasioner kasar 33 EEPROM Mesin beroperasi normal atau bahkan mesin mati 52 Sensor CKP Mesin tidak dapat dihidupkan 54 Sensor BAS Mesin beroperasi normal atau bahkan mesin mati","title":"DTC dan MIL Index"},{"location":"ototronik/mil-pgmfi/#referensi","text":"PGM-FI Troubleshooting Tips, American Honda Motor Co., Inc. PGM-FI XL700V Service Manual, American Honda Motor Co., Inc. ANF125 Service Manual, American Honda Motor Co., Inc. Buku Pedoman Reparasi CV-Matic, PT Astra Honda Motor MIL Trouble Code Honda, Al Tech","title":"Referensi"},{"location":"ototronik/pendahuluan-ototronik/","text":"Engine Management System (EMS) \u00b6 Gasoline Engine atau mesin bensin merupakan salah satu mesin yang menghasilkan tenaga dari hasil pembakaran campuran udara dan bahan bakar. Proses pembakaran campuran udara dan bahan bakar terjadi didalam ruang pembakaran ( Combustion Chamber ) sehingga dikenal juga sebagai mesin pembakaran dalam ( Internal Combustion Engine ). Besarnya tenaga yang dihasilkan tergantung beberapa faktor, yaitu: Kualitas campuran udara dan bahan bakar Campuran udara dan bahar bakar yang homogen Perbandingan campuran yang ideal yaitu 1 : 14,7 (1 bagian bahan bakar dan 14,7 bagian udara) Kualitas percikan bunga api Menghasilkan cukup tenaga listrik, sekitar 3 miliJoule Waktu penyalaan (percikan bunga api busi) yang tepat Kualitas kompresi Perbandingan kompresi yang ideal, yaitu 8 - 12 Tekanan kompresi yang ideal, yaitu 10 - 16 bar Tekanan pembakaran yang maksimal, yaitu 40 - 60 bar","title":"Pendahuluan"},{"location":"ototronik/pendahuluan-ototronik/#engine-management-system-ems","text":"Gasoline Engine atau mesin bensin merupakan salah satu mesin yang menghasilkan tenaga dari hasil pembakaran campuran udara dan bahan bakar. Proses pembakaran campuran udara dan bahan bakar terjadi didalam ruang pembakaran ( Combustion Chamber ) sehingga dikenal juga sebagai mesin pembakaran dalam ( Internal Combustion Engine ). Besarnya tenaga yang dihasilkan tergantung beberapa faktor, yaitu: Kualitas campuran udara dan bahan bakar Campuran udara dan bahar bakar yang homogen Perbandingan campuran yang ideal yaitu 1 : 14,7 (1 bagian bahan bakar dan 14,7 bagian udara) Kualitas percikan bunga api Menghasilkan cukup tenaga listrik, sekitar 3 miliJoule Waktu penyalaan (percikan bunga api busi) yang tepat Kualitas kompresi Perbandingan kompresi yang ideal, yaitu 8 - 12 Tekanan kompresi yang ideal, yaitu 10 - 16 bar Tekanan pembakaran yang maksimal, yaitu 40 - 60 bar","title":"Engine Management System (EMS)"},{"location":"ototronik/prinsip-regulator-mekanik/","text":"Prinsip Kerja Regulator Mekanik - Alternator \u00b6 Sistem Pengisian atau Charging System pada mobil sangat berperan penting, selain berfungsi untuk mengisi kembali baterai setelah digunakan oleh beberapa komponen kelistrikan juga berfungsi untuk mengambil alih fungsi baterai pada saat mesin mencapai kecepatan tertentu. Namun, alternator tidak konstan dalam menghasilkan tegangan, karena besarnya tegangan yang dihasilkan alternator terpengaruhi oleh kecepatan putaran mesin. Semakin cepat putaran mesin, semakin besar tegangan yang dihasilkan dan demikian sebaliknya. Selain itu, besar kecilnya tegangan/arus yang dihasilkan oleh alternator berpengaruh terhadap proses pengisian baterai. Jangan sampai baterai kehabisan muatan karena alternator tidak mampu mengisi dengan sempurna. Regulator Alternator \u00b6 Banyak faktor yang mempengaruhi kestabilan alternator dalam menghasilkan energi listrik, salah satunya adalah regulator. Regulator berperan mengatur besar kecilnya energi listrik yang dihasilkan oleh alternator melalui pengaturan besar kecilnya tegangan dari baterai yang masuk kedalam rotor. Ada dua jenis Regulator yang terdapat pada mobil yaitu Regulator Mekanik ( Mechanical Regulator ) dan Regulator Elektronik ( Electronic Regulator atau IC Regulator ), namun pada artikel ini hanya akan dibahas tentang Regulator Mekanik. Secara umum regulator memang digunakan untuk mengatur kestabilan tegangan yang dihasilkan oleh alternator, namun secara spesifik, regulator mengatur kekuatan medan magnet yang dihasilkan oleh rotor. Ketika putaran mesin tinggi maka regulator menurunkan tegangan yang masuk kedalam rotor, sehingga kekuatan kemagnetan rotor menurun. Ketika putaran mesin rendah, regulator memberikan tegangan penuh kedalam rotor, sehingga kekuatan kemagnetan rotor besar. Bagaimana regulator mengatur besar kecilnya tegangan dari baterai yang masuk kedalam rotor? 1. Mesin Mati \u00b6 Perhatikan Gambar 1. Pada saat mesin mati dan kunci kontak OFF, titik kontak (contact point) A berhubungan dengan titik kontak B pada Voltage Relay. Sedangkah pada Voltage Regulator, titik kontak 1 berhubungan dengan titik kontak 2. Tegangan belum mengalir ke Regulator, namun pada terminal B Alternator terdapat tegangan yang berasal dari Baterai. Tegangan dari baterai hanya sampai pada terminal B karena tertahan oleh Diode. Saat keadaan seperti ini Diode Rectifier berfungsi untuk melindungi lilitan stator (Stator Coil) terhadap arus balik yang berasal dari Baterai. Hal ini karena Diode adalah pintu satu arah yang hanya bisa mengalirkan salah satu jenis tegangan. Makanya, apabila terjadi kerusakan pada Diode (terutama short circuit) baterai akan cepat habis karena tegangan masuk kedalam lilitan stator, bahkan dalam kondisi tertentu bisa saja lilitan stator terbakar, namun kejadian terbakarnya lilitan stator jarang sekali terjadi. Gambar 1. Mesin Mati dan Kunci Kontak OFF 2. Mesin Mati Kunci Kontak ON \u00b6 Perhatikan Gambar 2. Pada saat mesin belum dihidupkan dan kunci kontak di putar ke posisi ON, maka tegangan mengalir dari baterai menuju kunci kontak dan mengalir melewati 2 fuse (sekring). 1 fuse digunakan sebagai pengaman terminal IG dan 1 fuse lagi digunakan sebagai pengaman terminal L. Gambar 2. Mesin Mati Kunci Kontak ON Arus mengalir melalui dua saluran yaitu: A. Arus ke Lampu CHG (Charger Warning Lamp) \u00b6 Terminal (+) Baterai \u2192 Fusible Link \u2192 Kunci Kontak (Ignition Switch) \u2192 Fuse \u2192 Lampu CHG \u2192 Terminal L \u2192 Titik Kontak B \u2192 Titik Kontak A \u2192 Terminal E Regulator \u2192 Massa Bodi Maka Lampu CHG ( Charger Warning Lamp ) menyala yang menandakan bahwa alternator belum menghasilkan tegangan. Jika saat kita berkendara dan tiba-tiba lampu CHG menyala, segera perbaiki karena lampu CHG yang menyala menandakan alterator tidak menghasilkan tegangan. Jika terus digunakan maka muatan baterai akan habis dan mesin pun berhenti bekerja. B. Arus ke Rotor Coil \u00b6 Terminal (+) Baterai \u2192 Fusible Link \u2192 Kunci Kontak (Ignition Switch) \u2192 Fuse \u2192 Terminal IG \u2192 Titik Kontak 1 \u2192 Titik Kontak 2 \u2192 Terminal F Regulator \u2192 Terminal F Alternator \u2192 Brush \u2192 Slip Ring \u2192 Rotor Coil \u2192 Slip Ring \u2192 Brush \u2192 Terminal E Alternator \u2192 Massa Bodi Maka pada Rotor Coil akan terbentuk medan magnet. Kemagnetan yang terbentuk pada lilitan rotor masih besar karena titik kontak 1 masih berhubungan langsung dengan titik kontak 2. Sampai disini alternator belum menghasilkan tegangan karena kemagnetan yang terbentuk pada lilitan rotor belum diputar oleh mesin sehingga belum terjadi induksi pada lilitan stator. 3. Mesin Hidup Putaran Idle \u00b6 Perhatikan Gambar 3. Pada saat mesin hidup, maka lilitan rotor sebagai medan magnet berputar diantara lilitan stator. Pada lilitan stator terjadi induksi sehingga dari setiap ujung-ujung lilitan stator menghasilkan GGL (Gaya Gerak Listrik atau Electromotive Force). Arus yang dihasilkan dari 3 ujung lilitan stator kemudian di searahkan (arus diubah dari AC menjadi DC) oleh diode rectifier dan keluar melalui terminal B. Arus dari terminal B inilah yang kemudian digunakan untuk mengisi baterai atau digunakan secara langsung oleh Load (beban kelistrikan kendaraan). Gambar 3. Mesin Hidup Putaran Idle Perhatikan aliran tegangan dari Alternator berikut ini: A. Tegangan Netral \u00b6 Tegangan netral adalah tegangan yang bernilai setengah jika diambil dari dari setiap 3 ujung lilitan stator. Tegangan ini hanya digunakan untuk mengisi lilitan voltage relay pada regulator. Perhatikan aliran tegangan dibawah ini: Terminal N Alternator \u2192 Terminal N Regulator \u2192 Voltage Relay \u2192 Massa Bodi Maka pada lilitan voltage relay akan terbentuk kemagnetan. Kemagnetan yang terbentuk pada lilitan voltage relay digunakan untuk menarik titik kontak B. Sehingga titik kontak B terlepas dari titik kontak A dan kemudian berhubungan dengan titik kontak C. Ketika titik kontak B terlepas dari titik kontak A maka Lampu CHG (dari terminal L) akan kehilangan massa bodi, hal ini menyebabkan lampu CHG padam. Sedangkan titik kontak B berhubungan dengan titik kontak C yang berasal dari terminal B alternator. Tegangan yang berasal terminal B regulator kemudian masuk ke dalam lilitan voltage regulator maka pada lilitan voltage regulator terbentuk kemagnetan. Tegangan dari B alternator yang mengisi kedalam lilitan voltage regulator mengalami perubahan sesuai dengan putaran mesin, sehingga sifat kemagnetan yang terbentuk pada lilitan voltage relay pun akan berubah. Sampai disinilah voltage relay bekerja. Voltage relay akan tetap dalam kondisi seperti ini selama mesin berjalan, baik dalam putaran idle, putaran menengah, hingga putaran tinggi. Sehingga dalam penjelasan berikutnya, voltage relay tidak akan dibahas lagi. Sederhananya, voltage relay digunakan untuk mengatur menyala dan padamnya lampu CHG, serta mengaktifkan kemagnetan didalam lilitan voltage regulator dengan cara menghubungan ujung lilitan voltage regulator dengan terminal B yang berasal dari alternator. B. Tegangan Yang Keluar (Output Voltage) \u00b6 Ketika terjadi induksi pada lilitan stator maka pada setiap ujung lilitan stator menghasilkan arus begitupun pada terminal N (Netral). 3 ujung lilitan stator menghasilkan arus dengan jenis arus AC, dan kemudian disearahkan oleh diode rectifier. Dari setiap 3 buah diode rectifier disatukan dalam satu ujung, ujung keluaran yang menuju ke terminal B dan ujung keluaran yang menuju ke terminal E. Terminal E kemudian disatukan dengan massa bodi kendaraan, sedangkan terminal B kemudian dialirkan menuju ke dua saluran, yaitu: 1. Ke Baterai \u00b6 Lilitan Stator \u2192 Diode Rectifier \u2192 Terminal B Alternator \u2192 Terminal (+) Baterai Maka terjadi proses pengisian (charge) pada baterai. (Mengenai proses elektrolisa pengisian pada baterai akan dibahas pada artikel terpisah) 2. Ke Regulator \u00b6 Lilitan Stator \u2192 Diode Rectifier \u2192 Terminal B Alternator \u2192 Terminal B Regulator \u2192 Voltage Regulator (melalui pertemuan titik kontak B dengan titik kontak C) \u2192 Terminal E Regulator \u2192 Massa Bodi Lilitan Voltage Regulator mendapat tegangan dari terminal B alternator maka terbentuk kemagnetan pada lilitan. Namun sifat kemagnetan lilitan voltage regulator belum mampu menarik titik kontak 2 untuk terlepas dari titik kontak 1, hal ini karena mesin masih berputar lambat (idle). 4. Putaran Idle ke Putaran Menengah \u00b6 Perhatikan Gambar 4. Dari mulai putaran idle, putaran menengah hingga ke putaran tinggi, bahasan terkonsentrasi pada voltage regulator. Tegangan yang dikeluarkan alternator melalui terminal B kemudian masuk kedalam regulator melalui terimal B regulator dan mengisi lilitan voltage regulator. Arus medan (field current) yang ke rotor dikontrol dan disesuaikan dengan tegangan yang dikeluarkan terminal B yang beraksi pada voltage regulator. Pengaturan besar arus medan (untuk pembentukan magnet) yang masuk ke dalam rotor diatur dengan arus yang melewati resistor (R) atau langsung tanpa melewati resistor. Arus akan melewati resistor atau tidak melewati resistor tergantung posisi titik kontak 2. Gambar 4. Putaran Idle ke Putaran Menengah Arus Yang Ke Rotor Coil \u00b6 Terminal B Alternator \u2192 Ignition Switch \u2192 Fuse \u2192 Terminal IG Regulator \u2192 Titik Kontak 1 \u2192 Titik Kontak 2 \u2192 Resistor \u2192 Terminal F Regulator \u2192 Terminal F Alternator \u2192 Rotor Coil \u2192 Terminal E Alternator \u2192 Massa Bodi Dalam hal ini arus yang akan masuk kedalam rotor coil bisa melalui 2 saluran yang saling bergantian, yaitu: Bila kemagnetan yang terbentuk didalam Voltage Regulator besar, akan mampu menarik titik kontak 2 terlepas dari titik kontak 1, maka arus yang akan ke rotor coil harus melewati resistor (R). Akibatnya arus yang mengalir menuju ke rotor coil akan mengecil (berkurang karena terhambat resistor) dan kemagnetan yang ditimbulkan rotor coil pun mengecil (berkurang). Sedangkan jika kemagnetan pada voltage regulator lemah, titik kontak 2 tidak akan tertarik dari titik kontak 1, maka arus yang akan ke rotor coil tidak akan melewati resitor karena titik kontak 2 berhubungan dengan titik kontak 1, sehingga kemagnetan pada rotor coil akan normal kembali. Pergantian saluran ini terus berlangsung jika mesin berputar dalam putaran idle ke menengah atau mesin bertahan pada putaran menengah. 5. Putaran Menengah ke Putaran Tinggi \u00b6 Perhatikan Gambar 5. Jika putaran mesin bertambah maka arus yang dihasilkan oleh stator coil pun akan bertambah, dan sifat kemagnetan pada voltage regulator menjadi lebih kuat. Dengan sifat kemagnetan yang lebih kuat pada voltage regulator membuat arus medan yang ke rotor coil akan mengalir terputus-putus (intermittenly). Hal ini terjadi karena titik kontak 2 dari voltage regulator kadang-kadang berhubungan dengan titik kontak 3 (yang menuju ke massa bodi). Walaupun titik kontak 2 kadang berhubungan dengan titik kontak 3 pada voltage regulator, namun titik kontak B pada voltage relay tidak akan terlepas dari titik kontak C, karena tegangan N (Netral) terpelihara dalam sisa flux dari rotor. Gambar 5. Putaran Menengah ke Putaran Tinggi Pembatasan dan Kehilangan Arus Medan \u00b6 Pada saat mesin mencapai putaran tinggi, maka arus yang akan masuk kedalam rotor coil sebagian akan dibuang untuk membatasi arus medan. Dalam hal ini arus yang akan masuk kedalam rotor coil bisa saja dialirkan dan atau dibuang. Proses pengaliran dan pembuangan arus medan terjadi secara bergantian, dengan rincian aliran sebagai berikut: 1. Pembatasan Arus Medan \u00b6 Pembatasan arus medan dilakukan oleh Resistor, hal ini terjadi karena titik kontak 2 tertarik oleh kemagnetan yang cukup besar dari voltage regulator seiring dengan pertambahan putaran mesin, hingga terlepas dari titik kontak 1. Namun titik kontak 2 belum berhubungan dengan titik kontak 3 (titik kontak 2 mengambang diantara titik kontak 1 dan titik kontak 3). Arus yang berasal dari terminal IG regulator menuju rotor coil akan tertahan oleh Resistor. Perhatikan aliran arus medan dibawah ini: Terminal B Alternator \u2192 Ignition Switch \u2192 Fuse \u2192 Terminal IG Regulator \u2192 Resistor (R) \u2192 Terminal F Regulator \u2192 Terminal F Alternator \u2192 Rotor Coil \u2192 Terminal E Alternator \u2192 Massa Bodi 2. Pembuangan Arus Medan \u00b6 Pada saat arus yang dihasilkan terminal B alternator bertambah lebih besar lagi seiring dengan pertambahan putaran mesin, maka sifat kemagnetan pada voltage regulator semakin kuat, hingga mampu menarik titik kontak 2 berhubungan titik kontak 3. Saat titik kontak 2 berhubungan dengan titik kontak 3 maka arus yang melewati Resistor akan dibuang ke massa bodi tanpa dialirkan kedalam rotor coil. Perhatikan aliran arus medan dibawah ini: Terminal B Alternator \u2192 Ignition Switch \u2192 Fuse \u2192 Terminal IG Regulator \u2192 Resistor (R) \u2192 Titik Kontak 2 \u2192 Titik Kontak 3 \u2192 Terminal E Regulator \u2192 Massa Bodi Ketika arus medan rotor ini dibuang ke massa, maka hilang kemagnetan pada rotor coil. Ketika kemagnetan menghilang maka tegangan yang dihasilkan stator coil akan turun drastis, ketika terjadi penurunan tegangan maka sifat kemagnetan pada voltage regulator akan menghilang. Kehilangan sifat kemagnetan membuat kontak 2 akan kembali ke posisi semula (ke kontak 1), namun baru saja lepas dari kontak 3, tegangan sudah dihasilkan lagi oleh stator coil. Ketika putaran mesin tinggi, kejadian putus sambung antara kontak 2 dengan kontak 3 terus berlangsung. Hal ini tentu akan menjaga kenaikan/lonjakan tegangan listrik dari stator coil yang melebihi kemampuan sistem kelistrikan. Kesimpulan \u00b6 Pada dasarnya regulator apapun jenisnya, baik mekanik maupun elektronik mempunya tugas untuk membatasi, menjaga, menstabilkan tegangan listrik yang dihasilkan oleh generator listrik. Hal ini karena kemampuan baterai dan komponen kelistrikan otomotif lainnya telah dibatasi kemampuannya dalam menerima tegangan listrik. Secara umum, kemampuan baterai dan komponen sistem kelistrikan otomotif hanya mampu menerima tegangan maksimal sebesar 15 Volt. Salam hangat dari Banjarsari - Ciamis - Jawa Barat - Indonesia - Bumi - Galaksi Bima Sakti...","title":"Prinsip Regulator Mekanik"},{"location":"ototronik/prinsip-regulator-mekanik/#prinsip-kerja-regulator-mekanik-alternator","text":"Sistem Pengisian atau Charging System pada mobil sangat berperan penting, selain berfungsi untuk mengisi kembali baterai setelah digunakan oleh beberapa komponen kelistrikan juga berfungsi untuk mengambil alih fungsi baterai pada saat mesin mencapai kecepatan tertentu. Namun, alternator tidak konstan dalam menghasilkan tegangan, karena besarnya tegangan yang dihasilkan alternator terpengaruhi oleh kecepatan putaran mesin. Semakin cepat putaran mesin, semakin besar tegangan yang dihasilkan dan demikian sebaliknya. Selain itu, besar kecilnya tegangan/arus yang dihasilkan oleh alternator berpengaruh terhadap proses pengisian baterai. Jangan sampai baterai kehabisan muatan karena alternator tidak mampu mengisi dengan sempurna.","title":"Prinsip Kerja Regulator Mekanik - Alternator"},{"location":"ototronik/prinsip-regulator-mekanik/#regulator-alternator","text":"Banyak faktor yang mempengaruhi kestabilan alternator dalam menghasilkan energi listrik, salah satunya adalah regulator. Regulator berperan mengatur besar kecilnya energi listrik yang dihasilkan oleh alternator melalui pengaturan besar kecilnya tegangan dari baterai yang masuk kedalam rotor. Ada dua jenis Regulator yang terdapat pada mobil yaitu Regulator Mekanik ( Mechanical Regulator ) dan Regulator Elektronik ( Electronic Regulator atau IC Regulator ), namun pada artikel ini hanya akan dibahas tentang Regulator Mekanik. Secara umum regulator memang digunakan untuk mengatur kestabilan tegangan yang dihasilkan oleh alternator, namun secara spesifik, regulator mengatur kekuatan medan magnet yang dihasilkan oleh rotor. Ketika putaran mesin tinggi maka regulator menurunkan tegangan yang masuk kedalam rotor, sehingga kekuatan kemagnetan rotor menurun. Ketika putaran mesin rendah, regulator memberikan tegangan penuh kedalam rotor, sehingga kekuatan kemagnetan rotor besar. Bagaimana regulator mengatur besar kecilnya tegangan dari baterai yang masuk kedalam rotor?","title":"Regulator Alternator"},{"location":"ototronik/prinsip-regulator-mekanik/#1-mesin-mati","text":"Perhatikan Gambar 1. Pada saat mesin mati dan kunci kontak OFF, titik kontak (contact point) A berhubungan dengan titik kontak B pada Voltage Relay. Sedangkah pada Voltage Regulator, titik kontak 1 berhubungan dengan titik kontak 2. Tegangan belum mengalir ke Regulator, namun pada terminal B Alternator terdapat tegangan yang berasal dari Baterai. Tegangan dari baterai hanya sampai pada terminal B karena tertahan oleh Diode. Saat keadaan seperti ini Diode Rectifier berfungsi untuk melindungi lilitan stator (Stator Coil) terhadap arus balik yang berasal dari Baterai. Hal ini karena Diode adalah pintu satu arah yang hanya bisa mengalirkan salah satu jenis tegangan. Makanya, apabila terjadi kerusakan pada Diode (terutama short circuit) baterai akan cepat habis karena tegangan masuk kedalam lilitan stator, bahkan dalam kondisi tertentu bisa saja lilitan stator terbakar, namun kejadian terbakarnya lilitan stator jarang sekali terjadi. Gambar 1. Mesin Mati dan Kunci Kontak OFF","title":"1. Mesin Mati"},{"location":"ototronik/prinsip-regulator-mekanik/#2-mesin-mati-kunci-kontak-on","text":"Perhatikan Gambar 2. Pada saat mesin belum dihidupkan dan kunci kontak di putar ke posisi ON, maka tegangan mengalir dari baterai menuju kunci kontak dan mengalir melewati 2 fuse (sekring). 1 fuse digunakan sebagai pengaman terminal IG dan 1 fuse lagi digunakan sebagai pengaman terminal L. Gambar 2. Mesin Mati Kunci Kontak ON Arus mengalir melalui dua saluran yaitu:","title":"2. Mesin Mati Kunci Kontak ON"},{"location":"ototronik/prinsip-regulator-mekanik/#a-arus-ke-lampu-chg-charger-warning-lamp","text":"Terminal (+) Baterai \u2192 Fusible Link \u2192 Kunci Kontak (Ignition Switch) \u2192 Fuse \u2192 Lampu CHG \u2192 Terminal L \u2192 Titik Kontak B \u2192 Titik Kontak A \u2192 Terminal E Regulator \u2192 Massa Bodi Maka Lampu CHG ( Charger Warning Lamp ) menyala yang menandakan bahwa alternator belum menghasilkan tegangan. Jika saat kita berkendara dan tiba-tiba lampu CHG menyala, segera perbaiki karena lampu CHG yang menyala menandakan alterator tidak menghasilkan tegangan. Jika terus digunakan maka muatan baterai akan habis dan mesin pun berhenti bekerja.","title":"A. Arus ke Lampu CHG (Charger Warning Lamp)"},{"location":"ototronik/prinsip-regulator-mekanik/#b-arus-ke-rotor-coil","text":"Terminal (+) Baterai \u2192 Fusible Link \u2192 Kunci Kontak (Ignition Switch) \u2192 Fuse \u2192 Terminal IG \u2192 Titik Kontak 1 \u2192 Titik Kontak 2 \u2192 Terminal F Regulator \u2192 Terminal F Alternator \u2192 Brush \u2192 Slip Ring \u2192 Rotor Coil \u2192 Slip Ring \u2192 Brush \u2192 Terminal E Alternator \u2192 Massa Bodi Maka pada Rotor Coil akan terbentuk medan magnet. Kemagnetan yang terbentuk pada lilitan rotor masih besar karena titik kontak 1 masih berhubungan langsung dengan titik kontak 2. Sampai disini alternator belum menghasilkan tegangan karena kemagnetan yang terbentuk pada lilitan rotor belum diputar oleh mesin sehingga belum terjadi induksi pada lilitan stator.","title":"B. Arus ke Rotor Coil"},{"location":"ototronik/prinsip-regulator-mekanik/#3-mesin-hidup-putaran-idle","text":"Perhatikan Gambar 3. Pada saat mesin hidup, maka lilitan rotor sebagai medan magnet berputar diantara lilitan stator. Pada lilitan stator terjadi induksi sehingga dari setiap ujung-ujung lilitan stator menghasilkan GGL (Gaya Gerak Listrik atau Electromotive Force). Arus yang dihasilkan dari 3 ujung lilitan stator kemudian di searahkan (arus diubah dari AC menjadi DC) oleh diode rectifier dan keluar melalui terminal B. Arus dari terminal B inilah yang kemudian digunakan untuk mengisi baterai atau digunakan secara langsung oleh Load (beban kelistrikan kendaraan). Gambar 3. Mesin Hidup Putaran Idle Perhatikan aliran tegangan dari Alternator berikut ini:","title":"3. Mesin Hidup Putaran Idle"},{"location":"ototronik/prinsip-regulator-mekanik/#a-tegangan-netral","text":"Tegangan netral adalah tegangan yang bernilai setengah jika diambil dari dari setiap 3 ujung lilitan stator. Tegangan ini hanya digunakan untuk mengisi lilitan voltage relay pada regulator. Perhatikan aliran tegangan dibawah ini: Terminal N Alternator \u2192 Terminal N Regulator \u2192 Voltage Relay \u2192 Massa Bodi Maka pada lilitan voltage relay akan terbentuk kemagnetan. Kemagnetan yang terbentuk pada lilitan voltage relay digunakan untuk menarik titik kontak B. Sehingga titik kontak B terlepas dari titik kontak A dan kemudian berhubungan dengan titik kontak C. Ketika titik kontak B terlepas dari titik kontak A maka Lampu CHG (dari terminal L) akan kehilangan massa bodi, hal ini menyebabkan lampu CHG padam. Sedangkan titik kontak B berhubungan dengan titik kontak C yang berasal dari terminal B alternator. Tegangan yang berasal terminal B regulator kemudian masuk ke dalam lilitan voltage regulator maka pada lilitan voltage regulator terbentuk kemagnetan. Tegangan dari B alternator yang mengisi kedalam lilitan voltage regulator mengalami perubahan sesuai dengan putaran mesin, sehingga sifat kemagnetan yang terbentuk pada lilitan voltage relay pun akan berubah. Sampai disinilah voltage relay bekerja. Voltage relay akan tetap dalam kondisi seperti ini selama mesin berjalan, baik dalam putaran idle, putaran menengah, hingga putaran tinggi. Sehingga dalam penjelasan berikutnya, voltage relay tidak akan dibahas lagi. Sederhananya, voltage relay digunakan untuk mengatur menyala dan padamnya lampu CHG, serta mengaktifkan kemagnetan didalam lilitan voltage regulator dengan cara menghubungan ujung lilitan voltage regulator dengan terminal B yang berasal dari alternator.","title":"A. Tegangan Netral"},{"location":"ototronik/prinsip-regulator-mekanik/#b-tegangan-yang-keluar-output-voltage","text":"Ketika terjadi induksi pada lilitan stator maka pada setiap ujung lilitan stator menghasilkan arus begitupun pada terminal N (Netral). 3 ujung lilitan stator menghasilkan arus dengan jenis arus AC, dan kemudian disearahkan oleh diode rectifier. Dari setiap 3 buah diode rectifier disatukan dalam satu ujung, ujung keluaran yang menuju ke terminal B dan ujung keluaran yang menuju ke terminal E. Terminal E kemudian disatukan dengan massa bodi kendaraan, sedangkan terminal B kemudian dialirkan menuju ke dua saluran, yaitu:","title":"B. Tegangan Yang Keluar (Output Voltage)"},{"location":"ototronik/prinsip-regulator-mekanik/#1-ke-baterai","text":"Lilitan Stator \u2192 Diode Rectifier \u2192 Terminal B Alternator \u2192 Terminal (+) Baterai Maka terjadi proses pengisian (charge) pada baterai. (Mengenai proses elektrolisa pengisian pada baterai akan dibahas pada artikel terpisah)","title":"1. Ke Baterai"},{"location":"ototronik/prinsip-regulator-mekanik/#2-ke-regulator","text":"Lilitan Stator \u2192 Diode Rectifier \u2192 Terminal B Alternator \u2192 Terminal B Regulator \u2192 Voltage Regulator (melalui pertemuan titik kontak B dengan titik kontak C) \u2192 Terminal E Regulator \u2192 Massa Bodi Lilitan Voltage Regulator mendapat tegangan dari terminal B alternator maka terbentuk kemagnetan pada lilitan. Namun sifat kemagnetan lilitan voltage regulator belum mampu menarik titik kontak 2 untuk terlepas dari titik kontak 1, hal ini karena mesin masih berputar lambat (idle).","title":"2. Ke Regulator"},{"location":"ototronik/prinsip-regulator-mekanik/#4-putaran-idle-ke-putaran-menengah","text":"Perhatikan Gambar 4. Dari mulai putaran idle, putaran menengah hingga ke putaran tinggi, bahasan terkonsentrasi pada voltage regulator. Tegangan yang dikeluarkan alternator melalui terminal B kemudian masuk kedalam regulator melalui terimal B regulator dan mengisi lilitan voltage regulator. Arus medan (field current) yang ke rotor dikontrol dan disesuaikan dengan tegangan yang dikeluarkan terminal B yang beraksi pada voltage regulator. Pengaturan besar arus medan (untuk pembentukan magnet) yang masuk ke dalam rotor diatur dengan arus yang melewati resistor (R) atau langsung tanpa melewati resistor. Arus akan melewati resistor atau tidak melewati resistor tergantung posisi titik kontak 2. Gambar 4. Putaran Idle ke Putaran Menengah","title":"4. Putaran Idle ke Putaran Menengah"},{"location":"ototronik/prinsip-regulator-mekanik/#arus-yang-ke-rotor-coil","text":"Terminal B Alternator \u2192 Ignition Switch \u2192 Fuse \u2192 Terminal IG Regulator \u2192 Titik Kontak 1 \u2192 Titik Kontak 2 \u2192 Resistor \u2192 Terminal F Regulator \u2192 Terminal F Alternator \u2192 Rotor Coil \u2192 Terminal E Alternator \u2192 Massa Bodi Dalam hal ini arus yang akan masuk kedalam rotor coil bisa melalui 2 saluran yang saling bergantian, yaitu: Bila kemagnetan yang terbentuk didalam Voltage Regulator besar, akan mampu menarik titik kontak 2 terlepas dari titik kontak 1, maka arus yang akan ke rotor coil harus melewati resistor (R). Akibatnya arus yang mengalir menuju ke rotor coil akan mengecil (berkurang karena terhambat resistor) dan kemagnetan yang ditimbulkan rotor coil pun mengecil (berkurang). Sedangkan jika kemagnetan pada voltage regulator lemah, titik kontak 2 tidak akan tertarik dari titik kontak 1, maka arus yang akan ke rotor coil tidak akan melewati resitor karena titik kontak 2 berhubungan dengan titik kontak 1, sehingga kemagnetan pada rotor coil akan normal kembali. Pergantian saluran ini terus berlangsung jika mesin berputar dalam putaran idle ke menengah atau mesin bertahan pada putaran menengah.","title":"Arus Yang Ke Rotor Coil"},{"location":"ototronik/prinsip-regulator-mekanik/#5-putaran-menengah-ke-putaran-tinggi","text":"Perhatikan Gambar 5. Jika putaran mesin bertambah maka arus yang dihasilkan oleh stator coil pun akan bertambah, dan sifat kemagnetan pada voltage regulator menjadi lebih kuat. Dengan sifat kemagnetan yang lebih kuat pada voltage regulator membuat arus medan yang ke rotor coil akan mengalir terputus-putus (intermittenly). Hal ini terjadi karena titik kontak 2 dari voltage regulator kadang-kadang berhubungan dengan titik kontak 3 (yang menuju ke massa bodi). Walaupun titik kontak 2 kadang berhubungan dengan titik kontak 3 pada voltage regulator, namun titik kontak B pada voltage relay tidak akan terlepas dari titik kontak C, karena tegangan N (Netral) terpelihara dalam sisa flux dari rotor. Gambar 5. Putaran Menengah ke Putaran Tinggi","title":"5. Putaran Menengah ke Putaran Tinggi"},{"location":"ototronik/prinsip-regulator-mekanik/#pembatasan-dan-kehilangan-arus-medan","text":"Pada saat mesin mencapai putaran tinggi, maka arus yang akan masuk kedalam rotor coil sebagian akan dibuang untuk membatasi arus medan. Dalam hal ini arus yang akan masuk kedalam rotor coil bisa saja dialirkan dan atau dibuang. Proses pengaliran dan pembuangan arus medan terjadi secara bergantian, dengan rincian aliran sebagai berikut:","title":"Pembatasan dan Kehilangan Arus Medan"},{"location":"ototronik/prinsip-regulator-mekanik/#1-pembatasan-arus-medan","text":"Pembatasan arus medan dilakukan oleh Resistor, hal ini terjadi karena titik kontak 2 tertarik oleh kemagnetan yang cukup besar dari voltage regulator seiring dengan pertambahan putaran mesin, hingga terlepas dari titik kontak 1. Namun titik kontak 2 belum berhubungan dengan titik kontak 3 (titik kontak 2 mengambang diantara titik kontak 1 dan titik kontak 3). Arus yang berasal dari terminal IG regulator menuju rotor coil akan tertahan oleh Resistor. Perhatikan aliran arus medan dibawah ini: Terminal B Alternator \u2192 Ignition Switch \u2192 Fuse \u2192 Terminal IG Regulator \u2192 Resistor (R) \u2192 Terminal F Regulator \u2192 Terminal F Alternator \u2192 Rotor Coil \u2192 Terminal E Alternator \u2192 Massa Bodi","title":"1. Pembatasan Arus Medan"},{"location":"ototronik/prinsip-regulator-mekanik/#2-pembuangan-arus-medan","text":"Pada saat arus yang dihasilkan terminal B alternator bertambah lebih besar lagi seiring dengan pertambahan putaran mesin, maka sifat kemagnetan pada voltage regulator semakin kuat, hingga mampu menarik titik kontak 2 berhubungan titik kontak 3. Saat titik kontak 2 berhubungan dengan titik kontak 3 maka arus yang melewati Resistor akan dibuang ke massa bodi tanpa dialirkan kedalam rotor coil. Perhatikan aliran arus medan dibawah ini: Terminal B Alternator \u2192 Ignition Switch \u2192 Fuse \u2192 Terminal IG Regulator \u2192 Resistor (R) \u2192 Titik Kontak 2 \u2192 Titik Kontak 3 \u2192 Terminal E Regulator \u2192 Massa Bodi Ketika arus medan rotor ini dibuang ke massa, maka hilang kemagnetan pada rotor coil. Ketika kemagnetan menghilang maka tegangan yang dihasilkan stator coil akan turun drastis, ketika terjadi penurunan tegangan maka sifat kemagnetan pada voltage regulator akan menghilang. Kehilangan sifat kemagnetan membuat kontak 2 akan kembali ke posisi semula (ke kontak 1), namun baru saja lepas dari kontak 3, tegangan sudah dihasilkan lagi oleh stator coil. Ketika putaran mesin tinggi, kejadian putus sambung antara kontak 2 dengan kontak 3 terus berlangsung. Hal ini tentu akan menjaga kenaikan/lonjakan tegangan listrik dari stator coil yang melebihi kemampuan sistem kelistrikan.","title":"2. Pembuangan Arus Medan"},{"location":"ototronik/prinsip-regulator-mekanik/#kesimpulan","text":"Pada dasarnya regulator apapun jenisnya, baik mekanik maupun elektronik mempunya tugas untuk membatasi, menjaga, menstabilkan tegangan listrik yang dihasilkan oleh generator listrik. Hal ini karena kemampuan baterai dan komponen kelistrikan otomotif lainnya telah dibatasi kemampuannya dalam menerima tegangan listrik. Secara umum, kemampuan baterai dan komponen sistem kelistrikan otomotif hanya mampu menerima tegangan maksimal sebesar 15 Volt. Salam hangat dari Banjarsari - Ciamis - Jawa Barat - Indonesia - Bumi - Galaksi Bima Sakti...","title":"Kesimpulan"},{"location":"ototronik/starter-sepeda-motor/","text":"Sistem Starter Sepeda Motor \u00b6 Sistem Starter Sepeda Motor menggunakan motor listrik arus searah yang mengubah energi listrik menjadi energi mekanik untuk memberikan gerak mula pada poros engkol. Gerak mula pada poros engkol atau crankshaft digunakan untuk menggerakan torak naik ke TMA dan turun ke TMB agar proses isap, kompresi, kerja dan buang bisa dimulai. Tugas Sistem Starter hanya untuk memberikan gerakan awal poros engkol saat memulai menghidupkan mesin. Sistem Starter Motor Listrik Sepeda Motor \u00b6 Untuk menghidupkan mesin sepeda motor diperlukan gerakan awal pada poros engkol ( crankshaft ) agar torak bergerak naik turun sehingga mesin dapat memulai siklusnya. Gerakan awal berupa putaran pada poros engkol diberikan oleh Sistem Starter atau Sistem Penggerak Mula. Sistem Starter dibedakan menurut jenis penggerak yang memulai putaran, yaitu: Sistem starter mekanis; Sistem starter motor listrik. Kedua sistem starter ini hampir semuanya dipasang pada berbagai jenis sepeda motor. Dari kedua sistem starter tersebut, jenis penggerak motor listrik merupakan jenis yang paling banyak digunakan oleh pengguna sepeda motor karena penggunaanya yang mudah dan ringan. Sedangkan sistem starter jenis penggerak mekanis atau sering disebut juga dengan Kick Starter lebih banyak digunakan sebagai cadangan. Kick Starter membutuhkan tenaga yang cukup besar untuk menggerakan poros engkol sehinga digunakan hanya ketika sistem starter motor listrik mengalami gangguan. Petunjuk Umum Wiring \u00b6 Wiring adalah teknik pengkabelan yang menghubungkan antar komponen kelistrikan untuk membentuk suatu rangkaian kelistrikan. Pada penjelasan berikut akan ditunjukan gambar wiring dengan warna pengkabelan berbeda. Warna merah digunakan untuk menggambarkan kabel yang dialiri tegangan positif baterei. Sedangkan warna hitam digunakan untuk menggambarkan kabel yang terhubung dengan negatif baterei. Hati-hati dalam melihat posisi saklar atau switch baik dalam keadaan OFF (terputus) maupun ON (terhubung). Komponen Sistem Starter Motor Listrik \u00b6 Pada gambar berikutnya tertera nama dari masing-masing komponen kelistrikan yang digunakan pada sistem starter motor listrik, diantaranya: Gambar 1. Komponen Sistem Starter Sepeda Motor Baterei adalah sumber listrik berarus DC dengan tegangan 12 Volt. Hampir semua komponen kelistrik pada sepeda motor mengambil energi listrik dari baterei. Kapasitas baterei berbeda-beda pada setiap merk dan tipe sepeda motor, yang biasanya disesuaikan dengan kapasitas mesin dan kelengkapan kelistrikan lainnya. Semakin besar energi yang dibutuhkan maka semakin besar kapasitas baterei. Fuse atau Sekring adalah komponen pengaman rangkaian kelistrikan saat terjadi short circuit atau hubungan singkat. Ketika terjadi short circuit maka fuse akan memutuskan dirinya sendiri agar komponen dan kabel dalam rangkaian kelistrikan tidak terbakar atau rusak. Ignition Switch atau Main Switch atau Kunci Kontak adalah sejenis saklar yang digunakan untuk menghubungkan dan memutuskan rangkaian kelistrikan secara keseluruhan menggunakan bantuan anak kunci yang dibuat unik. Hampir semua sistem kelistrikan pada sepeda motor akan mengambil tegangan dari baterei dengan melewati Saklar Utama ini. Starter Relay atau Magnetic Switch adalah saklar dengan kemampuan daya besar untuk mengalirkan listrik dari baterei menuju ke Motor Starter yang akan terhubung (ON) dan terputus (OFF) dengan teknik picuan kemagnetan. Ada dua bagian didalam Starter Relay yaitu: Selenoid dan Kontak Besar yang dihubungkan oleh plat. Ketika sifat kemagnetan terbentuk pada selenoid maka kontak besar dalam posisi ON, jika sifat kemagnetan menghilang pada selenoid maka kontak besar dalam posisi OFF. Starter Relay menggunakan kontak saklar berukuran besar karena konsumsi daya motor listrik yang besar pula. Hal ini untuk memperlambat tingkat keausan kontak saklar akibat panas yang muncul ketika saklar mulai terhubung dan terputus serta untuk memaksimalkan energi listrik yang dialirkan menuju ke Motor Starter. Motor Starter adalah motor listrik arus searah yang mengubah energi listrik baterei menjadi energi mekanik untuk menggerakan poros engkol. Motor Listrik ini membutuhkan daya yang besar sehingga kabel dan saklar yang digunakan untuk mengalirkan energi listrik juga harus yang berdaya besar agar motor listrik mampu menghasil putaran yang cepat dan kuat. Starter Switch atau Saklar Starter adalah saklar khusus yang digunakan untuk mengaktifkan Starter Relay . Pada saat Starter Switch dalam posisi terhubung (ON) atau posisi ditekan maka akan terbentuk kemagnetan pada selenoid yang mampu menghubungkan saklar didalam Magnetic Switch . Pada saat Starter Switch dalam posisi terputus (OFF) maka sifat kemagnetan pada selenoid akan menghilang dan saklar didalam Magnetic Switch akan terputus. Starter Switch berperan sebagai saklar pemicu untuk mengatur pembentukan sifat kemagnetan pada selenoid didalam Starter Relay. Starter Switch ditempatkan pada area kemudi yang mudah untuk dijangkau jari tangan. Pada saat Ignition Switch OFF \u00b6 Pada saat Ignition Switch atau Kunci Kontak terputus (OFF) maka seluruh sistem kelistrikan dalam keadaan mati termasuk sistem starter. Gambar 2. Sistem Starter saat Kunci Kontak OFF Aliran listrik positif (Warna Merah): Baterei + \u2192 Fuse \u2192 Ignition Switch \u2192 X Baterei + \u2192 kontak besar Starter Relay \u2192 X Tanda X berarti tidak berhubungan dengan apapun. Pada saat Ignition Switch ON \u00b6 Pada saat Ignition Switch terhubung (ON) maka beberapa sistem kelistrikan mendapat asupan listrik dari baterei, termasuk Starter Relay. Gambar 3. Sistem Starter saat Kunci Kontak ON Aliran listrik positif (Warna Merah): Baterei + \u2192 Fuse \u2192 Ignition Switch \u2192 Lilitan Selenoid Starter Relay \u2192 Starter Switch \u2192 X Baterei + \u2192 Kontak Besar Starter Relay \u2192 X Tanda X berarti tidak berhubungan dengan apapun. Lilitan selenoid pada Starter Relay juga mendapat asupan listrik dari kunci kontak namun karena Starter Switch belum terhubung ke negatif/massa baterei maka belum terbentuk sifat kemagnetan sehingga plat kontak saklar tidak tertarik dan saklar yang besar pun masih dalam keadaan terputus. Pada saat Starter Switch ON \u00b6 Pada saat Starter Switch dihubungkan (ON) maka aliran listrik dari selenoid akan diteruskan ke massa dan terbentuklah sifat kemagnetan pada selenoid. Gambar 4. Sistem Starter Saat Saklar Starter OFF Aliran listrik positif (Warna Merah): Baterei + \u2192 Fuse \u2192 Ignition Switch \u2192 Lilitan Selenoid Starter Relay \u2192 Starter Switch \u2192 Massa Baterei + \u2192 Kontak Besar Starter Relay \u2192 Starter Motor \u2192 Massa Ada dua kejadian saat Starter Switch dalam kondisi terhubung, yaitu: Terbentuknya kemagnetan pada lilitan selenoid. Sifat kemagnetan tersebut digunakan untuk menarik plat kontak besar diatasnya yang berfungsi untuk menghubungkan aliran tegangan dari baterei menuju Starter Motor. Sifat kemagnetan terbentuk karena Starter Switch pada awalnya sudah mendapat tegangan dari positif baterei dan sedang menunggu tegangan negatif atau massa baterei. Ketika Starter Switch dihubungkan, selenoid mendapat asupan tegangan positif dan negatif maka terbentuklah sifat kemagnetan pada lilitan selenoid. Ketika plat kontak tertarik oleh sifat kemagnetan yang terbentuk pada selenoid maka tegangan dari positif baterei akan mengalir menuju Starter Motor. Starter Motor mendapat asupan tegangan positif dan negatif baterei maka terjadi transformasi energi listrik menjadi energi mekanik. Energi putaran yang terbentuk pada Starter Motor digunakan untuk menggerakkan poros engkol. Beberapa saat kemudian... Brum! Brum! Brum! Bruuuuuuuuuuuummmm! Bruuuuuuuuuuuuuuuuuuuummmm! Bleph! Bleph! Bleph! Bleph! Argh! Bensin habis...! Kesimpulan \u00b6 Kenapa wiring sistem starter harus menggunakan Starter Relay atau Magnetic Switch? Starter Relay digunakan pada wiring sistem starter motor listrik karena alasan sebagai berikut: Mencegah terjadinya drop (penurunan) tegangan. Dengan menggunakan Starter Relay maka jarak antara baterei dengan starter motor menjadi lebih dekat sehingga rugi tegangan akibat tahanan (resistansi) kabel akan semakin kecil. Jika tidak menggunakan Relay Starter maka dibutuhkan kontak saklar berukuran besar dan hal ini tentu tidak memungkinkan untuk ditempatkan pada kemudi agar dekat dengan jari tangan. Lebih hemat biaya. Motor Starter membutuhkan energi yang besar maka dibutuhkan kabel penghubung yang besar pula. Tanpa Starter Relay maka kabel yang dibutuhkan akan lebih panjang dan mahal. Demikianlah beberapa alasan penggunaan Starter Relay dan demikian pula bahasan tentang prinsip kerja wiring sistem starter jenis motor listrik. Wiring atau pengkabelan Sistem Starter Motor Listrik yang digunakan pada artikel ini diambil dari jenis umum yang secara prinsip hampir sama pada semua merk dan type sepeda motor. Sedangkan secara spesifik yang membahas tentang fitur-fitur tambahan akan dijelaskan pada artikel terpisah. Sekian... Referensi \u00b6 Motorcycle Electrical Systems, American Honda Motor Co., Inc., 1977 Pedoman Reparasi Umum, Astra Honda Motor, 2014 Manual Service, Yamaha Motor Co., Ltd, 2006 New Step I Training Manual, Toyota Astra Motor, 1995","title":"Sistem Starter Sepeda Motor"},{"location":"ototronik/starter-sepeda-motor/#sistem-starter-sepeda-motor","text":"Sistem Starter Sepeda Motor menggunakan motor listrik arus searah yang mengubah energi listrik menjadi energi mekanik untuk memberikan gerak mula pada poros engkol. Gerak mula pada poros engkol atau crankshaft digunakan untuk menggerakan torak naik ke TMA dan turun ke TMB agar proses isap, kompresi, kerja dan buang bisa dimulai. Tugas Sistem Starter hanya untuk memberikan gerakan awal poros engkol saat memulai menghidupkan mesin.","title":"Sistem Starter Sepeda Motor"},{"location":"ototronik/starter-sepeda-motor/#sistem-starter-motor-listrik-sepeda-motor","text":"Untuk menghidupkan mesin sepeda motor diperlukan gerakan awal pada poros engkol ( crankshaft ) agar torak bergerak naik turun sehingga mesin dapat memulai siklusnya. Gerakan awal berupa putaran pada poros engkol diberikan oleh Sistem Starter atau Sistem Penggerak Mula. Sistem Starter dibedakan menurut jenis penggerak yang memulai putaran, yaitu: Sistem starter mekanis; Sistem starter motor listrik. Kedua sistem starter ini hampir semuanya dipasang pada berbagai jenis sepeda motor. Dari kedua sistem starter tersebut, jenis penggerak motor listrik merupakan jenis yang paling banyak digunakan oleh pengguna sepeda motor karena penggunaanya yang mudah dan ringan. Sedangkan sistem starter jenis penggerak mekanis atau sering disebut juga dengan Kick Starter lebih banyak digunakan sebagai cadangan. Kick Starter membutuhkan tenaga yang cukup besar untuk menggerakan poros engkol sehinga digunakan hanya ketika sistem starter motor listrik mengalami gangguan.","title":"Sistem Starter Motor Listrik Sepeda Motor"},{"location":"ototronik/starter-sepeda-motor/#petunjuk-umum-wiring","text":"Wiring adalah teknik pengkabelan yang menghubungkan antar komponen kelistrikan untuk membentuk suatu rangkaian kelistrikan. Pada penjelasan berikut akan ditunjukan gambar wiring dengan warna pengkabelan berbeda. Warna merah digunakan untuk menggambarkan kabel yang dialiri tegangan positif baterei. Sedangkan warna hitam digunakan untuk menggambarkan kabel yang terhubung dengan negatif baterei. Hati-hati dalam melihat posisi saklar atau switch baik dalam keadaan OFF (terputus) maupun ON (terhubung).","title":"Petunjuk Umum Wiring"},{"location":"ototronik/starter-sepeda-motor/#komponen-sistem-starter-motor-listrik","text":"Pada gambar berikutnya tertera nama dari masing-masing komponen kelistrikan yang digunakan pada sistem starter motor listrik, diantaranya: Gambar 1. Komponen Sistem Starter Sepeda Motor Baterei adalah sumber listrik berarus DC dengan tegangan 12 Volt. Hampir semua komponen kelistrik pada sepeda motor mengambil energi listrik dari baterei. Kapasitas baterei berbeda-beda pada setiap merk dan tipe sepeda motor, yang biasanya disesuaikan dengan kapasitas mesin dan kelengkapan kelistrikan lainnya. Semakin besar energi yang dibutuhkan maka semakin besar kapasitas baterei. Fuse atau Sekring adalah komponen pengaman rangkaian kelistrikan saat terjadi short circuit atau hubungan singkat. Ketika terjadi short circuit maka fuse akan memutuskan dirinya sendiri agar komponen dan kabel dalam rangkaian kelistrikan tidak terbakar atau rusak. Ignition Switch atau Main Switch atau Kunci Kontak adalah sejenis saklar yang digunakan untuk menghubungkan dan memutuskan rangkaian kelistrikan secara keseluruhan menggunakan bantuan anak kunci yang dibuat unik. Hampir semua sistem kelistrikan pada sepeda motor akan mengambil tegangan dari baterei dengan melewati Saklar Utama ini. Starter Relay atau Magnetic Switch adalah saklar dengan kemampuan daya besar untuk mengalirkan listrik dari baterei menuju ke Motor Starter yang akan terhubung (ON) dan terputus (OFF) dengan teknik picuan kemagnetan. Ada dua bagian didalam Starter Relay yaitu: Selenoid dan Kontak Besar yang dihubungkan oleh plat. Ketika sifat kemagnetan terbentuk pada selenoid maka kontak besar dalam posisi ON, jika sifat kemagnetan menghilang pada selenoid maka kontak besar dalam posisi OFF. Starter Relay menggunakan kontak saklar berukuran besar karena konsumsi daya motor listrik yang besar pula. Hal ini untuk memperlambat tingkat keausan kontak saklar akibat panas yang muncul ketika saklar mulai terhubung dan terputus serta untuk memaksimalkan energi listrik yang dialirkan menuju ke Motor Starter. Motor Starter adalah motor listrik arus searah yang mengubah energi listrik baterei menjadi energi mekanik untuk menggerakan poros engkol. Motor Listrik ini membutuhkan daya yang besar sehingga kabel dan saklar yang digunakan untuk mengalirkan energi listrik juga harus yang berdaya besar agar motor listrik mampu menghasil putaran yang cepat dan kuat. Starter Switch atau Saklar Starter adalah saklar khusus yang digunakan untuk mengaktifkan Starter Relay . Pada saat Starter Switch dalam posisi terhubung (ON) atau posisi ditekan maka akan terbentuk kemagnetan pada selenoid yang mampu menghubungkan saklar didalam Magnetic Switch . Pada saat Starter Switch dalam posisi terputus (OFF) maka sifat kemagnetan pada selenoid akan menghilang dan saklar didalam Magnetic Switch akan terputus. Starter Switch berperan sebagai saklar pemicu untuk mengatur pembentukan sifat kemagnetan pada selenoid didalam Starter Relay. Starter Switch ditempatkan pada area kemudi yang mudah untuk dijangkau jari tangan.","title":"Komponen Sistem Starter Motor Listrik"},{"location":"ototronik/starter-sepeda-motor/#pada-saat-ignition-switch-off","text":"Pada saat Ignition Switch atau Kunci Kontak terputus (OFF) maka seluruh sistem kelistrikan dalam keadaan mati termasuk sistem starter. Gambar 2. Sistem Starter saat Kunci Kontak OFF Aliran listrik positif (Warna Merah): Baterei + \u2192 Fuse \u2192 Ignition Switch \u2192 X Baterei + \u2192 kontak besar Starter Relay \u2192 X Tanda X berarti tidak berhubungan dengan apapun.","title":"Pada saat Ignition Switch OFF"},{"location":"ototronik/starter-sepeda-motor/#pada-saat-ignition-switch-on","text":"Pada saat Ignition Switch terhubung (ON) maka beberapa sistem kelistrikan mendapat asupan listrik dari baterei, termasuk Starter Relay. Gambar 3. Sistem Starter saat Kunci Kontak ON Aliran listrik positif (Warna Merah): Baterei + \u2192 Fuse \u2192 Ignition Switch \u2192 Lilitan Selenoid Starter Relay \u2192 Starter Switch \u2192 X Baterei + \u2192 Kontak Besar Starter Relay \u2192 X Tanda X berarti tidak berhubungan dengan apapun. Lilitan selenoid pada Starter Relay juga mendapat asupan listrik dari kunci kontak namun karena Starter Switch belum terhubung ke negatif/massa baterei maka belum terbentuk sifat kemagnetan sehingga plat kontak saklar tidak tertarik dan saklar yang besar pun masih dalam keadaan terputus.","title":"Pada saat Ignition Switch ON"},{"location":"ototronik/starter-sepeda-motor/#pada-saat-starter-switch-on","text":"Pada saat Starter Switch dihubungkan (ON) maka aliran listrik dari selenoid akan diteruskan ke massa dan terbentuklah sifat kemagnetan pada selenoid. Gambar 4. Sistem Starter Saat Saklar Starter OFF Aliran listrik positif (Warna Merah): Baterei + \u2192 Fuse \u2192 Ignition Switch \u2192 Lilitan Selenoid Starter Relay \u2192 Starter Switch \u2192 Massa Baterei + \u2192 Kontak Besar Starter Relay \u2192 Starter Motor \u2192 Massa Ada dua kejadian saat Starter Switch dalam kondisi terhubung, yaitu: Terbentuknya kemagnetan pada lilitan selenoid. Sifat kemagnetan tersebut digunakan untuk menarik plat kontak besar diatasnya yang berfungsi untuk menghubungkan aliran tegangan dari baterei menuju Starter Motor. Sifat kemagnetan terbentuk karena Starter Switch pada awalnya sudah mendapat tegangan dari positif baterei dan sedang menunggu tegangan negatif atau massa baterei. Ketika Starter Switch dihubungkan, selenoid mendapat asupan tegangan positif dan negatif maka terbentuklah sifat kemagnetan pada lilitan selenoid. Ketika plat kontak tertarik oleh sifat kemagnetan yang terbentuk pada selenoid maka tegangan dari positif baterei akan mengalir menuju Starter Motor. Starter Motor mendapat asupan tegangan positif dan negatif baterei maka terjadi transformasi energi listrik menjadi energi mekanik. Energi putaran yang terbentuk pada Starter Motor digunakan untuk menggerakkan poros engkol. Beberapa saat kemudian... Brum! Brum! Brum! Bruuuuuuuuuuuummmm! Bruuuuuuuuuuuuuuuuuuuummmm! Bleph! Bleph! Bleph! Bleph! Argh! Bensin habis...!","title":"Pada saat Starter Switch ON"},{"location":"ototronik/starter-sepeda-motor/#kesimpulan","text":"Kenapa wiring sistem starter harus menggunakan Starter Relay atau Magnetic Switch? Starter Relay digunakan pada wiring sistem starter motor listrik karena alasan sebagai berikut: Mencegah terjadinya drop (penurunan) tegangan. Dengan menggunakan Starter Relay maka jarak antara baterei dengan starter motor menjadi lebih dekat sehingga rugi tegangan akibat tahanan (resistansi) kabel akan semakin kecil. Jika tidak menggunakan Relay Starter maka dibutuhkan kontak saklar berukuran besar dan hal ini tentu tidak memungkinkan untuk ditempatkan pada kemudi agar dekat dengan jari tangan. Lebih hemat biaya. Motor Starter membutuhkan energi yang besar maka dibutuhkan kabel penghubung yang besar pula. Tanpa Starter Relay maka kabel yang dibutuhkan akan lebih panjang dan mahal. Demikianlah beberapa alasan penggunaan Starter Relay dan demikian pula bahasan tentang prinsip kerja wiring sistem starter jenis motor listrik. Wiring atau pengkabelan Sistem Starter Motor Listrik yang digunakan pada artikel ini diambil dari jenis umum yang secara prinsip hampir sama pada semua merk dan type sepeda motor. Sedangkan secara spesifik yang membahas tentang fitur-fitur tambahan akan dijelaskan pada artikel terpisah. Sekian...","title":"Kesimpulan"},{"location":"ototronik/starter-sepeda-motor/#referensi","text":"Motorcycle Electrical Systems, American Honda Motor Co., Inc., 1977 Pedoman Reparasi Umum, Astra Honda Motor, 2014 Manual Service, Yamaha Motor Co., Ltd, 2006 New Step I Training Manual, Toyota Astra Motor, 1995","title":"Referensi"},{"location":"papan/apa-itu-arduino/","text":"Mengenal Arduino \u00b6 Arduino merupakan salah satu platform mikrokontroler yang sangat populer akhir-akhir ini. Para pegiat mikrokontroler dari segala penjuru dunia sebagian besar terpusat untuk membahas pembahasan Arduino. Sifatnya yang Open Source Hardware membuatnya berkembang sangat pesat. Orang-orang begitu bersemangat untuk saling berbagi kode-kode yang sudah disusun oleh mereka untuk dibagikan keseluruh dunia. Selain itu, perangkat keras yang tersedia pun semakin melimpah dan semakin murah. Para pecinta mikrokontroler berlomba-lomba untuk membuat platform Arduino ini dengan berbagai fasilitas dan fungsi yang lebih namun dengan tetap menjualnya dengan harga murah. Setiap pecinta mikrokontroler diperbolehkan untuk membuat Arduino sesuai dengan selera dan kebutuhannya masing-masing, inilah yang membuat Arduini menjadi sangat menarik untuk dipelajari. Lalu apa Arduino? Apa itu Arduino? \u00b6 Arduino adalah sebuah platform open source (sumber terbuka) yang digunakan untuk membuat proyek-proyek elektronika. Arduino terdiri dari dua bagian utama yaitu sebuah papan sirkuit fisik (sering disebut juga dengan mikrokontroler) dan sebuah perangkat lunak atau IDE (Integrated Development Environment) yang berjalan pada komputer. Perangkat lunak ini sering disebut Arduino IDE yang digunakan untuk menulis dan meng-upload kode dari komputer ke papan fisik (hardware) Arduino. Ketika membicarakan Arduino maka ada dua hal yang terlintas dalam pikiran para penggunanya, yaitu hardware dan software. Dua bagian ini seakan satu kesatuan utuh yang tidak bisa di pisahkan. Platform Arduino sekarang ini menjadi sangat populer dengan pertambahan jumlah pengguna baru yang terus meningkat. Hal ini karena kemudahannya dalam penggunaan dan penulisan kode. Tidak seperti kebanyakan papan sirkuit pemrograman sebelumnya, Arduino tidak lagi membutuhkan perangkat keras terpisah (disebut programmer atau downloader) untuk memuat atau meng-upload kode baru ke dalam mikrokontroler. Cukup dengan menggunakan kabel USB untuk mulai menggunakan Arduino. Selain itu, Arduino IDE menggunakan bahasa pemrograman C++ dengan versi yang telah disederhanakan, sehingga lebih mudah dalam belajar pemrograman. Arduino akhirnya berhasil menjadi papan sirkuit pemrograman paling disukai hingga menjadikannya sebagai bentuk standar dari fungsi mikrokontroler dengan paket yang mudah untuk diakses. Gambar diatas menunjukan papan Arduino Uno yang merupakan salah satu papan paling populer diantara keluarga Arduino dan papan ini merupakan pilihan yang sangat cocok bagi para pemula. Dan selanjutnya artikel ini akan membahas lebih dalam mengenai Arduino terutama Arduino Uno. Sebelum Arduino diciptakan, menulis kode mikrokontroler adalah hal yang sangat rumit dan memusingkan, tapi sekarang, hal yang sangat rumit itu menjadi lebih sederhana. Bahkan sebagian orang menyebutnya tidak mungkin, ketika hanya dengan 10 baris kode kita mampu membuat LED berkedip. Apa Itu Mikrokontroler? \u00b6 Berbagai jenis komputer dirancang dan dibangun dengan tujuan berbeda. Komputer yang menjadi jantung laptop Anda dioptimalkan untuk tujuan berbeda dari apa yang ada didalam ponsel atau didalam mouse yang anda pegang sekarang. Komputer sederhana adalah perangkat yang dirancang untuk mengambil perangkat inpu (masukan) dari dunia fisik dan atau mengendalikan perangkat output (keluaran) di dunia fisik. Inilah yang disebut mikrokontroler. Sebagian perangkat elektronik yang ada sekarang ini memiliki mikrokontroler pada bagian intinya. Mikrokontroler yang dioptimalkan untuk mengendalikan input saja atau output saja. Mereka pada umumnya memiliki kemampuan komputasi yang rendah jika dibandingkan dengan prosesor yang digunakan pada komputer multimedia atau komputer server. Mikrokontroler membutuhkan daya yang lebih rendah dibanding prosesor lainnya dan lebih mudah untuk berinteraksi dengan dunia fisik melalui sirkuit input yang disebut sensor dan sirkuit output yang disebut aktuator. Mikrokontroler juga dapat berkomunikkasi dengan prosesor lain melalui berbagai antarmuka komunikasi (communication interface). Komputer, mikrokontroler, prosesor? Jadi yang mana? Kita sering mendengar istilah-istilah ini disebutkan silih berganti disekitar kita. Komputer dan Prosesor adalah istilah umum untuk apapun yang pada dasarnya mampu menjalankan program. Sedangkan Kontroler atau Mikrokontroler biasanya diperuntukan bagi prosesor sederhana yang hanya mampu menjalankan satu tugas saja, seperti membaca sensor. Apa Yang Bisa Dilakukan Arduino? \u00b6 Hardware dan software Arduino dirancang bagi para seniman, desainer, pe-hobi, hacker, pemula dan siapapun yang tertarik untuk menciptakan objek interaktif dan pengembangan lingkungan. Arduino mampu berinteraksi dengan tombol, LED, motor, speaker, GPS, kamera, internet, ponsel pintar bahkan dengan televisi anda. Fleksibilitas ini dihasilkan dari kombinasi ketersediaan software Arduino yang gratis, papan perangkat keras yang murah, dan keduanya yang mudah untuk dipelajari. Hal inilah yang menciptakan jumlah pengguna menjadi sebuah komunitas besar dengan berbagai kontribusinya yang telah dirilis pada berbagai proyek dengan berbasiskan Arduino. Jika Anda ingin mengetahui dimana kita bisa menemukan berbagai contoh proyek Arduino yang telah tercipta, dibawah ini adalah beberapa sumber daya yang bagus untuk proyek-proyek berbasis Arduino, yang bisa memicu cara berfikir Anda dan menggugah kreatifitas: Sparkfun Instructables Bildr Arduino Playground Adafruit Make Projects Dan tentu saja anda dapat menemukan banyak tutorial menarik disini di https://henduino.github.io/library/ Apa Yang Ada Pada Papan Arduino? \u00b6 Ada banyak jenis papan Arduino yang dapat digunakan untuk tujuan yang berbeda. Beberapa papan memiliki ukuran, jumlah pin, mikrokontroler yang berbeda seperti pada gambar dibawah ini. Namun, sebagian besar Arduino memiliki komponen utama yang sama. Daya (USB/Barrel Jack) \u00b6 Setiap papan Arduino membutuhkan jalur untuk terhubung ke sumber listrik. Arduino Uno dapat diaktifkan melalui kable USB ang berasal dari komputer atau power supply terpisah yang dihubungkan ke Barrel Jack. Pada gambar diatas koneksi USB diberi label (1) dan Barrel Jack diberi label (2). Koneksi USB selain digunakan sebagai jalur listrik untuk mengaktifkan papan, juga digunakan untuk meng-upload kode dari komputer ke papan Arduino. Dua fungsi melalui satu jalur atau 2 in 1 (seperti iklan Shampo). Perhatian!: JANGAN menggunakan power supply lebih dari 20 Volt untuk mengaktifkan papan Arduino melalui Barrel Jack karena itu tegangan berlebihan yang cukup untuk menghacurkan papan Arduino Anda. Tegangan yang dianjurkan untuk sebagian besar keluarga Arduino adalah antara 6 Volt sampai dengan 12 Volt. Pin (5V, 3.3V, GND, Analog, Digital, PWM, AREF) \u00b6 Pin pada Arduino adalah tempat dimana kita menghubungkan kabel untuk membuat suatu rangkaian (menghubungkan satu titik dengan titik lainnya pada breadboard dengan sejumlah kabel penghubung). Kabel penghubung (jumper wire) yang digunakan dalam membuat rangkaian biasanya memiliki kepala yang terbuat dari plastik berwarna hitam yang memungkin kawat dari kabel penghubungnya saja yang terhubung langsung ke papan. Arduino memiliki beberapa jenis pin yang masing-masing diberi label pada papan dan digunakan untuk fungsi yang berbeda-beda. GND (3) : GND merupakan singkatan dari GROUND. Ada beberapa pin GND pada Arduino, dan semuanya dapat digunakan untuk hubungan ke ground. 5V (4) dan 3.3V (5) : Pin 5V digunakan untuk menyediakan tegangan sebesar 5 volt. Sedangkan pin 3.3V digunakan untuk menyediakan tegangan 3,3 volt. Sebagian besar komponen sederhana yang digunakan bersama dengan Arduino berjalan pada kisaran tegangan 3,3 volt hingga 5 volt. Analog (6) : Pin yang berada pada area berlabel \"ANALOG IN\" (A0 sampai A5 pada Arduino Uno) digunakan sebagai pin analog. Yaitu pin yang digunakan untuk membaca sinyal-sinyal analog dari sensor-sensor analog (misal; sensor suhu) dan mengubahnya menjadi nilai digital yang dapat kita baca. Digital (7) : Pin digital berada diseberang pin analog (0 sampai 13 pada Arduino Uno). Pin ini dapat digunakan dalam 2 arah digital yaitu input digital (misal untuk melihat kondisi bahwa tombol sedang ditekan) dan output digital (memberikan tegangan sebuah LED). PWM (8) : Perhatikanlah simbol tilde (~) disamping beberapa pin digital (yaitu pada pin 3, 5, 6, 9, 10 dan 11 pada Arduino Uno). Pin ini dapat digunakan sebagai pin digital biasa, tetapi juga dapat digunakan sebagai pin PWM (Pulse Width Modulation). PWM biasanya digunakan sebagai pin yang mampu mensimulasikan output analog (seperti mengatur pemudaran cahaya dan warna LED saat datang dan pergi). PWM bukan analog, hanya mampu mensimulasikan analog saja. Jadi tidaklah sama antara analog dengan PWM. (Bahasan di artikel lain). AREF (9) : Kepanjangan dari Analog Reference atau Referensi Analog. Selama belajar, tinggalkan saja pin ini. Pin ini terkadang digunakan sebagai referensi dalam mengatur tegangan eksternal (antara 0 sampai 5 volt) untuk memberikan limit (batasan akhir) pada input pin analog. Tombol Reset \u00b6 Menekan tombol Reset (10) beberapa saat pada papan Arduino akan menghubungkan pin Reset ke Ground. Ini digunakan untuk me-restart kode yang telah dimuat oleh Arduino. Ini sangat bermanfaat untuk menguji ulang kode, jika kode tersebut ditulis tanpa pengulangan (repeat) atau sekali jalan. Jika anda pernah menggunakan Nintendo pasti tahu fungsi tombol Reset ini. Pada Nintendo ketika menekan tombol Reset maka hal itu digunakan untuk memperbaiki masalah, tetapi tidak demikian pada Arduino. LED Indikator Daya \u00b6 Tepat di bawah dan di sebelah kanan kata \"UNO\" pada papan Arduino Uno, terdapat sebuah LED kecil berlabel \"ON\" (11). LED ini harus menyala setiap kita mengubungkan papan Arduino pada sumber listrik. Jika lampu LED ini tidak menyala, kemungkinan ada papan mengalami kerusakan atau terjadi kesalahan. Periksa ulang rankaian yang anda buat. TX RX LED \u00b6 TX adalah singkatan dari 'transmit' (kirim), dan RX adalah singkatan dari 'receive' (terima). LED indikator TX dan RX (12) ini akan berkedip redup atau terang dengan jeda tak tentu untuk memberitahukan bahwa telah terjadi komunikasi serial. Kedipan LED ini sebagai indikasi visual yang merupakan pertanda baik bahwa telah terjadi pengiriman dan penerimaan data pada papan Arduino (misal ketika kita meng-upload kode baru ke dalam papan). IC Utama \u00b6 Sesuatu yang berwarna hitam dengan semua kakinya terbuat dari logam inilah yang sebut IC atau Integrated Circuit (13). Ini adalah otak dari papan Arduino. IC utama Arduino berbeda-beda sesuai dengan jenis papan, tetapi biasanya memiliki ciri khas bertuliskan ATmega yang merupakan IC buatan perusahaan ATMEL. Ini merupakan hal penting, karena kita perlu untuk memahami jenis IC (sesuai juga dengan jenis papan Arduino) sebelum memuat atau meng-upload sekumpulan kode program yang telah kita buat dari perangkat lunak Arduino IDE kedalam papan Arduino. Informasi tentang tipe IC dapat kita temukan pada permukaan IC tersebut. Jika kita ingin tahu lebih jauh tentang perbedaan jenis IC yang digunakan pada keluarga Arduino maka sebaiknya selalu unduh datasheet dari masing-masing tipe IC. Regulator Tegangan \u00b6 Voltage Regulator (14) bukanlah sesuatu yang mampu berinteraksi dengan papan Arduino. Tetapi kita harus mengetahui fungsi dari voltage regulator. Voltage Regulator atau Regulator Tegangan akan mengalirkan sejumlah tegangan teregulati ke dalam papan Arduino. Voltage Regulator berperan sebagai penjaga pintu gerbang, dia akan membalikan atau membuang tegangan berlebihan yang bisa membahayan rangkaian. Tapi tentu saja ada batasnya, pastikan bahwa tegangan yang masuk ke dalam papan tidak lebih besar dari 20 volt. Keluarga Arduino \u00b6 Perusahaan Arduino telah membuat beberapa tipe papan yang berbeda-beda, masing-masing tipe tersebut memiliki kemampuan yang berbeda pula. Selain itu, Arduino merupakan Open Source Hardware yang berarti bahwa siapa saja dapat memodifikasi dan menghasilkan turunan Arduino dengan bentuk dan fungsi yang lebih beragam. Jika Anda belum begitu paham mengenai papan Arduino, berikut adalah beberapa pilihan yang cocok untuk mereka yang baru saja ingin berkenalan dengan Arduino. Arduino Uno (R3) \u00b6 Arduino Uno adalah pilihan yang tepat bagi mereka yang baru pertama kali ingin mempelajari Arduino. Karena Uno merupakan paket lengkap untuk memulai belajar Arduino. Memiliki 14 pin input/output digital (dimana 6 pin dapat digunakan sebagai output PWM), 6 pin input analog, koneksi USB, jack daya, tombol reset, dan masih banyak lagi. Ini semua sudah cukup untuk keperluan belajar mikrokontroler. Hanya dengan menghubungkan papan Arduino ke komputer melalui kabel USB, atau menggunakan adaptor AC-DC, atau menggunakan baterai untuk mengaktifkan papan Arduino. Arduino Leonardo \u00b6 Arduino Leonardo adalah tipe papan yang dikembangkan pertama kali oleh Arduino dengan menggunakan satu mikrokontroler dengan fungsi komunikasi USB yang terintegrasi didalamnya. Ini membuat Leonardo lebih sederhana dan lebih murah. Karena Leonardo dapat menanganai komunikasi USB secara langsung, kode perpustakaan yang tersedia pun memungkinkan Leonardo dapat meniru keyboard komputer, mouse dan masih banyak lagi. Arduino Mega \u00b6 Arduino Mega itu seperti halnya kakak UNO. Memiliki banyak (54) pin digital input/output (14 pin digunakan sebagai output PWM), 16 pin analog, koneksi USB, jack daya, tombol reset, dan masih banyak lagi. Ini merupakan papan lengkap yang diperlukan untuk mendukung pembelajaran mikrokontroler. Jumlah pin yang banyak membuat Arduino Mega digunakan untuk proyek-proyke yang memerlukan banyak input dan ouput digital. Bagian Pelengkap \u00b6 Jika anda sudah yakin dengan papan Arduino yang akan digunakan, maka selanjutnya adalah menentukan bagian pelengkap, karena papan Arduino tidak bisa berdiri sendiri tanpa sesuatu terpasang pada papan. Anda bisa menghubungkan sensor atau shield Arduino. Peralatan ini sangat berguna untuk digunakan pada proyek yang akan anda buat. Sensor \u00b6 dengan beberapa baris kode sederhana, Arduino dapat mengontrol dan berinteraksi dengan berbagai sensor, misalnya; pengukur intensitas cahaya, suhu, tekanan, akselerasi, kandungan karbon monoksida, aktifitas radioaktif, kelembaban, tekanan udara, dan mungkin suatu sensor yang bisa anda buat dan beri nama sendiri. Shield \u00b6 Selain sensor, ada juga yang sebut shield (marilah kita sebut dengan perisai). Pada dasarnya shield adalah papan rangkaian yang tidak belum disempurnakan atau dilengkapi secara keseluruhan dan dibuat dengan pin yang sesuai dengan papan Ardiuno agar mudah saat digunakan atau dihubungkan. Shield memberikan kemampuan tambahan seperti halnya; pengendari motor, menghubungkan dengan internet, komunikasi seluler, komunikasi nirkabel, mengontrol layar LCD dan masih banyak lagi shield dengan berbagai fungsi yang bisa dipilih sesuai dengan proyek yang akan anda buat. Untuk mengetahui lebih jauh tentang shield yang banyak digunakan para pengguna Arduino anda bisa memeriksanya pada situs ShieldList.org . Kesimpulan \u00b6 Penulis berharap sekarang anda mulai memahami tentang Arduino, keluarga Arduino, dan beberapa informasi tentang Arduino sebagai awalan untuk belajar tentang mikrokontroler. Ada ribuan sensor dan shield yang bisa anda manfaatkan untuk membantu proyek anda ke tingkat selanjutnya. Selamat belajar... Referensi \u00b6 Learn the basics Arduino Tutorials Beginner Arduino Learn Electronics and Microcontrollers Physical Computing The Complete Arduino Guide For Beginners The Absolute Beginner's Guide to Arduino","title":"Mengenal Arduino"},{"location":"papan/apa-itu-arduino/#mengenal-arduino","text":"Arduino merupakan salah satu platform mikrokontroler yang sangat populer akhir-akhir ini. Para pegiat mikrokontroler dari segala penjuru dunia sebagian besar terpusat untuk membahas pembahasan Arduino. Sifatnya yang Open Source Hardware membuatnya berkembang sangat pesat. Orang-orang begitu bersemangat untuk saling berbagi kode-kode yang sudah disusun oleh mereka untuk dibagikan keseluruh dunia. Selain itu, perangkat keras yang tersedia pun semakin melimpah dan semakin murah. Para pecinta mikrokontroler berlomba-lomba untuk membuat platform Arduino ini dengan berbagai fasilitas dan fungsi yang lebih namun dengan tetap menjualnya dengan harga murah. Setiap pecinta mikrokontroler diperbolehkan untuk membuat Arduino sesuai dengan selera dan kebutuhannya masing-masing, inilah yang membuat Arduini menjadi sangat menarik untuk dipelajari. Lalu apa Arduino?","title":"Mengenal Arduino"},{"location":"papan/apa-itu-arduino/#apa-itu-arduino","text":"Arduino adalah sebuah platform open source (sumber terbuka) yang digunakan untuk membuat proyek-proyek elektronika. Arduino terdiri dari dua bagian utama yaitu sebuah papan sirkuit fisik (sering disebut juga dengan mikrokontroler) dan sebuah perangkat lunak atau IDE (Integrated Development Environment) yang berjalan pada komputer. Perangkat lunak ini sering disebut Arduino IDE yang digunakan untuk menulis dan meng-upload kode dari komputer ke papan fisik (hardware) Arduino. Ketika membicarakan Arduino maka ada dua hal yang terlintas dalam pikiran para penggunanya, yaitu hardware dan software. Dua bagian ini seakan satu kesatuan utuh yang tidak bisa di pisahkan. Platform Arduino sekarang ini menjadi sangat populer dengan pertambahan jumlah pengguna baru yang terus meningkat. Hal ini karena kemudahannya dalam penggunaan dan penulisan kode. Tidak seperti kebanyakan papan sirkuit pemrograman sebelumnya, Arduino tidak lagi membutuhkan perangkat keras terpisah (disebut programmer atau downloader) untuk memuat atau meng-upload kode baru ke dalam mikrokontroler. Cukup dengan menggunakan kabel USB untuk mulai menggunakan Arduino. Selain itu, Arduino IDE menggunakan bahasa pemrograman C++ dengan versi yang telah disederhanakan, sehingga lebih mudah dalam belajar pemrograman. Arduino akhirnya berhasil menjadi papan sirkuit pemrograman paling disukai hingga menjadikannya sebagai bentuk standar dari fungsi mikrokontroler dengan paket yang mudah untuk diakses. Gambar diatas menunjukan papan Arduino Uno yang merupakan salah satu papan paling populer diantara keluarga Arduino dan papan ini merupakan pilihan yang sangat cocok bagi para pemula. Dan selanjutnya artikel ini akan membahas lebih dalam mengenai Arduino terutama Arduino Uno. Sebelum Arduino diciptakan, menulis kode mikrokontroler adalah hal yang sangat rumit dan memusingkan, tapi sekarang, hal yang sangat rumit itu menjadi lebih sederhana. Bahkan sebagian orang menyebutnya tidak mungkin, ketika hanya dengan 10 baris kode kita mampu membuat LED berkedip.","title":"Apa itu Arduino?"},{"location":"papan/apa-itu-arduino/#apa-itu-mikrokontroler","text":"Berbagai jenis komputer dirancang dan dibangun dengan tujuan berbeda. Komputer yang menjadi jantung laptop Anda dioptimalkan untuk tujuan berbeda dari apa yang ada didalam ponsel atau didalam mouse yang anda pegang sekarang. Komputer sederhana adalah perangkat yang dirancang untuk mengambil perangkat inpu (masukan) dari dunia fisik dan atau mengendalikan perangkat output (keluaran) di dunia fisik. Inilah yang disebut mikrokontroler. Sebagian perangkat elektronik yang ada sekarang ini memiliki mikrokontroler pada bagian intinya. Mikrokontroler yang dioptimalkan untuk mengendalikan input saja atau output saja. Mereka pada umumnya memiliki kemampuan komputasi yang rendah jika dibandingkan dengan prosesor yang digunakan pada komputer multimedia atau komputer server. Mikrokontroler membutuhkan daya yang lebih rendah dibanding prosesor lainnya dan lebih mudah untuk berinteraksi dengan dunia fisik melalui sirkuit input yang disebut sensor dan sirkuit output yang disebut aktuator. Mikrokontroler juga dapat berkomunikkasi dengan prosesor lain melalui berbagai antarmuka komunikasi (communication interface). Komputer, mikrokontroler, prosesor? Jadi yang mana? Kita sering mendengar istilah-istilah ini disebutkan silih berganti disekitar kita. Komputer dan Prosesor adalah istilah umum untuk apapun yang pada dasarnya mampu menjalankan program. Sedangkan Kontroler atau Mikrokontroler biasanya diperuntukan bagi prosesor sederhana yang hanya mampu menjalankan satu tugas saja, seperti membaca sensor.","title":"Apa Itu Mikrokontroler?"},{"location":"papan/apa-itu-arduino/#apa-yang-bisa-dilakukan-arduino","text":"Hardware dan software Arduino dirancang bagi para seniman, desainer, pe-hobi, hacker, pemula dan siapapun yang tertarik untuk menciptakan objek interaktif dan pengembangan lingkungan. Arduino mampu berinteraksi dengan tombol, LED, motor, speaker, GPS, kamera, internet, ponsel pintar bahkan dengan televisi anda. Fleksibilitas ini dihasilkan dari kombinasi ketersediaan software Arduino yang gratis, papan perangkat keras yang murah, dan keduanya yang mudah untuk dipelajari. Hal inilah yang menciptakan jumlah pengguna menjadi sebuah komunitas besar dengan berbagai kontribusinya yang telah dirilis pada berbagai proyek dengan berbasiskan Arduino. Jika Anda ingin mengetahui dimana kita bisa menemukan berbagai contoh proyek Arduino yang telah tercipta, dibawah ini adalah beberapa sumber daya yang bagus untuk proyek-proyek berbasis Arduino, yang bisa memicu cara berfikir Anda dan menggugah kreatifitas: Sparkfun Instructables Bildr Arduino Playground Adafruit Make Projects Dan tentu saja anda dapat menemukan banyak tutorial menarik disini di https://henduino.github.io/library/","title":"Apa Yang Bisa Dilakukan Arduino?"},{"location":"papan/apa-itu-arduino/#apa-yang-ada-pada-papan-arduino","text":"Ada banyak jenis papan Arduino yang dapat digunakan untuk tujuan yang berbeda. Beberapa papan memiliki ukuran, jumlah pin, mikrokontroler yang berbeda seperti pada gambar dibawah ini. Namun, sebagian besar Arduino memiliki komponen utama yang sama.","title":"Apa Yang Ada Pada Papan Arduino?"},{"location":"papan/apa-itu-arduino/#daya-usbbarrel-jack","text":"Setiap papan Arduino membutuhkan jalur untuk terhubung ke sumber listrik. Arduino Uno dapat diaktifkan melalui kable USB ang berasal dari komputer atau power supply terpisah yang dihubungkan ke Barrel Jack. Pada gambar diatas koneksi USB diberi label (1) dan Barrel Jack diberi label (2). Koneksi USB selain digunakan sebagai jalur listrik untuk mengaktifkan papan, juga digunakan untuk meng-upload kode dari komputer ke papan Arduino. Dua fungsi melalui satu jalur atau 2 in 1 (seperti iklan Shampo). Perhatian!: JANGAN menggunakan power supply lebih dari 20 Volt untuk mengaktifkan papan Arduino melalui Barrel Jack karena itu tegangan berlebihan yang cukup untuk menghacurkan papan Arduino Anda. Tegangan yang dianjurkan untuk sebagian besar keluarga Arduino adalah antara 6 Volt sampai dengan 12 Volt.","title":"Daya (USB/Barrel Jack)"},{"location":"papan/apa-itu-arduino/#pin-5v-33v-gnd-analog-digital-pwm-aref","text":"Pin pada Arduino adalah tempat dimana kita menghubungkan kabel untuk membuat suatu rangkaian (menghubungkan satu titik dengan titik lainnya pada breadboard dengan sejumlah kabel penghubung). Kabel penghubung (jumper wire) yang digunakan dalam membuat rangkaian biasanya memiliki kepala yang terbuat dari plastik berwarna hitam yang memungkin kawat dari kabel penghubungnya saja yang terhubung langsung ke papan. Arduino memiliki beberapa jenis pin yang masing-masing diberi label pada papan dan digunakan untuk fungsi yang berbeda-beda. GND (3) : GND merupakan singkatan dari GROUND. Ada beberapa pin GND pada Arduino, dan semuanya dapat digunakan untuk hubungan ke ground. 5V (4) dan 3.3V (5) : Pin 5V digunakan untuk menyediakan tegangan sebesar 5 volt. Sedangkan pin 3.3V digunakan untuk menyediakan tegangan 3,3 volt. Sebagian besar komponen sederhana yang digunakan bersama dengan Arduino berjalan pada kisaran tegangan 3,3 volt hingga 5 volt. Analog (6) : Pin yang berada pada area berlabel \"ANALOG IN\" (A0 sampai A5 pada Arduino Uno) digunakan sebagai pin analog. Yaitu pin yang digunakan untuk membaca sinyal-sinyal analog dari sensor-sensor analog (misal; sensor suhu) dan mengubahnya menjadi nilai digital yang dapat kita baca. Digital (7) : Pin digital berada diseberang pin analog (0 sampai 13 pada Arduino Uno). Pin ini dapat digunakan dalam 2 arah digital yaitu input digital (misal untuk melihat kondisi bahwa tombol sedang ditekan) dan output digital (memberikan tegangan sebuah LED). PWM (8) : Perhatikanlah simbol tilde (~) disamping beberapa pin digital (yaitu pada pin 3, 5, 6, 9, 10 dan 11 pada Arduino Uno). Pin ini dapat digunakan sebagai pin digital biasa, tetapi juga dapat digunakan sebagai pin PWM (Pulse Width Modulation). PWM biasanya digunakan sebagai pin yang mampu mensimulasikan output analog (seperti mengatur pemudaran cahaya dan warna LED saat datang dan pergi). PWM bukan analog, hanya mampu mensimulasikan analog saja. Jadi tidaklah sama antara analog dengan PWM. (Bahasan di artikel lain). AREF (9) : Kepanjangan dari Analog Reference atau Referensi Analog. Selama belajar, tinggalkan saja pin ini. Pin ini terkadang digunakan sebagai referensi dalam mengatur tegangan eksternal (antara 0 sampai 5 volt) untuk memberikan limit (batasan akhir) pada input pin analog.","title":"Pin (5V, 3.3V, GND, Analog, Digital, PWM, AREF)"},{"location":"papan/apa-itu-arduino/#tombol-reset","text":"Menekan tombol Reset (10) beberapa saat pada papan Arduino akan menghubungkan pin Reset ke Ground. Ini digunakan untuk me-restart kode yang telah dimuat oleh Arduino. Ini sangat bermanfaat untuk menguji ulang kode, jika kode tersebut ditulis tanpa pengulangan (repeat) atau sekali jalan. Jika anda pernah menggunakan Nintendo pasti tahu fungsi tombol Reset ini. Pada Nintendo ketika menekan tombol Reset maka hal itu digunakan untuk memperbaiki masalah, tetapi tidak demikian pada Arduino.","title":"Tombol Reset"},{"location":"papan/apa-itu-arduino/#led-indikator-daya","text":"Tepat di bawah dan di sebelah kanan kata \"UNO\" pada papan Arduino Uno, terdapat sebuah LED kecil berlabel \"ON\" (11). LED ini harus menyala setiap kita mengubungkan papan Arduino pada sumber listrik. Jika lampu LED ini tidak menyala, kemungkinan ada papan mengalami kerusakan atau terjadi kesalahan. Periksa ulang rankaian yang anda buat.","title":"LED Indikator Daya"},{"location":"papan/apa-itu-arduino/#tx-rx-led","text":"TX adalah singkatan dari 'transmit' (kirim), dan RX adalah singkatan dari 'receive' (terima). LED indikator TX dan RX (12) ini akan berkedip redup atau terang dengan jeda tak tentu untuk memberitahukan bahwa telah terjadi komunikasi serial. Kedipan LED ini sebagai indikasi visual yang merupakan pertanda baik bahwa telah terjadi pengiriman dan penerimaan data pada papan Arduino (misal ketika kita meng-upload kode baru ke dalam papan).","title":"TX RX LED"},{"location":"papan/apa-itu-arduino/#ic-utama","text":"Sesuatu yang berwarna hitam dengan semua kakinya terbuat dari logam inilah yang sebut IC atau Integrated Circuit (13). Ini adalah otak dari papan Arduino. IC utama Arduino berbeda-beda sesuai dengan jenis papan, tetapi biasanya memiliki ciri khas bertuliskan ATmega yang merupakan IC buatan perusahaan ATMEL. Ini merupakan hal penting, karena kita perlu untuk memahami jenis IC (sesuai juga dengan jenis papan Arduino) sebelum memuat atau meng-upload sekumpulan kode program yang telah kita buat dari perangkat lunak Arduino IDE kedalam papan Arduino. Informasi tentang tipe IC dapat kita temukan pada permukaan IC tersebut. Jika kita ingin tahu lebih jauh tentang perbedaan jenis IC yang digunakan pada keluarga Arduino maka sebaiknya selalu unduh datasheet dari masing-masing tipe IC.","title":"IC Utama"},{"location":"papan/apa-itu-arduino/#regulator-tegangan","text":"Voltage Regulator (14) bukanlah sesuatu yang mampu berinteraksi dengan papan Arduino. Tetapi kita harus mengetahui fungsi dari voltage regulator. Voltage Regulator atau Regulator Tegangan akan mengalirkan sejumlah tegangan teregulati ke dalam papan Arduino. Voltage Regulator berperan sebagai penjaga pintu gerbang, dia akan membalikan atau membuang tegangan berlebihan yang bisa membahayan rangkaian. Tapi tentu saja ada batasnya, pastikan bahwa tegangan yang masuk ke dalam papan tidak lebih besar dari 20 volt.","title":"Regulator Tegangan"},{"location":"papan/apa-itu-arduino/#keluarga-arduino","text":"Perusahaan Arduino telah membuat beberapa tipe papan yang berbeda-beda, masing-masing tipe tersebut memiliki kemampuan yang berbeda pula. Selain itu, Arduino merupakan Open Source Hardware yang berarti bahwa siapa saja dapat memodifikasi dan menghasilkan turunan Arduino dengan bentuk dan fungsi yang lebih beragam. Jika Anda belum begitu paham mengenai papan Arduino, berikut adalah beberapa pilihan yang cocok untuk mereka yang baru saja ingin berkenalan dengan Arduino.","title":"Keluarga Arduino"},{"location":"papan/apa-itu-arduino/#arduino-uno-r3","text":"Arduino Uno adalah pilihan yang tepat bagi mereka yang baru pertama kali ingin mempelajari Arduino. Karena Uno merupakan paket lengkap untuk memulai belajar Arduino. Memiliki 14 pin input/output digital (dimana 6 pin dapat digunakan sebagai output PWM), 6 pin input analog, koneksi USB, jack daya, tombol reset, dan masih banyak lagi. Ini semua sudah cukup untuk keperluan belajar mikrokontroler. Hanya dengan menghubungkan papan Arduino ke komputer melalui kabel USB, atau menggunakan adaptor AC-DC, atau menggunakan baterai untuk mengaktifkan papan Arduino.","title":"Arduino Uno (R3)"},{"location":"papan/apa-itu-arduino/#arduino-leonardo","text":"Arduino Leonardo adalah tipe papan yang dikembangkan pertama kali oleh Arduino dengan menggunakan satu mikrokontroler dengan fungsi komunikasi USB yang terintegrasi didalamnya. Ini membuat Leonardo lebih sederhana dan lebih murah. Karena Leonardo dapat menanganai komunikasi USB secara langsung, kode perpustakaan yang tersedia pun memungkinkan Leonardo dapat meniru keyboard komputer, mouse dan masih banyak lagi.","title":"Arduino Leonardo"},{"location":"papan/apa-itu-arduino/#arduino-mega","text":"Arduino Mega itu seperti halnya kakak UNO. Memiliki banyak (54) pin digital input/output (14 pin digunakan sebagai output PWM), 16 pin analog, koneksi USB, jack daya, tombol reset, dan masih banyak lagi. Ini merupakan papan lengkap yang diperlukan untuk mendukung pembelajaran mikrokontroler. Jumlah pin yang banyak membuat Arduino Mega digunakan untuk proyek-proyke yang memerlukan banyak input dan ouput digital.","title":"Arduino Mega"},{"location":"papan/apa-itu-arduino/#bagian-pelengkap","text":"Jika anda sudah yakin dengan papan Arduino yang akan digunakan, maka selanjutnya adalah menentukan bagian pelengkap, karena papan Arduino tidak bisa berdiri sendiri tanpa sesuatu terpasang pada papan. Anda bisa menghubungkan sensor atau shield Arduino. Peralatan ini sangat berguna untuk digunakan pada proyek yang akan anda buat.","title":"Bagian Pelengkap"},{"location":"papan/apa-itu-arduino/#sensor","text":"dengan beberapa baris kode sederhana, Arduino dapat mengontrol dan berinteraksi dengan berbagai sensor, misalnya; pengukur intensitas cahaya, suhu, tekanan, akselerasi, kandungan karbon monoksida, aktifitas radioaktif, kelembaban, tekanan udara, dan mungkin suatu sensor yang bisa anda buat dan beri nama sendiri.","title":"Sensor"},{"location":"papan/apa-itu-arduino/#shield","text":"Selain sensor, ada juga yang sebut shield (marilah kita sebut dengan perisai). Pada dasarnya shield adalah papan rangkaian yang tidak belum disempurnakan atau dilengkapi secara keseluruhan dan dibuat dengan pin yang sesuai dengan papan Ardiuno agar mudah saat digunakan atau dihubungkan. Shield memberikan kemampuan tambahan seperti halnya; pengendari motor, menghubungkan dengan internet, komunikasi seluler, komunikasi nirkabel, mengontrol layar LCD dan masih banyak lagi shield dengan berbagai fungsi yang bisa dipilih sesuai dengan proyek yang akan anda buat. Untuk mengetahui lebih jauh tentang shield yang banyak digunakan para pengguna Arduino anda bisa memeriksanya pada situs ShieldList.org .","title":"Shield"},{"location":"papan/apa-itu-arduino/#kesimpulan","text":"Penulis berharap sekarang anda mulai memahami tentang Arduino, keluarga Arduino, dan beberapa informasi tentang Arduino sebagai awalan untuk belajar tentang mikrokontroler. Ada ribuan sensor dan shield yang bisa anda manfaatkan untuk membantu proyek anda ke tingkat selanjutnya. Selamat belajar...","title":"Kesimpulan"},{"location":"papan/apa-itu-arduino/#referensi","text":"Learn the basics Arduino Tutorials Beginner Arduino Learn Electronics and Microcontrollers Physical Computing The Complete Arduino Guide For Beginners The Absolute Beginner's Guide to Arduino","title":"Referensi"},{"location":"papan/mengenal-arduino-leonardo/","text":"Mengenal Arduino Leonardo \u00b6 Arduino Leonardo adalah papan mikrokontroler berbasis ATmega32u4 (datasheet ATmega32U4) . Arduino Leonardo memiliki 20 digital pin input/output (yang mana 7 pin dapat digunakan sebagai output PWM dan 12 pin sebagai input analog), 16 MHz kristal osilator, koneksi micro USB, jack power suplai tegangan, header ICSP, dan tombol reset. Ini semua yang diperlukan untuk mendukung mikrokontroler. Cukup dengan menghubungkannya ke komputer melalui kabel USB atau power dihubungkan dengan adaptor AC-DC atau baterai untuk mulai mengaktifkannya. Leonardo berbeda dari semua papan Arduino yang lainnya karena ATmega32u4 secara terintegrasi ( built-in ) telah memiliki komunikasi USB, sehingga tidak lagi membutuhkan prosesor sekunder (tanpa chip ATmega16U2 sebagai konverter USB-to-serial). Hal ini memungkinkan Arduino Leonardo yang terhubung ke komputer digunakan sebagai mouse dan keyboard, selain bisa digunakan sebagai virtual (CDC) serial/COM port. Spesifikasi \u00b6 Dibawah ini spesifikasi sederhana dari Arduino Leonardo: Info Spesifikasi Mikrokontroler >ATmega32u4 Tegangan Operasi 5V Input Voltage (disarankan) 7-12V Input Voltage (limit) 6-20V Digital I/O Pins 20 pin Channel PWM 7 pin Input Analog 12 pin Arus DC per pin I/O 40 mA Arus DC untuk pin 3.3V 50 mA Flash Memory 32 KB (ATmega32u4) 4 KB digunakan bootloader SRAM 2.5 KB (ATmega32u4) EEPROM 1 KB (ATmega32u4) Clock Speed 16 MHz Skema & Referensi Desain \u00b6 Dibawah ini file skema dan desain PCB untuk Arduino Leonardo: Skema Arduino Leonardo (EagleCAD): Arduino-leonardo-referensi-design.zip Skema Arduino Leonardo (PDF): Arduino-leonardo-skema-rev3b.pdf Untuk membuka file EagleCAD disarankan menggunakan EagleCAD versi 6.0 keatas Sumber Daya (Tegangan) \u00b6 Arduino Leonardo dapat diaktifkan melalui koneksi USB mikro atau dengan catu daya eksternal. Sumber daya dipilih secara otomatis. Sumber daya Eksternal (non-USB) dapat berasal baik dari adaptor AC-DC atau baterai. Adaptor dapat dihubungkan dengan mencolokkan steker 2.1 mm denan pusat-positif ke jack power pada papan. Sumber tegangan dari baterai dapat dihubungkan ke header pin Gnd dan Vin pin sebagai konektor sumber daya tegangan papan. Papan Arduino Leonardo dapat beroperasi dengan pasokan daya eksternal 6 Volt sampai 20 volt. Jika diberi tegangan kurang dari 7 Volt, maka, pin 5 Volt mungkin akan menghasilkan tegangan kurang dari 5 Volt dan ini akan membuat papan menjadi tidak stabil. Jika sumber tegangan menggunakan lebih dari 12 Volt, regulator tegangan akan mengalami panas berlebihan dan bisa merusak papan. Rentang sumber tegangan yang dianjurkan adalah 7 Volt sampai 12 Volt. Pin tegangan yang tersedia pada papan Arduino Leonardo adalah sebagai berikut: VIN : Adalah input tegangan untuk papan Arduino ketika menggunakan sumber daya eksternal (sebagai 'saingan' tegangan 5 Volt dari koneksi USB atau sumber daya ter-regulator lainnya). Anda dapat memberikan tegangan melalui pin ini, atau jika memasok tegangan untuk papan melalui jack power, kita bisa mengakses/mengambil tegangan melalui pin ini. 5V : Tegangan listrik ter-regulator yang digunakan untuk daya mikrokontroler dan komponen lainnya pada papan Arduino. Tegangan dapat menggunakan pin VIN melalui regulator on-board, atau dipasok oleh USB atau power suplai lain dengan besar tegangan 5V ter-regulator. 3V3 : Sebuah pin yang menghasilkan tegangan 3,3 Volt. Tegangan ini dihasilkan oleh regulator yang terdapat pada papan (on-board). Arus maksimum yang dihasilkan adalah 50 mA. GND : Pin Ground atau Massa. IOREF : Pin ini pada papan Arduino berfungsi untuk memberikan referensi tegangan yang beroperasi pada mikrokontroler (atau VCC untuk papan). Pin ini bertegangan 5V pada Leonardo. Memori \u00b6 ATmega32u4 memiliki memori sebesar 32 KB (4 KB digunakan untuk bootloader). Juga memiliki 2,5 KB SRAM dan 1 KB EEPROM (yang dapat dibaca dan ditulis dengan perpustakaan EEPROM). Input dan Output \u00b6 20 pin digital I/O pada Leonardo dapat digunakan sebagai input atau output, menggunakan fungsi pinMode () , digitalWrite () , dan digitalRead ( . Mereka beroperasi pada tegangan 5 volt. Setiap pin dapat memberikan atau menerima maksimum 40 mA dan memiliki resistor pull-up internal sebesar 20-50 kOhm yang terputus secara default. Selain itu, beberapa pin memiliki fungsi khusus, yaitu: Serial : Pin 0 (RX) dan pin 1 (TX). Digunakan untuk menerima (RX) dan mengirimkan (TX) data serial TTL menggunakan hardware ATmega32U4 yang memiliki kemampuan serial didalamnya. Perhatikan bahwa pada Leonardo, kelas Serial mengacu pada komunikasi USB (CDC); untuk TTL serial pada pin 0 dan 1, menggunakan kelas Serial 1. TWI : Pin 2 (SDA) dan pin 3 (SCL). Dukungan komunikasi TWI menggunakan perpustakaan Wire. Eksternal Interupsi : Pin 3 (interrupt 0), pin 2 (interrupt 1), pin 0 (interrupt 2), pin 1 (interrupt 3) dan pin 7 (interrupt 4). Pin ini dapat dikonfigurasi untuk memicu sebuah interupsi pada nilai yang rendah, meningkat atau menurun, atau merubah nilai. PWM : Pin 3, 5, 6, 9, 10, 11, dan 13. Menyediakan 8-bit output PWM dengan fungsi analogWrite () . SPI : Pin pada header ICSP ini mendukung komunikasi SPI menggunakan perpustakaan SPI. Perhatikan bahwa pin SPI tidak terhubung ke salah satu pun pin digital I/O karena yang terhubung langsung hanya pada Arduino Uno, Mereka hanya menyediakan konektor ICSP. Ini berarti bahwa jika Anda memiliki shield yang menggunakan SPI, tetapi tidak terdapat 6 pin konektor ICSP yang terhubung ke 6 pin ICSP header Leonardo, maka shield tidak akan bekerja. LED : Pin 13. Tersedia secara built-in pada papan Arduino ATmega2560. LED terhubung ke pin digital 13. Ketika pin diset bernilai HIGH, maka LED menyala (ON), dan ketika pin diset bernilai LOW, maka LED padam (OFF). Input Analog : Pin A0-A5, Pin A6 - A11 (pada pin digital 4, 6, 8, 9, 10, dan 12). Leonardo memiliki 12 input analog, berlabel A0 sampai A11, yang semuanya juga dapat digunakan sebagai digital I/O. Pin A0-A5 terdapat di lokasi yang sama seperti pada Arduino Uno; Pin input A6-A11 masing-masing ada pada digital I/O pin 4, 6, 8, 9, 10, dan 12. Masing-masing pin menyediakan resolusi 10 bit (yaitu 1024 nilai yang berbeda). Secara default pin ini dapat diukur/diatur dari mulai Ground sampai dengan 5 Volt, juga memungkinkan untuk mengubah titik jangkauan tertinggi atau terendah mereka menggunakan pin AREF dan fungsi analogReference () . Masih ada beberapa pin lainnya pada Arduino Leonardo, yaitu: AREF : Referensi tegangan untuk input analog. Digunakan dengan fungsi analogReference () . RESET : Jalur LOW ini digunakan untuk me-reset (menghidupkan ulang) mikrokontroler. Jalur ini biasanya digunakan untuk menambahkan tombol reset pada shield yang menghalangi papan utama Arduino. Gambar 1. Arduino Leonardo dari Atas Pemetaaan \u00b6 Dibawah ini pemetaan Pin ATmega32U4 dan Pin Arduino Leonardo: Gambar 2. Pemetaan Pin ATmega32U4 Pin Number Pin Name Mapped Pin Name 1 PE6 (INT.6/AIN0) Digital pin 7 2 UVcc +5V 3 D- RD- 4 D+ RD+ 5 UGnd UGND 6 UCap UCAP 7 VUSB VBus 8 (SS/PCINT0) PB0 RXLED 9 (PCINT1/SCLK) PB1 SCK 10 (PDI/PCINT2/MOSI) PB2 MOSI 11 (PDO/PCINT3/MISO) PB3 MISO 12 (PCINT7/OCA0/OC1C/#RTS) PB7 Digital pin 11 (PWM) 13 RESET RESET 14 Vcc +5V 15 GND GND 16 XTAL2 XTAL2 17 XTAL1 XTAL1 18 (OC0B/SCL/INT0) PD0 Digital pin 3 (SCL)(PWM) 19 (SDA/INT1) PD1 Digital pin 2 (SDA) 20 (RX D1/AIN1/INT2) PD2 Digital pin 0 (RX) 21 (TXD1/INT3) PD3 Digital pin 1 (TX) 22 (XCK1/#CTS) PD5 TXLED 23 GND1 GND 24 AVCC AVCC 25 (ICP1/ADC8) PD4 Digital pin 4 26 (T1/#OC4D/ADC9) PD6 Digital pin 12 27 (T0/OC4D/ADC10) PD7 Digital Pin 6 (PWM) 28 (ADC11/PCINT4) PB4 Digital pin 8 29 (PCINT5/OC1A/#OC4B/ADC12) PB5 Digital Pin 9 (PWM) 30 (PCINT6/OC1B/OC4B/ADC13) PB6 Digital Pin 10 (PWM) 31 (OC3A/#0C4A) PC6 Digital Pin 5 (PWM) 32 (ICP3/CLK0/)C4A) PC7 Digital Pin 13 (PWM) 33 (#HWB) PE2 HWB 34 Vcc1 +5V 35 GND2 GND 36 (ADC7/TDI) PF7 Analog In 0 37 (ADC6/TDO) PF6 Analog In 1 38 (ADC5/TMS) PF5 Analog In 2 39 (ADC4/TCK) PF4 Analog In 3 40 (ADC1) PF1 Analog In 4 41 (ADC0) PF0 Analog In 5 42 AREF AEF 43 GND3 GND 44 AVCC1 AVCC Komunikasi \u00b6 Leonardo memiliki sejumlah fasilitas untuk berkomunikasi dengan komputer, dengan Arduino lain, atau dengan mikrokontroler lainnya. ATmega32U4 mampu menyediakan komunikasi serial UART TTL (5V), yang tersedia pada pin digital 0 (RX) dan 1 (TX). ATmega32U4 juga memungkinkan untuk komunikasi serial (CDC) melalui USB dan muncul sebagai com port virtual pada perangkat lunak komputer. Chip ini juga bertindak sebagai perangkat USB 2.0 dengan kecepatan tinggi, serta menggunakan standar driver USB COM, tetapi ntuk sistem operasi Windows masih tetap memerlukan file inf. Perangkat lunak Arduino termasuk didalamnya serial monitor memungkinkan data tekstual sederhana dikirim ke dan dari papan Arduino. LED RX dan TX yang tersedia pada papan akan berkedip ketika data sedang dikirim atau diterima melalui chip USB-to-serial yang terhubung melalui USB komputer (tetapi tidak untuk komunikasi serial seperti pada pin 0 dan 1). Sebuah perpustakaan SoftwareSerial memungkinkan komunikasi serial pada beberapa pin digital Leonardo. ATmega32U4 juga mendukung komunikasi I2C (TWI) dan SPI. Perangkat lunak Arduino termasuk perpustakaan Wire digunakan untuk menyederhanakan penggunaan bus I2C. Untuk komunikasi SPI, menggunakan perpustakaan SPI. Leonardo muncul pada komputer sebagai keyboard dan mouse generik, dan dapat diprogram untuk mengontrol perangkat input menggunakan kelas/kelompok Keyboard dan Mouse. Pemrograman \u00b6 Arduino Mega dapat diprogram dengan software Arduino (Unduh perangkat lunak Arduino) . (Mengenai pemahasan lebih rinci tentang perangkat lunak Arduino akan dibahas pada artikel terpisah). ATmega32U4 pada Arduino Leonardo sudah tersedia preburned dengan bootloader ( preburned dan bootloader apa bahasa Indonesianya?) yang memungkinkan Anda untuk meng-upload kode baru tanpa menggunakan programmer hardware eksternal. Hal ini karena komunikasi yang terjadi menggunakan protokol AVR109. Anda juga dapat melewati ( bypass ) bootloader dan program mikrokontroler melalui pin header ICSP ( In-Circuit Serial Programming ). Reset (Software) Otomatis dan Inisiasi Bootloader \u00b6 Daripada menekan tombol reset sebelum upload, Arduino Leonardo didesain dengan cara yang memungkinkan Anda untuk me-reset melalui perangkat lunak yang berjalan pada komputer yang terhubung. Reset dipicu ketika virtual (CDC) port serial/COM Leonardo dibuka pada 1200 baud dan kemudian ditutup. Ketika ini terjadi, prosesor akan mengatur ular (reset), memutuskan hubungan koneksi USB ke komputer (virtual port serial/COM akan hilang dari komputer). Setelah prosesor melakukan reset, bootlader akan dimuat, yang akan segera aktif dalam waktu sekitar 8 detik. Bootloader juga dapat dimuat dengan menekan tombol Reset pada Leonardo. Perhatikan bahwa ketika pertama kali papan diaktifkan, ia akan melompat langsung ke sketch, jika tersedia, dari pada harus memuat bootloader. Karena itu metode yang terbaik untuk melakukan reset pada Leonardo adalah dengan membiarkan software arduino melakukan reset sebelum upload sketch, terutama bagi mereka yang terbiasa menekan tombol reset sebelum melakukan upload. Jika software Arduino tidak dapat melakukan reset terhadap papan, kita bisa memulai bootloader dengan menekan tombol reset yang tersedia pada papan. Perlindungan Beban Berlebih pada USB \u00b6 Arduino Leonardo memiliki polyfuse reset yang melindungi port USB komputer Anda dari hubungan singkat dan arus lebih. Meskipun pada dasarnya komputer telah memiliki perlindungan internal pada port USB mereka sendiri, sekring memberikan lapisan perlindungan tambahan. Jika arus lebih dari 500 mA dihubungkan ke port USB, sekring secara otomatis akan memutuskan sambungan sampai hubungan singkat atau overload dihapus/dibuang. Karakteristik Fisik \u00b6 Maksimum panjang dan lebar PCB Arduino Leonardo sama dengan Arduino Uno yaitu 2.7 x 2.1 inch (6,8 x 5,3 cm), dengan konektor USB dan jack power menonjol melampaui batas dimensi. Empat lubang sekrup memungkinkan papan terpasang pada suatu permukaan atau wadah. Perhatikan bahwa jarak antara pin digital 7 dan 8 adalah 160 mil (0.16 inch), tidak seperti pin lainnya dengan kelipatan genap berjarak 100 mil.","title":"Mengenal Arduino Leonardo"},{"location":"papan/mengenal-arduino-leonardo/#mengenal-arduino-leonardo","text":"Arduino Leonardo adalah papan mikrokontroler berbasis ATmega32u4 (datasheet ATmega32U4) . Arduino Leonardo memiliki 20 digital pin input/output (yang mana 7 pin dapat digunakan sebagai output PWM dan 12 pin sebagai input analog), 16 MHz kristal osilator, koneksi micro USB, jack power suplai tegangan, header ICSP, dan tombol reset. Ini semua yang diperlukan untuk mendukung mikrokontroler. Cukup dengan menghubungkannya ke komputer melalui kabel USB atau power dihubungkan dengan adaptor AC-DC atau baterai untuk mulai mengaktifkannya. Leonardo berbeda dari semua papan Arduino yang lainnya karena ATmega32u4 secara terintegrasi ( built-in ) telah memiliki komunikasi USB, sehingga tidak lagi membutuhkan prosesor sekunder (tanpa chip ATmega16U2 sebagai konverter USB-to-serial). Hal ini memungkinkan Arduino Leonardo yang terhubung ke komputer digunakan sebagai mouse dan keyboard, selain bisa digunakan sebagai virtual (CDC) serial/COM port.","title":"Mengenal Arduino Leonardo"},{"location":"papan/mengenal-arduino-leonardo/#spesifikasi","text":"Dibawah ini spesifikasi sederhana dari Arduino Leonardo: Info Spesifikasi Mikrokontroler >ATmega32u4 Tegangan Operasi 5V Input Voltage (disarankan) 7-12V Input Voltage (limit) 6-20V Digital I/O Pins 20 pin Channel PWM 7 pin Input Analog 12 pin Arus DC per pin I/O 40 mA Arus DC untuk pin 3.3V 50 mA Flash Memory 32 KB (ATmega32u4) 4 KB digunakan bootloader SRAM 2.5 KB (ATmega32u4) EEPROM 1 KB (ATmega32u4) Clock Speed 16 MHz","title":"Spesifikasi"},{"location":"papan/mengenal-arduino-leonardo/#skema-referensi-desain","text":"Dibawah ini file skema dan desain PCB untuk Arduino Leonardo: Skema Arduino Leonardo (EagleCAD): Arduino-leonardo-referensi-design.zip Skema Arduino Leonardo (PDF): Arduino-leonardo-skema-rev3b.pdf Untuk membuka file EagleCAD disarankan menggunakan EagleCAD versi 6.0 keatas","title":"Skema &amp; Referensi Desain"},{"location":"papan/mengenal-arduino-leonardo/#sumber-daya-tegangan","text":"Arduino Leonardo dapat diaktifkan melalui koneksi USB mikro atau dengan catu daya eksternal. Sumber daya dipilih secara otomatis. Sumber daya Eksternal (non-USB) dapat berasal baik dari adaptor AC-DC atau baterai. Adaptor dapat dihubungkan dengan mencolokkan steker 2.1 mm denan pusat-positif ke jack power pada papan. Sumber tegangan dari baterai dapat dihubungkan ke header pin Gnd dan Vin pin sebagai konektor sumber daya tegangan papan. Papan Arduino Leonardo dapat beroperasi dengan pasokan daya eksternal 6 Volt sampai 20 volt. Jika diberi tegangan kurang dari 7 Volt, maka, pin 5 Volt mungkin akan menghasilkan tegangan kurang dari 5 Volt dan ini akan membuat papan menjadi tidak stabil. Jika sumber tegangan menggunakan lebih dari 12 Volt, regulator tegangan akan mengalami panas berlebihan dan bisa merusak papan. Rentang sumber tegangan yang dianjurkan adalah 7 Volt sampai 12 Volt. Pin tegangan yang tersedia pada papan Arduino Leonardo adalah sebagai berikut: VIN : Adalah input tegangan untuk papan Arduino ketika menggunakan sumber daya eksternal (sebagai 'saingan' tegangan 5 Volt dari koneksi USB atau sumber daya ter-regulator lainnya). Anda dapat memberikan tegangan melalui pin ini, atau jika memasok tegangan untuk papan melalui jack power, kita bisa mengakses/mengambil tegangan melalui pin ini. 5V : Tegangan listrik ter-regulator yang digunakan untuk daya mikrokontroler dan komponen lainnya pada papan Arduino. Tegangan dapat menggunakan pin VIN melalui regulator on-board, atau dipasok oleh USB atau power suplai lain dengan besar tegangan 5V ter-regulator. 3V3 : Sebuah pin yang menghasilkan tegangan 3,3 Volt. Tegangan ini dihasilkan oleh regulator yang terdapat pada papan (on-board). Arus maksimum yang dihasilkan adalah 50 mA. GND : Pin Ground atau Massa. IOREF : Pin ini pada papan Arduino berfungsi untuk memberikan referensi tegangan yang beroperasi pada mikrokontroler (atau VCC untuk papan). Pin ini bertegangan 5V pada Leonardo.","title":"Sumber Daya (Tegangan)"},{"location":"papan/mengenal-arduino-leonardo/#memori","text":"ATmega32u4 memiliki memori sebesar 32 KB (4 KB digunakan untuk bootloader). Juga memiliki 2,5 KB SRAM dan 1 KB EEPROM (yang dapat dibaca dan ditulis dengan perpustakaan EEPROM).","title":"Memori"},{"location":"papan/mengenal-arduino-leonardo/#input-dan-output","text":"20 pin digital I/O pada Leonardo dapat digunakan sebagai input atau output, menggunakan fungsi pinMode () , digitalWrite () , dan digitalRead ( . Mereka beroperasi pada tegangan 5 volt. Setiap pin dapat memberikan atau menerima maksimum 40 mA dan memiliki resistor pull-up internal sebesar 20-50 kOhm yang terputus secara default. Selain itu, beberapa pin memiliki fungsi khusus, yaitu: Serial : Pin 0 (RX) dan pin 1 (TX). Digunakan untuk menerima (RX) dan mengirimkan (TX) data serial TTL menggunakan hardware ATmega32U4 yang memiliki kemampuan serial didalamnya. Perhatikan bahwa pada Leonardo, kelas Serial mengacu pada komunikasi USB (CDC); untuk TTL serial pada pin 0 dan 1, menggunakan kelas Serial 1. TWI : Pin 2 (SDA) dan pin 3 (SCL). Dukungan komunikasi TWI menggunakan perpustakaan Wire. Eksternal Interupsi : Pin 3 (interrupt 0), pin 2 (interrupt 1), pin 0 (interrupt 2), pin 1 (interrupt 3) dan pin 7 (interrupt 4). Pin ini dapat dikonfigurasi untuk memicu sebuah interupsi pada nilai yang rendah, meningkat atau menurun, atau merubah nilai. PWM : Pin 3, 5, 6, 9, 10, 11, dan 13. Menyediakan 8-bit output PWM dengan fungsi analogWrite () . SPI : Pin pada header ICSP ini mendukung komunikasi SPI menggunakan perpustakaan SPI. Perhatikan bahwa pin SPI tidak terhubung ke salah satu pun pin digital I/O karena yang terhubung langsung hanya pada Arduino Uno, Mereka hanya menyediakan konektor ICSP. Ini berarti bahwa jika Anda memiliki shield yang menggunakan SPI, tetapi tidak terdapat 6 pin konektor ICSP yang terhubung ke 6 pin ICSP header Leonardo, maka shield tidak akan bekerja. LED : Pin 13. Tersedia secara built-in pada papan Arduino ATmega2560. LED terhubung ke pin digital 13. Ketika pin diset bernilai HIGH, maka LED menyala (ON), dan ketika pin diset bernilai LOW, maka LED padam (OFF). Input Analog : Pin A0-A5, Pin A6 - A11 (pada pin digital 4, 6, 8, 9, 10, dan 12). Leonardo memiliki 12 input analog, berlabel A0 sampai A11, yang semuanya juga dapat digunakan sebagai digital I/O. Pin A0-A5 terdapat di lokasi yang sama seperti pada Arduino Uno; Pin input A6-A11 masing-masing ada pada digital I/O pin 4, 6, 8, 9, 10, dan 12. Masing-masing pin menyediakan resolusi 10 bit (yaitu 1024 nilai yang berbeda). Secara default pin ini dapat diukur/diatur dari mulai Ground sampai dengan 5 Volt, juga memungkinkan untuk mengubah titik jangkauan tertinggi atau terendah mereka menggunakan pin AREF dan fungsi analogReference () . Masih ada beberapa pin lainnya pada Arduino Leonardo, yaitu: AREF : Referensi tegangan untuk input analog. Digunakan dengan fungsi analogReference () . RESET : Jalur LOW ini digunakan untuk me-reset (menghidupkan ulang) mikrokontroler. Jalur ini biasanya digunakan untuk menambahkan tombol reset pada shield yang menghalangi papan utama Arduino. Gambar 1. Arduino Leonardo dari Atas","title":"Input dan Output"},{"location":"papan/mengenal-arduino-leonardo/#pemetaaan","text":"Dibawah ini pemetaan Pin ATmega32U4 dan Pin Arduino Leonardo: Gambar 2. Pemetaan Pin ATmega32U4 Pin Number Pin Name Mapped Pin Name 1 PE6 (INT.6/AIN0) Digital pin 7 2 UVcc +5V 3 D- RD- 4 D+ RD+ 5 UGnd UGND 6 UCap UCAP 7 VUSB VBus 8 (SS/PCINT0) PB0 RXLED 9 (PCINT1/SCLK) PB1 SCK 10 (PDI/PCINT2/MOSI) PB2 MOSI 11 (PDO/PCINT3/MISO) PB3 MISO 12 (PCINT7/OCA0/OC1C/#RTS) PB7 Digital pin 11 (PWM) 13 RESET RESET 14 Vcc +5V 15 GND GND 16 XTAL2 XTAL2 17 XTAL1 XTAL1 18 (OC0B/SCL/INT0) PD0 Digital pin 3 (SCL)(PWM) 19 (SDA/INT1) PD1 Digital pin 2 (SDA) 20 (RX D1/AIN1/INT2) PD2 Digital pin 0 (RX) 21 (TXD1/INT3) PD3 Digital pin 1 (TX) 22 (XCK1/#CTS) PD5 TXLED 23 GND1 GND 24 AVCC AVCC 25 (ICP1/ADC8) PD4 Digital pin 4 26 (T1/#OC4D/ADC9) PD6 Digital pin 12 27 (T0/OC4D/ADC10) PD7 Digital Pin 6 (PWM) 28 (ADC11/PCINT4) PB4 Digital pin 8 29 (PCINT5/OC1A/#OC4B/ADC12) PB5 Digital Pin 9 (PWM) 30 (PCINT6/OC1B/OC4B/ADC13) PB6 Digital Pin 10 (PWM) 31 (OC3A/#0C4A) PC6 Digital Pin 5 (PWM) 32 (ICP3/CLK0/)C4A) PC7 Digital Pin 13 (PWM) 33 (#HWB) PE2 HWB 34 Vcc1 +5V 35 GND2 GND 36 (ADC7/TDI) PF7 Analog In 0 37 (ADC6/TDO) PF6 Analog In 1 38 (ADC5/TMS) PF5 Analog In 2 39 (ADC4/TCK) PF4 Analog In 3 40 (ADC1) PF1 Analog In 4 41 (ADC0) PF0 Analog In 5 42 AREF AEF 43 GND3 GND 44 AVCC1 AVCC","title":"Pemetaaan"},{"location":"papan/mengenal-arduino-leonardo/#komunikasi","text":"Leonardo memiliki sejumlah fasilitas untuk berkomunikasi dengan komputer, dengan Arduino lain, atau dengan mikrokontroler lainnya. ATmega32U4 mampu menyediakan komunikasi serial UART TTL (5V), yang tersedia pada pin digital 0 (RX) dan 1 (TX). ATmega32U4 juga memungkinkan untuk komunikasi serial (CDC) melalui USB dan muncul sebagai com port virtual pada perangkat lunak komputer. Chip ini juga bertindak sebagai perangkat USB 2.0 dengan kecepatan tinggi, serta menggunakan standar driver USB COM, tetapi ntuk sistem operasi Windows masih tetap memerlukan file inf. Perangkat lunak Arduino termasuk didalamnya serial monitor memungkinkan data tekstual sederhana dikirim ke dan dari papan Arduino. LED RX dan TX yang tersedia pada papan akan berkedip ketika data sedang dikirim atau diterima melalui chip USB-to-serial yang terhubung melalui USB komputer (tetapi tidak untuk komunikasi serial seperti pada pin 0 dan 1). Sebuah perpustakaan SoftwareSerial memungkinkan komunikasi serial pada beberapa pin digital Leonardo. ATmega32U4 juga mendukung komunikasi I2C (TWI) dan SPI. Perangkat lunak Arduino termasuk perpustakaan Wire digunakan untuk menyederhanakan penggunaan bus I2C. Untuk komunikasi SPI, menggunakan perpustakaan SPI. Leonardo muncul pada komputer sebagai keyboard dan mouse generik, dan dapat diprogram untuk mengontrol perangkat input menggunakan kelas/kelompok Keyboard dan Mouse.","title":"Komunikasi"},{"location":"papan/mengenal-arduino-leonardo/#pemrograman","text":"Arduino Mega dapat diprogram dengan software Arduino (Unduh perangkat lunak Arduino) . (Mengenai pemahasan lebih rinci tentang perangkat lunak Arduino akan dibahas pada artikel terpisah). ATmega32U4 pada Arduino Leonardo sudah tersedia preburned dengan bootloader ( preburned dan bootloader apa bahasa Indonesianya?) yang memungkinkan Anda untuk meng-upload kode baru tanpa menggunakan programmer hardware eksternal. Hal ini karena komunikasi yang terjadi menggunakan protokol AVR109. Anda juga dapat melewati ( bypass ) bootloader dan program mikrokontroler melalui pin header ICSP ( In-Circuit Serial Programming ).","title":"Pemrograman"},{"location":"papan/mengenal-arduino-leonardo/#reset-software-otomatis-dan-inisiasi-bootloader","text":"Daripada menekan tombol reset sebelum upload, Arduino Leonardo didesain dengan cara yang memungkinkan Anda untuk me-reset melalui perangkat lunak yang berjalan pada komputer yang terhubung. Reset dipicu ketika virtual (CDC) port serial/COM Leonardo dibuka pada 1200 baud dan kemudian ditutup. Ketika ini terjadi, prosesor akan mengatur ular (reset), memutuskan hubungan koneksi USB ke komputer (virtual port serial/COM akan hilang dari komputer). Setelah prosesor melakukan reset, bootlader akan dimuat, yang akan segera aktif dalam waktu sekitar 8 detik. Bootloader juga dapat dimuat dengan menekan tombol Reset pada Leonardo. Perhatikan bahwa ketika pertama kali papan diaktifkan, ia akan melompat langsung ke sketch, jika tersedia, dari pada harus memuat bootloader. Karena itu metode yang terbaik untuk melakukan reset pada Leonardo adalah dengan membiarkan software arduino melakukan reset sebelum upload sketch, terutama bagi mereka yang terbiasa menekan tombol reset sebelum melakukan upload. Jika software Arduino tidak dapat melakukan reset terhadap papan, kita bisa memulai bootloader dengan menekan tombol reset yang tersedia pada papan.","title":"Reset (Software) Otomatis dan Inisiasi Bootloader"},{"location":"papan/mengenal-arduino-leonardo/#perlindungan-beban-berlebih-pada-usb","text":"Arduino Leonardo memiliki polyfuse reset yang melindungi port USB komputer Anda dari hubungan singkat dan arus lebih. Meskipun pada dasarnya komputer telah memiliki perlindungan internal pada port USB mereka sendiri, sekring memberikan lapisan perlindungan tambahan. Jika arus lebih dari 500 mA dihubungkan ke port USB, sekring secara otomatis akan memutuskan sambungan sampai hubungan singkat atau overload dihapus/dibuang.","title":"Perlindungan Beban Berlebih pada USB"},{"location":"papan/mengenal-arduino-leonardo/#karakteristik-fisik","text":"Maksimum panjang dan lebar PCB Arduino Leonardo sama dengan Arduino Uno yaitu 2.7 x 2.1 inch (6,8 x 5,3 cm), dengan konektor USB dan jack power menonjol melampaui batas dimensi. Empat lubang sekrup memungkinkan papan terpasang pada suatu permukaan atau wadah. Perhatikan bahwa jarak antara pin digital 7 dan 8 adalah 160 mil (0.16 inch), tidak seperti pin lainnya dengan kelipatan genap berjarak 100 mil.","title":"Karakteristik Fisik"},{"location":"papan/mengenal-arduino-nano/","text":"Mengenal Arduino Nano \u00b6 Papan pengembangan elektronika mikrokontroler yang diberi nama Arduino ini memiliki banyak sekali turunannya. Baik itu yang diturunkan langsung dari pihak Arduino sendiri atau pihak ketiga yang ikut mengembangkan papan Arduino. Hal ini karena Arduino bersifat Open Source Hardware (OSH), karena sifatnya yang terbuka ini maka membuat para pengembang tidak perlu takut dengan Hak Atas Kekayaan Intelektual. Siapapun dapat membangun papan Arduino dengan versi sendiri dan disesuaikan dengan kebutuhan sendiri atau bahkan disesuaikan dengan dana yang dimiliki, namun tetap bekerja normal layaknya papan Arduino aslinya. Salah satu papan Arduino yang dikembangkan pihak ke tiga dan dapat diterima oleh pasar dengan baik adalah Arduino Nano. Seperti apa Arduino Nano? Arduino Nano adalah salah satu papan pengembangan mikrokontoler yang berukuran kecil, lengkap dan mendukung penggunaan breadboard. Arduino Nano diciptakan dengan basis mikrokontroler ATmega328 (untuk Arduino Nano versi 3.x) atau ATmega 168(untuk Arduino versi 2.x). Arduino Nano kurang lebih memiliki fungsi yang sama dengan Arduino Duemilanove, tetapi dalam paket yang berbeda. Arduino Nano tidak menyertakan colokan DC berjenis Barrel Jack, dan dihubungkan ke komputer menggunakan port USB Mini-B. Arduino Nano dirancang dan diproduksi oleh perusahaan Gravitech . Gambar 1. Arduino Nano Depan Gambar 2. Arduino Nano Belakang Skema dan Desain \u00b6 Karena Arduino Nano dibuat oleh Gravitech maka dibawah ini ada dua lampiran file tentang skema Arduino Nano. Yang keduanya identik, baik yang berasal dari situs Arduino maupun dari situs Gravitech. Unduh Skema (PDF) Arduino Nano versi 3.0 (ATmega328) : skema dari Arduino dan skema dari Gravitech Unduh Skema (EagleCAD) Arduino Nano versi 3.0 (ATmega328): skema dari Arduino dan skema dari Gravitech Unduh Skema (PDF) Arduino Nano versi 2.3 (ATmega168) : skema PDF , skema EagleCAD Catatan : Jika anda menggunakan EagleCAD versi gratis maka tidak bisa menangani layer lebih dari 2, sedangkan Arduino Nano versi 2.3 terdiri dari 4 lapisan (layer). Spesifikasi \u00b6 Dibawah ini spesifikasi dari Arduino Nano: Info Spesifikasi Mikrokontroler Atmel ATmega168 atau ATmega328 Tegangan Operasi 5V Input Voltage (disarankan) 7-12V Input Voltage (limit) 6-20V Pin Digital I/O 14 (6 pin digunakan sebagai output PWM) Pins Input Analog 8 Arus DC per pin I/O 40 mA Flash Memory 16KB (ATmega168) atau 32KB (ATmega328) 2KB digunakan oleh Bootloader SRAM 1 KB (ATmega168) atau 2 KB (ATmega328) EEPROM 512 byte (ATmega168) atau 1KB (ATmega328) Clock Speed 16 MHz Ukuran 1.85cm x 4.3cm Sumber Daya \u00b6 Arduino Nano dapat diaktifkan melalui koneksi USB Mini-B, atau melalui catu daya eksternal dengan tegangan belum teregulasi antara 6-20 Volt yang dihubungkan melalui pin 30 atau pin VIN, atau melalui catu daya eksternal dengan tegangan teregulasi 5 volt melalui pin 27 atau pin 5V. Sumber daya akan secara otomatis dipilih dari sumber tegangan yang lebih tinggi. Chip FTDI FT232L pada Arduino Nano akan aktif apabila memperoleh daya melalui USB, ketika Arduino Nano diberikan daya dari luar (Non-USB) maka Chip FTDI tidak aktif dan pin 3.3V pun tidak tersedia (tidak mengeluarkan tegangan), sedangkan LED TX dan RX pun berkedip apabila pin digital 0 dan 1 berada pada posisi HIGH. Pemetaan Pin \u00b6 Dibawah ini pemetaan pin ATmega168 pada Arduino Nano. Gambar 3. Pemetaan Pin ATmega168 Perhatikan pemetaan antara pin Arduino Nano dan port ATmega168. Pemetaan untuk ATmega8, ATmega168, dan ATmega328 sangat identik atau sama persis. Gambar 4. Pin Layout Arduino Nano Tabel Pemetaan \u00b6 No Pin ATmega328 Nama Pin ATmega328 No Pin Nano Peta Pin Nano 1 PD3 (PCINT19/OCB2B/INT1) 6 Digital Pin 3 (PWM) 2 PD4 (PCINT20/XCK/T0) 7 Digital Pin 4 3 GND 4 GND 4 VCC 27 VCC 5 GND 4 GND 6 VCC 27 VCC 7 PB6 (PCINT6/XTAL1/TOASC1) - - 8 PB7 (PCINT7/XTAL2/TOASC2) - - 9 PD5 (PCINT21/OC0B/T1) 8 Digital Pin 5 (PWM) 10 PD6 (PCINT22/OC0A/AIN0) 9 Digital Pin 6 (PWM) 11 PD7 (PCINT23/AIN1) 10 Digital Pin 7 12 PB0 (PCINT0/CLK0/ICP1) 11 Digital Pin 8 13 PB1 (PCINT1/OC1A) 13 Digital Pin 9 (PWM) 14 PB2 (PCINT2/SS/OC1B) 13 Digital Pin 10 (PWM - SS) 15 PB3 (PCINT3/OC2A/MOSI) 14 Digital Pin 11 (PWM - MOSI) 16 PB4 (PCINT4/MISO) 15 Digital Pin 12 (MISO) 17 PB5 (PCINT5/SCK) 16 Digital Pin 13 (SCK) 18 AVCC 27 VCC 19 ADC6 25 Analog Input 6 20 AREF 18 AREF 21 GND 29 GND 22 ADC7 26 Analog Input 7 23 PC0 (PCINT8/ADC0) 19 Analog Input 0 24 PC1 (PCINT9/ADC1) 20 Analog Input 1 25 PC2 (PCINT10/ADC2) 21 Analog Input 2 26 PC3 (PCINT11/ADC3) 22 Analog Input 3 27 PC4 (PCINT12/ADC4/SDA) 24 Analog Input 4 (SDA) 28 PC5 (PCINT13/ADC5/SCL) 25 Analog Input 5 (SCL) 29 PC6 (PCINT14/RESET) 18 RESET 30 PD0 (PCINT16/RXD) 2 Digital Pin 0 (RX) 31 PD1 (PCINT17/TXD) 1 Digital Pin 1 (TX) 32 PD2 (PCINT18/INT0) 5 Digital Pin 2 Memory \u00b6 ATmega168 memiliki 16 KB flash memory untuk menyimpan kode (2 KB digunakan untuk bootloader); Sedangkan ATmega328 memiliki flash memory sebesar 32 KB, (juga dengan 2 KB digunakan untuk bootloader). ATmega168 memiliki 1 KB memory pada SRAM dan 512 byte pada EEPROM (yang dapat dibaca dan ditulis dengan perpustakaan EEPROM); Sedangkan ATmega328 memiliki 2 KB memory pada SRAM dan 1 KB pada EEPROM. Input dan Output \u00b6 Masing-masing dari 14 pin digital pada Arduino Nano dapat digunakan sebagai input atau output, dengan menggunakan fungsi pinMode () , digitalWrite () , dan digitalRead () . Semua pin beroperasi pada tegangan 5 volt. Setiap pin dapat memberikan atau menerima arus maksimum 40 mA dan memiliki resistor pull-up internal (yang terputus secara default) sebesar 20-50 KOhm. Selain itu beberapa pin memiliki fungsi khusus, yaitu: Serial : 0 (RX) dan 1 (TX). Digunakan untuk menerima (RX) dan mengirimkan (TX) TTL data serial. Pin ini terhubung ke pin yang sesuai dari chip FTDI USB-to-TTL Serial. External Interrupt (Interupsi Eksternal): Pin 2 dan pin 3 ini dapat dikonfigurasi untuk memicu sebuah interupsi pada nilai yang rendah, meningkat atau menurun, atau perubahan nilai. PWM : Pin 3, 5, 6, 9, 10, dan 11. Menyediakan output PWM 8-bit dengan fungsi analogWrite () . Jika pada jenis papan berukuran lebih besar (misal: Arduino Uno ), pin PWM ini diberi simbol tilde atau \"~\" sedangkan pada Arduino Nano diberi tanda titik. SPI : Pin 10 (SS), 11 (MOSI), 12 (MISO), 13 (SCK). Pin ini mendukung komunikasi SPI. Sebenarnya komunikasi SPI ini tersedia pada hardware, tapi untuk saat belum didukung dalam bahasa Arduino. LED : Pin 13. Tersedia secara built-in pada papan Arduino Nano. LED terhubung ke pin digital 13. Ketika pin diset bernilai HIGH, maka LED menyala, dan ketika pin diset bernilai LOW, maka LED padam. Arduino Nano memiliki 8 pin sebagai input analog, diberi label A0 sampai dengan A7, yang masing-masing menyediakan resolusi 10 bit (yaitu 1024 nilai yang berbeda). Secara default pin ini dapat diukur/diatur dari mulai Ground sampai dengan 5 Volt, juga memungkinkan untuk mengubah titik jangkauan tertinggi atau terendah mereka menggunakan fungsi analogReference () . Pin Analog 6 dan 7 tidak dapat digunakan sebagai pin digital. Selain itu juga, beberapa pin memiliki fungsi yang dikhususkan, yaitu: I2C : Pin A4 (SDA) dan pin A5 (SCL). Yang mendukung komunikasi I2C (TWI) menggunakan perpustakaan Wire. Masih ada beberapa pin lainnya pada Arduino Nano, yaitu: AREF : Referensi tegangan untuk input analog. Digunakan dengan fungsi analogReference () . RESET : Jalur LOW ini digunakan untuk me-reset (menghidupkan ulang) mikrokontroler. Biasanya digunakan untuk menambahkan tombol reset pada shield yang menghalangi papan utama Arduino. Komunikasi \u00b6 Arduino Nano memiliki sejumlah fasilitas untuk berkomunikasi dengan komputer, dengan Arduino lain, atau dengan mikrokontroler lainnya. ATmega168 dan ATmega328 menyediakan komunikasi serial UART TTL (5 Volt), yang tersedia pada pin digital 0 (RX) dan pin 1 (TX). Sebuah chip FTDI FT232RL yang terdapat pada papan Arduino Nano digunakan sebagai media komunikasi serial melalui USB dan driver FTDI (tersedia pada software Arduino IDE) yang akan menyediakan COM Port Virtual (pada Device komputer) untuk berkomunikasi dengan perangkat lunak pada komputer. Perangkat lunak Arduino termasuk didalamnya serial monitor memungkinkan data tekstual sederhana dikirim ke dan dari papan Arduino. LED RX dan TX yang tersedia pada papan akan berkedip ketika data sedang dikirim atau diterima melalui chip FTDI dan koneksi USB yang terhubung melalui USB komputer (tetapi tidak untuk komunikasi serial pada pin 0 dan 1). Sebuah perpustakaan SoftwareSerial memungkinkan komunikasi serial pada beberapa pin digital Nano. ATmega168 dan ATmega328 juga mendukung komunikasi I2C (TWI) dan SPI. Perangkat lunak Arduino termasuk perpustakaan Wire digunakan untuk menyederhanakan penggunaan bus I2C. Untuk komunikasi SPI, silakan lihat datasheet ATmega168 atau ATmega328. Pemrograman \u00b6 Arduino Nano dapat diprogram dengan software Arduino ( Unduh perangkat lunak Arduino ). Pilih \"Arduino Diecimila, Duemilanove, atau Nano w/ ATmega168 \" or \"Arduino Duemilanove atau Nano w/ ATmega328\" melalui menu Tools > Board (sesuaikan dengan jenis mikrokontroler yang anda miliki). ATmega168 dan ATmega328 pada Arduino Nano sudah dipaket preburned dengan bootloader yang memungkinkan Anda untuk meng-upload kode baru tanpa menggunakan programer hardware eksternal. Hal ini karena komunikasi yang terjadi menggunakan protokol asli STK500. Anda juga dapat melewati (bypass) bootloader dan program mikrokontroler melalui pin header ICSP (In-Circuit Serial Programming) menggunakan Arduino ISP atau yang sejenis. Reset (Software) Otomatis \u00b6 Daripada menekan tombol reset sebelum upload, Arduino Nano didesain dengan cara yang memungkinkan Anda untuk me-reset melalui perangkat lunak yang berjalan pada komputer yang terhubung. Salah satu jalur kontrol hardware (DTR) mengalir dari FT232RL dan terhubung ke jalur reset dari ATmega168 atau ATmega328 melalui kapasitor 100 nanofarad. Bila jalur ini di-set rendah/low, jalur reset drop cukup lama untuk me-reset chip. Perangkat lunak Arduino menggunakan kemampuan ini untuk memungkinkan Anda meng-upload kode dengan hanya menekan tombol upload pada perangkat lunak Arduino. Ini berarti bahwa bootloader memiliki rentang waktu yang lebih pendek, seperti menurunkan DTR dapat terkoordinasi (berjalan beriringan) dengan dimulainya upload. Pengaturan ini juga memiliki implikasi lain. Ketika Arduino Nano terhubung dengan komputer yang menggunakan sistem operasi Mac OS X atau Linux, papan Arduino akan di-reset setiap kali dihubungkan dengan software komputer (melalui USB). Dan setengah detik kemudian atau lebih, bootloader berjalan pada papan Arduino Nano. Proses reset melalui program ini digunakan untuk mengabaikan data yang cacat (yaitu apapun selain meng-upload kode baru), ia akan memotong dan membuang beberapa byte pertama dari data yang dikirim ke papan setelah sambungan terbuka. Jika sebuah sketsa dijalankan pada papan untuk menerima satu kali konfigurasi atau menerima data lain ketika pertama kali dijalankan, pastikan bahwa perangkat lunak diberikan waktu untuk berkomunikasi dengan menunggu beberapa detik setelah terkoneksi dan sebelum mengirim data. Referensi \u00b6 Arduino Nano Board Arduino Nano 3.0 with ATmega328","title":"Mengenal Arduino Nano"},{"location":"papan/mengenal-arduino-nano/#mengenal-arduino-nano","text":"Papan pengembangan elektronika mikrokontroler yang diberi nama Arduino ini memiliki banyak sekali turunannya. Baik itu yang diturunkan langsung dari pihak Arduino sendiri atau pihak ketiga yang ikut mengembangkan papan Arduino. Hal ini karena Arduino bersifat Open Source Hardware (OSH), karena sifatnya yang terbuka ini maka membuat para pengembang tidak perlu takut dengan Hak Atas Kekayaan Intelektual. Siapapun dapat membangun papan Arduino dengan versi sendiri dan disesuaikan dengan kebutuhan sendiri atau bahkan disesuaikan dengan dana yang dimiliki, namun tetap bekerja normal layaknya papan Arduino aslinya. Salah satu papan Arduino yang dikembangkan pihak ke tiga dan dapat diterima oleh pasar dengan baik adalah Arduino Nano. Seperti apa Arduino Nano? Arduino Nano adalah salah satu papan pengembangan mikrokontoler yang berukuran kecil, lengkap dan mendukung penggunaan breadboard. Arduino Nano diciptakan dengan basis mikrokontroler ATmega328 (untuk Arduino Nano versi 3.x) atau ATmega 168(untuk Arduino versi 2.x). Arduino Nano kurang lebih memiliki fungsi yang sama dengan Arduino Duemilanove, tetapi dalam paket yang berbeda. Arduino Nano tidak menyertakan colokan DC berjenis Barrel Jack, dan dihubungkan ke komputer menggunakan port USB Mini-B. Arduino Nano dirancang dan diproduksi oleh perusahaan Gravitech . Gambar 1. Arduino Nano Depan Gambar 2. Arduino Nano Belakang","title":"Mengenal Arduino Nano"},{"location":"papan/mengenal-arduino-nano/#skema-dan-desain","text":"Karena Arduino Nano dibuat oleh Gravitech maka dibawah ini ada dua lampiran file tentang skema Arduino Nano. Yang keduanya identik, baik yang berasal dari situs Arduino maupun dari situs Gravitech. Unduh Skema (PDF) Arduino Nano versi 3.0 (ATmega328) : skema dari Arduino dan skema dari Gravitech Unduh Skema (EagleCAD) Arduino Nano versi 3.0 (ATmega328): skema dari Arduino dan skema dari Gravitech Unduh Skema (PDF) Arduino Nano versi 2.3 (ATmega168) : skema PDF , skema EagleCAD Catatan : Jika anda menggunakan EagleCAD versi gratis maka tidak bisa menangani layer lebih dari 2, sedangkan Arduino Nano versi 2.3 terdiri dari 4 lapisan (layer).","title":"Skema dan Desain"},{"location":"papan/mengenal-arduino-nano/#spesifikasi","text":"Dibawah ini spesifikasi dari Arduino Nano: Info Spesifikasi Mikrokontroler Atmel ATmega168 atau ATmega328 Tegangan Operasi 5V Input Voltage (disarankan) 7-12V Input Voltage (limit) 6-20V Pin Digital I/O 14 (6 pin digunakan sebagai output PWM) Pins Input Analog 8 Arus DC per pin I/O 40 mA Flash Memory 16KB (ATmega168) atau 32KB (ATmega328) 2KB digunakan oleh Bootloader SRAM 1 KB (ATmega168) atau 2 KB (ATmega328) EEPROM 512 byte (ATmega168) atau 1KB (ATmega328) Clock Speed 16 MHz Ukuran 1.85cm x 4.3cm","title":"Spesifikasi"},{"location":"papan/mengenal-arduino-nano/#sumber-daya","text":"Arduino Nano dapat diaktifkan melalui koneksi USB Mini-B, atau melalui catu daya eksternal dengan tegangan belum teregulasi antara 6-20 Volt yang dihubungkan melalui pin 30 atau pin VIN, atau melalui catu daya eksternal dengan tegangan teregulasi 5 volt melalui pin 27 atau pin 5V. Sumber daya akan secara otomatis dipilih dari sumber tegangan yang lebih tinggi. Chip FTDI FT232L pada Arduino Nano akan aktif apabila memperoleh daya melalui USB, ketika Arduino Nano diberikan daya dari luar (Non-USB) maka Chip FTDI tidak aktif dan pin 3.3V pun tidak tersedia (tidak mengeluarkan tegangan), sedangkan LED TX dan RX pun berkedip apabila pin digital 0 dan 1 berada pada posisi HIGH.","title":"Sumber Daya"},{"location":"papan/mengenal-arduino-nano/#pemetaan-pin","text":"Dibawah ini pemetaan pin ATmega168 pada Arduino Nano. Gambar 3. Pemetaan Pin ATmega168 Perhatikan pemetaan antara pin Arduino Nano dan port ATmega168. Pemetaan untuk ATmega8, ATmega168, dan ATmega328 sangat identik atau sama persis. Gambar 4. Pin Layout Arduino Nano","title":"Pemetaan Pin"},{"location":"papan/mengenal-arduino-nano/#tabel-pemetaan","text":"No Pin ATmega328 Nama Pin ATmega328 No Pin Nano Peta Pin Nano 1 PD3 (PCINT19/OCB2B/INT1) 6 Digital Pin 3 (PWM) 2 PD4 (PCINT20/XCK/T0) 7 Digital Pin 4 3 GND 4 GND 4 VCC 27 VCC 5 GND 4 GND 6 VCC 27 VCC 7 PB6 (PCINT6/XTAL1/TOASC1) - - 8 PB7 (PCINT7/XTAL2/TOASC2) - - 9 PD5 (PCINT21/OC0B/T1) 8 Digital Pin 5 (PWM) 10 PD6 (PCINT22/OC0A/AIN0) 9 Digital Pin 6 (PWM) 11 PD7 (PCINT23/AIN1) 10 Digital Pin 7 12 PB0 (PCINT0/CLK0/ICP1) 11 Digital Pin 8 13 PB1 (PCINT1/OC1A) 13 Digital Pin 9 (PWM) 14 PB2 (PCINT2/SS/OC1B) 13 Digital Pin 10 (PWM - SS) 15 PB3 (PCINT3/OC2A/MOSI) 14 Digital Pin 11 (PWM - MOSI) 16 PB4 (PCINT4/MISO) 15 Digital Pin 12 (MISO) 17 PB5 (PCINT5/SCK) 16 Digital Pin 13 (SCK) 18 AVCC 27 VCC 19 ADC6 25 Analog Input 6 20 AREF 18 AREF 21 GND 29 GND 22 ADC7 26 Analog Input 7 23 PC0 (PCINT8/ADC0) 19 Analog Input 0 24 PC1 (PCINT9/ADC1) 20 Analog Input 1 25 PC2 (PCINT10/ADC2) 21 Analog Input 2 26 PC3 (PCINT11/ADC3) 22 Analog Input 3 27 PC4 (PCINT12/ADC4/SDA) 24 Analog Input 4 (SDA) 28 PC5 (PCINT13/ADC5/SCL) 25 Analog Input 5 (SCL) 29 PC6 (PCINT14/RESET) 18 RESET 30 PD0 (PCINT16/RXD) 2 Digital Pin 0 (RX) 31 PD1 (PCINT17/TXD) 1 Digital Pin 1 (TX) 32 PD2 (PCINT18/INT0) 5 Digital Pin 2","title":"Tabel Pemetaan"},{"location":"papan/mengenal-arduino-nano/#memory","text":"ATmega168 memiliki 16 KB flash memory untuk menyimpan kode (2 KB digunakan untuk bootloader); Sedangkan ATmega328 memiliki flash memory sebesar 32 KB, (juga dengan 2 KB digunakan untuk bootloader). ATmega168 memiliki 1 KB memory pada SRAM dan 512 byte pada EEPROM (yang dapat dibaca dan ditulis dengan perpustakaan EEPROM); Sedangkan ATmega328 memiliki 2 KB memory pada SRAM dan 1 KB pada EEPROM.","title":"Memory"},{"location":"papan/mengenal-arduino-nano/#input-dan-output","text":"Masing-masing dari 14 pin digital pada Arduino Nano dapat digunakan sebagai input atau output, dengan menggunakan fungsi pinMode () , digitalWrite () , dan digitalRead () . Semua pin beroperasi pada tegangan 5 volt. Setiap pin dapat memberikan atau menerima arus maksimum 40 mA dan memiliki resistor pull-up internal (yang terputus secara default) sebesar 20-50 KOhm. Selain itu beberapa pin memiliki fungsi khusus, yaitu: Serial : 0 (RX) dan 1 (TX). Digunakan untuk menerima (RX) dan mengirimkan (TX) TTL data serial. Pin ini terhubung ke pin yang sesuai dari chip FTDI USB-to-TTL Serial. External Interrupt (Interupsi Eksternal): Pin 2 dan pin 3 ini dapat dikonfigurasi untuk memicu sebuah interupsi pada nilai yang rendah, meningkat atau menurun, atau perubahan nilai. PWM : Pin 3, 5, 6, 9, 10, dan 11. Menyediakan output PWM 8-bit dengan fungsi analogWrite () . Jika pada jenis papan berukuran lebih besar (misal: Arduino Uno ), pin PWM ini diberi simbol tilde atau \"~\" sedangkan pada Arduino Nano diberi tanda titik. SPI : Pin 10 (SS), 11 (MOSI), 12 (MISO), 13 (SCK). Pin ini mendukung komunikasi SPI. Sebenarnya komunikasi SPI ini tersedia pada hardware, tapi untuk saat belum didukung dalam bahasa Arduino. LED : Pin 13. Tersedia secara built-in pada papan Arduino Nano. LED terhubung ke pin digital 13. Ketika pin diset bernilai HIGH, maka LED menyala, dan ketika pin diset bernilai LOW, maka LED padam. Arduino Nano memiliki 8 pin sebagai input analog, diberi label A0 sampai dengan A7, yang masing-masing menyediakan resolusi 10 bit (yaitu 1024 nilai yang berbeda). Secara default pin ini dapat diukur/diatur dari mulai Ground sampai dengan 5 Volt, juga memungkinkan untuk mengubah titik jangkauan tertinggi atau terendah mereka menggunakan fungsi analogReference () . Pin Analog 6 dan 7 tidak dapat digunakan sebagai pin digital. Selain itu juga, beberapa pin memiliki fungsi yang dikhususkan, yaitu: I2C : Pin A4 (SDA) dan pin A5 (SCL). Yang mendukung komunikasi I2C (TWI) menggunakan perpustakaan Wire. Masih ada beberapa pin lainnya pada Arduino Nano, yaitu: AREF : Referensi tegangan untuk input analog. Digunakan dengan fungsi analogReference () . RESET : Jalur LOW ini digunakan untuk me-reset (menghidupkan ulang) mikrokontroler. Biasanya digunakan untuk menambahkan tombol reset pada shield yang menghalangi papan utama Arduino.","title":"Input dan Output"},{"location":"papan/mengenal-arduino-nano/#komunikasi","text":"Arduino Nano memiliki sejumlah fasilitas untuk berkomunikasi dengan komputer, dengan Arduino lain, atau dengan mikrokontroler lainnya. ATmega168 dan ATmega328 menyediakan komunikasi serial UART TTL (5 Volt), yang tersedia pada pin digital 0 (RX) dan pin 1 (TX). Sebuah chip FTDI FT232RL yang terdapat pada papan Arduino Nano digunakan sebagai media komunikasi serial melalui USB dan driver FTDI (tersedia pada software Arduino IDE) yang akan menyediakan COM Port Virtual (pada Device komputer) untuk berkomunikasi dengan perangkat lunak pada komputer. Perangkat lunak Arduino termasuk didalamnya serial monitor memungkinkan data tekstual sederhana dikirim ke dan dari papan Arduino. LED RX dan TX yang tersedia pada papan akan berkedip ketika data sedang dikirim atau diterima melalui chip FTDI dan koneksi USB yang terhubung melalui USB komputer (tetapi tidak untuk komunikasi serial pada pin 0 dan 1). Sebuah perpustakaan SoftwareSerial memungkinkan komunikasi serial pada beberapa pin digital Nano. ATmega168 dan ATmega328 juga mendukung komunikasi I2C (TWI) dan SPI. Perangkat lunak Arduino termasuk perpustakaan Wire digunakan untuk menyederhanakan penggunaan bus I2C. Untuk komunikasi SPI, silakan lihat datasheet ATmega168 atau ATmega328.","title":"Komunikasi"},{"location":"papan/mengenal-arduino-nano/#pemrograman","text":"Arduino Nano dapat diprogram dengan software Arduino ( Unduh perangkat lunak Arduino ). Pilih \"Arduino Diecimila, Duemilanove, atau Nano w/ ATmega168 \" or \"Arduino Duemilanove atau Nano w/ ATmega328\" melalui menu Tools > Board (sesuaikan dengan jenis mikrokontroler yang anda miliki). ATmega168 dan ATmega328 pada Arduino Nano sudah dipaket preburned dengan bootloader yang memungkinkan Anda untuk meng-upload kode baru tanpa menggunakan programer hardware eksternal. Hal ini karena komunikasi yang terjadi menggunakan protokol asli STK500. Anda juga dapat melewati (bypass) bootloader dan program mikrokontroler melalui pin header ICSP (In-Circuit Serial Programming) menggunakan Arduino ISP atau yang sejenis.","title":"Pemrograman"},{"location":"papan/mengenal-arduino-nano/#reset-software-otomatis","text":"Daripada menekan tombol reset sebelum upload, Arduino Nano didesain dengan cara yang memungkinkan Anda untuk me-reset melalui perangkat lunak yang berjalan pada komputer yang terhubung. Salah satu jalur kontrol hardware (DTR) mengalir dari FT232RL dan terhubung ke jalur reset dari ATmega168 atau ATmega328 melalui kapasitor 100 nanofarad. Bila jalur ini di-set rendah/low, jalur reset drop cukup lama untuk me-reset chip. Perangkat lunak Arduino menggunakan kemampuan ini untuk memungkinkan Anda meng-upload kode dengan hanya menekan tombol upload pada perangkat lunak Arduino. Ini berarti bahwa bootloader memiliki rentang waktu yang lebih pendek, seperti menurunkan DTR dapat terkoordinasi (berjalan beriringan) dengan dimulainya upload. Pengaturan ini juga memiliki implikasi lain. Ketika Arduino Nano terhubung dengan komputer yang menggunakan sistem operasi Mac OS X atau Linux, papan Arduino akan di-reset setiap kali dihubungkan dengan software komputer (melalui USB). Dan setengah detik kemudian atau lebih, bootloader berjalan pada papan Arduino Nano. Proses reset melalui program ini digunakan untuk mengabaikan data yang cacat (yaitu apapun selain meng-upload kode baru), ia akan memotong dan membuang beberapa byte pertama dari data yang dikirim ke papan setelah sambungan terbuka. Jika sebuah sketsa dijalankan pada papan untuk menerima satu kali konfigurasi atau menerima data lain ketika pertama kali dijalankan, pastikan bahwa perangkat lunak diberikan waktu untuk berkomunikasi dengan menunggu beberapa detik setelah terkoneksi dan sebelum mengirim data.","title":"Reset (Software) Otomatis"},{"location":"papan/mengenal-arduino-nano/#referensi","text":"Arduino Nano Board Arduino Nano 3.0 with ATmega328","title":"Referensi"},{"location":"papan/mengenal-arduino-uno/","text":"Mengenal Arduino Uno \u00b6 Arduino Uno adalah papan mikrokontroler berbasis ATmega328 (datasheet) . Arduino Uno memiliki 14 digital pin input/output, dimana 6 pin digunakan sebagai output PWM, 6 pin input analog, 16 MHz resonator keramik, koneksi USB, jack catu daya eksternal, header ICSP, dan tombol reset. Ini semua berisi hal-hal yang diperlukan untuk mendukung mikrokontroler; sederhana saja, hanya dengan menghubungkannya ke komputer dengan kabel USB atau sumber tegangan dengan adaptor AC-DC dan atau baterai untuk memulai menggunakan papan arduino. Arduino Uno R3 berbeda dari semua papan Uno sebelumnya yang sudah tidak menggunakan chip driver FTDI USB-to-serial. Sekarang, Arduino Uno menggunakan fitur Atmega16U2 (Atmega8U2 sampai dengan versi R2) yang diprogram sebagai konverter USB-to-serial. Arduino Uno Revisi 2 memiliki resistor pulling untuk 8U2 dari jalur HWB ke ground, sehingga lebih mudah untuk dimasukkan ke dalam mode DFU. Arduino Uno Revisi 3 memiliki fitur-fitur baru berikut: 1.0 pinout: ditambahkan pin SDA dan SCL yang dekat dengan pin AREF dan dua pin baru lainnya yang ditempatkan dekat dengan pin RESET, sedangkan IOREF digunakan sebagai perisai untuk beradaptasi dengan tegangan yang tersedia pada papan. Kedepannya, perisai akan dibuat kompatibel dengan dua jenis papan yang menggunakan AVR yang beroperasi pada tegangan 5V dan dengan Arduino Due yang beroperasi pada tegangan 3.3V. Sedangkan 2 pin tidak terhubung, yang disediakan untuk tujuan masa depan. Sirkuit RESET handal. Atmega 16U2 menggantikan 8U2. \"Uno\" berarti satu yang diambil dari bahasa Italia dan penggunaan nama ini untuk menandai peluncuran Arduino 1.0. Uno dan versi 1.0 akan menjadi versi referensi Arduino, yang akan terus berkembang. Uno adalah yang terbaru dalam serangkaian papan USB Arduino, dan digunakan sebagai model referensi untuk platform Arduino. Ringkasan \u00b6 Info Spesifikasi Mikrokontroler ATmega328 Tegangan Operasi 5 Volt Input Voltage (disarankan) 7 - 12 Volt Input Voltage (batas akhir) 6 - 20 Volt Digital I/O Pin 14 (6 pin sebagai output PWM) Analog Input Pin 6 Arus DC per pin I/O 40 mA Arus DC untuk pin 3.3V 50 mA Flash Memory 32 KB (ATmega328) 0,5 KB untuk bootloader SRAM 2 KB (ATmega328) EEPROM 1 KB (ATmega328) Clock Speed 16 MHz Skema & Referensi Desain \u00b6 File EAGLE: Arduino-uno-Rev3-referensi-design.zip ( CATATAN: hanya mampu dibuka dengan Eagle 6.0 dan atau yang lebih baru ) Skema: Arduino-uno-Rev3-schematic.pdf CATATAN : Sebagai referensi desain, Arduino dapat menggunakan ATmega8, 168, atau 328, model saat ini menggunakan ATmega328, tapi ATmega8 digunakan dalam skema untuk referensi. Konfigurasi pin identik pada ketiga jenis prosesor tersebut. Sumber Daya (Tegangan) \u00b6 Arduino Uno dapat diaktifkan melalui koneksi USB atau dengan catu daya eksternal. Sumber daya akan dipilih secara otomatis oleh Arduino. Sumber daya eksternal (non-USB) dapat berasal baik dari adaptor AC-DC atau baterai. Adaptor dapat dihubungkan dengan mencolokkan steker 2,1 mm yang bagian tengahnya terminal positif ke ke jack sumber tegangan pada papan. Jika tegangan berasal dari baterai dapat langsung dihubungkan melalui header pin Gnd dan pin Vin dari konektor POWER. Papan Arduino Uno dapat beroperasi dengan pasokan daya eksternal 6 Volt sampai 20 volt. Jika diberi tegangan kurang dari 7 Volt, maka, pin 5 Volt mungkin akan menghasilkan tegangan kurang dari 5 Volt dan ini akan membuat papan menjadi tidak stabil. Jika sumber tegangan menggunakan lebih dari 12 Volt, regulator tegangan akan mengalami panas berlebihan dan bisa merusak papan. Rentang sumber tegangan yang dianjurkan adalah 7 Volt sampai 12 Volt. Pin tegangan yang tersedia pada papan Arduino adalah sebagai berikut: VIN : Adalah input tegangan untuk papan Arduino ketika menggunakan sumber daya eksternal (sebagai 'saingan' tegangan 5 Volt dari koneksi USB atau sumber daya ter-regulator lainnya). Anda dapat memberikan tegangan melalui pin ini, atau jika memasok tegangan untuk papan melalui jack power, kita bisa mengakses/mengambil tegangan melalui pin ini. 5V : Sebuah pin yang mengeluarkan tegangan ter-regulator 5 Volt, dari pin ini tegangan sudah diatur (ter-regulator) dari regulator yang tersedia (built-in) pada papan. Arduino dapat diaktifkan dengan sumber daya baik berasal dari jack power DC (7-12 Volt), konektor USB (5 Volt), atau pin VIN pada board (7-12 Volt). Memberikan tegangan melalui pin 5V atau 3.3V secara langsung tanpa melewati regulator dapat merusak papan Arduino. 3V3 : Sebuah pin yang menghasilkan tegangan 3,3 Volt. Tegangan ini dihasilkan oleh regulator yang terdapat pada papan (on-board). Arus maksimum yang dihasilkan adalah 50 mA. GND : Pin Ground atau Massa. IOREF : Pin ini pada papan Arduino berfungsi untuk memberikan referensi tegangan yang beroperasi pada mikrokontroler. Sebuah perisai (shield) dikonfigurasi dengan benar untuk dapat membaca pin tegangan IOREF dan memilih sumber daya yang tepat atau mengaktifkan penerjemah tegangan (voltage translator) pada output untuk bekerja pada tegangan 5 Volt atau 3,3 Volt. Memori \u00b6 Prosessor ATmega328 memiliki memori sebesar 32 KB yang mana sebesar 0,5 KB digunakan untuk menyimpan file bootloader. ATmega328 juga memiliki 2 KB SRAM dan 1 KB EEPROM (yang dapat dibaca dan ditulis dengan perpustakaan EEPROM). Input dan Output \u00b6 Masing-masing dari 14 pin digital pada Arduino Uno dapat digunakan sebagai input atau output, dengan menggunakan fungsi pinMode() , digitalWrite() , dan digitalRead(). Semua pin beroperasi pada tegangan 5 volt. Setiap pin dapat memberikan atau menerima arus maksimum 40 mA dan memiliki resistor pull-up internal (terputus secara default) sebesar 20-50 kOhm. Selain itu beberapa pin memiliki fungsi khusus, yaitu: Serial : 0 (RX) dan 1 (TX). Digunakan untuk menerima (RX) dan mengirimkan (TX) TTL data serial. Pin ini terhubung ke pin korespondensi dari chip ATmega8U2 Serial USB-to-TTL. External Interrupt (Interupsi Eksternal): Pin 2 dan pin 3 ini dapat dikonfigurasi untuk memicu sebuah interupsi pada nilai yang rendah, meningkat atau menurun, atau perubahan nilai. Baca rincian fungsi attachInterrupt() (belum diterbitkan saat artikel ini ditulis). PWM : Pin 3, 5, 6, 9, 10, dan 11. Menyediakan output PWM 8-bit dengan fungsi analogWrite(). SPI : Pin 10 (SS), 11 (MOSI), 12 (MISO), 13 (SCK). Pin ini mendukung komunikasi SPI menggunakan perpustakaan SPI. LED : Pin 13. Tersedia secara built-in pada papan Arduino Uno. LED terhubung ke pin digital 13. Ketika pin diset bernilai HIGH, maka LED menyala, dan ketika pin diset bernilai LOW, maka LED padam. Arduino Uno memiliki 6 pin sebagai input analog, diberi label A0 sampai dengan A5, yang masing-masing menyediakan resolusi 10 bit (yaitu 1024 nilai yang berbeda). Secara default pin ini dapat diukur/diatur dari mulai Ground sampai dengan 5 Volt, juga memungkinkan untuk mengubah titik jangkauan tertinggi atau terendah mereka menggunakan pin AREF dan fungsi analogReference(). Selain itu juga, beberapa pin memiliki fungsi yang dikhususkan, yaitu: TWI : Pin A4 atau SDA dan pin A5 atau SCL. Yang mendukung komunikasi TWI menggunakan perpustakaan Wire. Masih ada beberapa pin lainnya pada Arduino Uno, yaitu: AREF : Referensi tegangan untuk input analog. Digunakan dengan fungsi analogReference(). RESET : Jalur LOW ini digunakan untuk me-reset (menghidupkan ulang) mikrokontroler. Jalur ini biasanya digunakan untuk menambahkan tombol reset pada shield yang menghalangi papan utama Arduino. Perhatikan pemetaan antara pin Arduino dan port ATmega328. Pemetaan untuk ATmega8, 168, dan 328 sangat identik. Komunikasi \u00b6 Arduino Uno memiliki sejumlah fasilitas untuk berkomunikasi dengan komputer, dengan Arduino lain, atau dengan mikrokontroler lainnya. ATmega328 menyediakan komunikasi serial UART TTL (5 Volt), yang tersedia pada pin digital 0 (RX) dan pin 1 (TX). Sebuah chip ATmega16U2 yang terdapat pada papan digunakan sebagai media komunikasi serial melalui USB dan muncul sebagai COM Port Virtual (pada Device komputer) untuk berkomunikasi dengan perangkat lunak pada komputer. Firmware 16U2 menggunakan driver standar USB COM, dan tidak membutuhkan driver eksternal. Namun pada sistem operasi Windows, file .inf masih dibutuhkan. Perangkat lunak Arduino termasuk didalamnya serial monitor memungkinkan data tekstual sederhana dikirim ke dan dari papan Arduino. LED RX dan TX yang tersedia pada papan akan berkedip ketika data sedang dikirim atau diterima melalui chip USB-to-serial yang terhubung melalui USB komputer (tetapi tidak untuk komunikasi serial seperti pada pin 0 dan 1). Sebuah perpustakaan SoftwareSerial memungkinkan komunikasi serial pada beberapa pin digital Uno. ATmega328 juga mendukung komunikasi I2C (TWI) dan SPI. Perangkat lunak Arduino termasuk perpustakaan Wire digunakan untuk menyederhanakan penggunaan bus I2C. Untuk komunikasi SPI, menggunakan perpustakaan SPI. Pemrograman \u00b6 Arduino Uno dapat diprogram dengan software Arduino (Unduh perangkat lunak Arduino) . (Mengenai pemahasan lebih rinci tentang perangkat lunak Arduino akan dibahas pada artikel terpisah). ATmega328 pada Arduino Uno sudah tersedia preburned dengan bootloader (preburned dan bootloader apa bahasa Indonesianya?) yang memungkinkan Anda untuk meng-upload kode baru tanpa menggunakan programmer hardware eksternal. Hal ini karena komunikasi yang terjadi menggunakan protokol asli STK500. Anda juga dapat melewati (bypass) bootloader dan program mikrokontroler melalui pin header ICSP (In-Circuit Serial Programming). Chip ATmega16U2 (atau 8U2 pada board Rev. 1 dan Rev. 2) source code firmware tersedia. ATmega16U2/8U2 dapat dimuat dengan bootloader DFU, yang dapat diaktifkan melalui: Pada papan Revisi 1: Menghubungkan jumper solder di bagian belakang papan (dekat dengan peta Italia) dan kemudian akan me-reset 8U2. Pada papan Revisi 2: Ada resistor yang menghubungkan jalur HWB 8U2/16U2 ke ground, sehingga lebih mudah untuk dimasukkan ke dalam mode DFU. Kemudian Anda dapat menggunakan Atmel FLIP software (sistem operasi Windows) atau DFU programmer (sistem operasi Mac OS X dan Linux) untuk memuat firmware baru. Atau Anda dapat menggunakan pin header ISP dengan programmer eksternal (overwrite DFU bootloader). Reset (Software) Otomatis \u00b6 Daripada menekan tombol reset sebelum upload, Arduino Uno didesain dengan cara yang memungkinkan Anda untuk me-reset melalui perangkat lunak yang berjalan pada komputer yang terhubung. Salah satu jalur kontrol hardware (DTR) mengalir dari ATmega8U2/16U2 dan terhubung ke jalur reset dari ATmega328 melalui kapasitor 100 nanofarad. Bila jalur ini di-set rendah/low, jalur reset drop cukup lama untuk me-reset chip. Perangkat lunak Arduino menggunakan kemampuan ini untuk memungkinkan Anda meng-upload kode dengan hanya menekan tombol upload pada perangkat lunak Arduino. Ini berarti bahwa bootloader memiliki rentang waktu yang lebih pendek, seperti menurunkan DTR dapat terkoordinasi (berjalan beriringan) dengan dimulainya upload. Pengaturan ini juga memiliki implikasi lain. Ketika Arduino Uno terhubung dengan komputer yang menggunakan sistem operasi Mac OS X atau Linux, papan Arduino akan di-reset setiap kali dihubungkan dengan software komputer (melalui USB). Dan setengah detik kemudian atau lebih, bootloader berjalan pada papan Arduino Uno. Proses reset melalui program ini digunakan untuk mengabaikan data yang cacat (yaitu apapun selain meng-upload kode baru), ia akan memotong dan membuang beberapa byte pertama dari data yang dikirim ke papan setelah sambungan dibuka. Jika sebuah sketsa dijalankan pada papan untuk menerima satu kali konfigurasi atau menerima data lain ketika pertama kali dijalankan, pastikan bahwa perangkat lunak diberikan waktu untuk berkomunikasi dengan menunggu satu detik setelah terkoneksi dan sebelum mengirim data. Arduino Uno memiliki trek jalur yang dapat dipotong untuk menonaktifkan fungsi auto-reset. Pad di kedua sisi jalur dapat hubungkan dengan disolder untuk mengaktifkan kembali fungsi auto-reset. Pad berlabel \"RESET-EN\". Anda juga dapat menonaktifkan auto-reset dengan menghubungkan resistor 110 ohm dari 5V ke jalur reset. Perlindungan Beban Berlebih pada USB \u00b6 Arduino Uno memiliki polyfuse reset yang melindungi port USB komputer Anda dari hubungan singkat dan arus lebih. Meskipun pada dasarnya komputer telah memiliki perlindungan internal pada port USB mereka sendiri, sekring memberikan lapisan perlindungan tambahan. Jika arus lebih dari 500 mA dihubungkan ke port USB, sekring secara otomatis akan memutuskan sambungan sampai hubungan singkat atau overload dihapus/dibuang. Karakteristik Fisik \u00b6 Panjang dan lebar maksimum PCB Arduino Uno adalah 2.7 x 2.1 inch (6,8 x 5,3 cm), dengan konektor USB dan jack power menonjol melampaui batas dimensi. Empat lubang sekrup memungkinkan papan terpasang pada suatu permukaan atau wadah. Perhatikan bahwa jarak antara pin digital 7 dan 8 adalah 160 mil (0.16\"), tidak seperti pin lainnya dengan kelipatan genap berjarak 100 mil. Daftar Pustaka \u00b6 Arduino Uno (Halaman diakses pada tanggal 5 Agustus 2014, 06:51 AM)","title":"Mengenal Arduino Uno"},{"location":"papan/mengenal-arduino-uno/#mengenal-arduino-uno","text":"Arduino Uno adalah papan mikrokontroler berbasis ATmega328 (datasheet) . Arduino Uno memiliki 14 digital pin input/output, dimana 6 pin digunakan sebagai output PWM, 6 pin input analog, 16 MHz resonator keramik, koneksi USB, jack catu daya eksternal, header ICSP, dan tombol reset. Ini semua berisi hal-hal yang diperlukan untuk mendukung mikrokontroler; sederhana saja, hanya dengan menghubungkannya ke komputer dengan kabel USB atau sumber tegangan dengan adaptor AC-DC dan atau baterai untuk memulai menggunakan papan arduino. Arduino Uno R3 berbeda dari semua papan Uno sebelumnya yang sudah tidak menggunakan chip driver FTDI USB-to-serial. Sekarang, Arduino Uno menggunakan fitur Atmega16U2 (Atmega8U2 sampai dengan versi R2) yang diprogram sebagai konverter USB-to-serial. Arduino Uno Revisi 2 memiliki resistor pulling untuk 8U2 dari jalur HWB ke ground, sehingga lebih mudah untuk dimasukkan ke dalam mode DFU. Arduino Uno Revisi 3 memiliki fitur-fitur baru berikut: 1.0 pinout: ditambahkan pin SDA dan SCL yang dekat dengan pin AREF dan dua pin baru lainnya yang ditempatkan dekat dengan pin RESET, sedangkan IOREF digunakan sebagai perisai untuk beradaptasi dengan tegangan yang tersedia pada papan. Kedepannya, perisai akan dibuat kompatibel dengan dua jenis papan yang menggunakan AVR yang beroperasi pada tegangan 5V dan dengan Arduino Due yang beroperasi pada tegangan 3.3V. Sedangkan 2 pin tidak terhubung, yang disediakan untuk tujuan masa depan. Sirkuit RESET handal. Atmega 16U2 menggantikan 8U2. \"Uno\" berarti satu yang diambil dari bahasa Italia dan penggunaan nama ini untuk menandai peluncuran Arduino 1.0. Uno dan versi 1.0 akan menjadi versi referensi Arduino, yang akan terus berkembang. Uno adalah yang terbaru dalam serangkaian papan USB Arduino, dan digunakan sebagai model referensi untuk platform Arduino.","title":"Mengenal Arduino Uno"},{"location":"papan/mengenal-arduino-uno/#ringkasan","text":"Info Spesifikasi Mikrokontroler ATmega328 Tegangan Operasi 5 Volt Input Voltage (disarankan) 7 - 12 Volt Input Voltage (batas akhir) 6 - 20 Volt Digital I/O Pin 14 (6 pin sebagai output PWM) Analog Input Pin 6 Arus DC per pin I/O 40 mA Arus DC untuk pin 3.3V 50 mA Flash Memory 32 KB (ATmega328) 0,5 KB untuk bootloader SRAM 2 KB (ATmega328) EEPROM 1 KB (ATmega328) Clock Speed 16 MHz","title":"Ringkasan"},{"location":"papan/mengenal-arduino-uno/#skema-referensi-desain","text":"File EAGLE: Arduino-uno-Rev3-referensi-design.zip ( CATATAN: hanya mampu dibuka dengan Eagle 6.0 dan atau yang lebih baru ) Skema: Arduino-uno-Rev3-schematic.pdf CATATAN : Sebagai referensi desain, Arduino dapat menggunakan ATmega8, 168, atau 328, model saat ini menggunakan ATmega328, tapi ATmega8 digunakan dalam skema untuk referensi. Konfigurasi pin identik pada ketiga jenis prosesor tersebut.","title":"Skema &amp; Referensi Desain"},{"location":"papan/mengenal-arduino-uno/#sumber-daya-tegangan","text":"Arduino Uno dapat diaktifkan melalui koneksi USB atau dengan catu daya eksternal. Sumber daya akan dipilih secara otomatis oleh Arduino. Sumber daya eksternal (non-USB) dapat berasal baik dari adaptor AC-DC atau baterai. Adaptor dapat dihubungkan dengan mencolokkan steker 2,1 mm yang bagian tengahnya terminal positif ke ke jack sumber tegangan pada papan. Jika tegangan berasal dari baterai dapat langsung dihubungkan melalui header pin Gnd dan pin Vin dari konektor POWER. Papan Arduino Uno dapat beroperasi dengan pasokan daya eksternal 6 Volt sampai 20 volt. Jika diberi tegangan kurang dari 7 Volt, maka, pin 5 Volt mungkin akan menghasilkan tegangan kurang dari 5 Volt dan ini akan membuat papan menjadi tidak stabil. Jika sumber tegangan menggunakan lebih dari 12 Volt, regulator tegangan akan mengalami panas berlebihan dan bisa merusak papan. Rentang sumber tegangan yang dianjurkan adalah 7 Volt sampai 12 Volt. Pin tegangan yang tersedia pada papan Arduino adalah sebagai berikut: VIN : Adalah input tegangan untuk papan Arduino ketika menggunakan sumber daya eksternal (sebagai 'saingan' tegangan 5 Volt dari koneksi USB atau sumber daya ter-regulator lainnya). Anda dapat memberikan tegangan melalui pin ini, atau jika memasok tegangan untuk papan melalui jack power, kita bisa mengakses/mengambil tegangan melalui pin ini. 5V : Sebuah pin yang mengeluarkan tegangan ter-regulator 5 Volt, dari pin ini tegangan sudah diatur (ter-regulator) dari regulator yang tersedia (built-in) pada papan. Arduino dapat diaktifkan dengan sumber daya baik berasal dari jack power DC (7-12 Volt), konektor USB (5 Volt), atau pin VIN pada board (7-12 Volt). Memberikan tegangan melalui pin 5V atau 3.3V secara langsung tanpa melewati regulator dapat merusak papan Arduino. 3V3 : Sebuah pin yang menghasilkan tegangan 3,3 Volt. Tegangan ini dihasilkan oleh regulator yang terdapat pada papan (on-board). Arus maksimum yang dihasilkan adalah 50 mA. GND : Pin Ground atau Massa. IOREF : Pin ini pada papan Arduino berfungsi untuk memberikan referensi tegangan yang beroperasi pada mikrokontroler. Sebuah perisai (shield) dikonfigurasi dengan benar untuk dapat membaca pin tegangan IOREF dan memilih sumber daya yang tepat atau mengaktifkan penerjemah tegangan (voltage translator) pada output untuk bekerja pada tegangan 5 Volt atau 3,3 Volt.","title":"Sumber Daya (Tegangan)"},{"location":"papan/mengenal-arduino-uno/#memori","text":"Prosessor ATmega328 memiliki memori sebesar 32 KB yang mana sebesar 0,5 KB digunakan untuk menyimpan file bootloader. ATmega328 juga memiliki 2 KB SRAM dan 1 KB EEPROM (yang dapat dibaca dan ditulis dengan perpustakaan EEPROM).","title":"Memori"},{"location":"papan/mengenal-arduino-uno/#input-dan-output","text":"Masing-masing dari 14 pin digital pada Arduino Uno dapat digunakan sebagai input atau output, dengan menggunakan fungsi pinMode() , digitalWrite() , dan digitalRead(). Semua pin beroperasi pada tegangan 5 volt. Setiap pin dapat memberikan atau menerima arus maksimum 40 mA dan memiliki resistor pull-up internal (terputus secara default) sebesar 20-50 kOhm. Selain itu beberapa pin memiliki fungsi khusus, yaitu: Serial : 0 (RX) dan 1 (TX). Digunakan untuk menerima (RX) dan mengirimkan (TX) TTL data serial. Pin ini terhubung ke pin korespondensi dari chip ATmega8U2 Serial USB-to-TTL. External Interrupt (Interupsi Eksternal): Pin 2 dan pin 3 ini dapat dikonfigurasi untuk memicu sebuah interupsi pada nilai yang rendah, meningkat atau menurun, atau perubahan nilai. Baca rincian fungsi attachInterrupt() (belum diterbitkan saat artikel ini ditulis). PWM : Pin 3, 5, 6, 9, 10, dan 11. Menyediakan output PWM 8-bit dengan fungsi analogWrite(). SPI : Pin 10 (SS), 11 (MOSI), 12 (MISO), 13 (SCK). Pin ini mendukung komunikasi SPI menggunakan perpustakaan SPI. LED : Pin 13. Tersedia secara built-in pada papan Arduino Uno. LED terhubung ke pin digital 13. Ketika pin diset bernilai HIGH, maka LED menyala, dan ketika pin diset bernilai LOW, maka LED padam. Arduino Uno memiliki 6 pin sebagai input analog, diberi label A0 sampai dengan A5, yang masing-masing menyediakan resolusi 10 bit (yaitu 1024 nilai yang berbeda). Secara default pin ini dapat diukur/diatur dari mulai Ground sampai dengan 5 Volt, juga memungkinkan untuk mengubah titik jangkauan tertinggi atau terendah mereka menggunakan pin AREF dan fungsi analogReference(). Selain itu juga, beberapa pin memiliki fungsi yang dikhususkan, yaitu: TWI : Pin A4 atau SDA dan pin A5 atau SCL. Yang mendukung komunikasi TWI menggunakan perpustakaan Wire. Masih ada beberapa pin lainnya pada Arduino Uno, yaitu: AREF : Referensi tegangan untuk input analog. Digunakan dengan fungsi analogReference(). RESET : Jalur LOW ini digunakan untuk me-reset (menghidupkan ulang) mikrokontroler. Jalur ini biasanya digunakan untuk menambahkan tombol reset pada shield yang menghalangi papan utama Arduino. Perhatikan pemetaan antara pin Arduino dan port ATmega328. Pemetaan untuk ATmega8, 168, dan 328 sangat identik.","title":"Input dan Output"},{"location":"papan/mengenal-arduino-uno/#komunikasi","text":"Arduino Uno memiliki sejumlah fasilitas untuk berkomunikasi dengan komputer, dengan Arduino lain, atau dengan mikrokontroler lainnya. ATmega328 menyediakan komunikasi serial UART TTL (5 Volt), yang tersedia pada pin digital 0 (RX) dan pin 1 (TX). Sebuah chip ATmega16U2 yang terdapat pada papan digunakan sebagai media komunikasi serial melalui USB dan muncul sebagai COM Port Virtual (pada Device komputer) untuk berkomunikasi dengan perangkat lunak pada komputer. Firmware 16U2 menggunakan driver standar USB COM, dan tidak membutuhkan driver eksternal. Namun pada sistem operasi Windows, file .inf masih dibutuhkan. Perangkat lunak Arduino termasuk didalamnya serial monitor memungkinkan data tekstual sederhana dikirim ke dan dari papan Arduino. LED RX dan TX yang tersedia pada papan akan berkedip ketika data sedang dikirim atau diterima melalui chip USB-to-serial yang terhubung melalui USB komputer (tetapi tidak untuk komunikasi serial seperti pada pin 0 dan 1). Sebuah perpustakaan SoftwareSerial memungkinkan komunikasi serial pada beberapa pin digital Uno. ATmega328 juga mendukung komunikasi I2C (TWI) dan SPI. Perangkat lunak Arduino termasuk perpustakaan Wire digunakan untuk menyederhanakan penggunaan bus I2C. Untuk komunikasi SPI, menggunakan perpustakaan SPI.","title":"Komunikasi"},{"location":"papan/mengenal-arduino-uno/#pemrograman","text":"Arduino Uno dapat diprogram dengan software Arduino (Unduh perangkat lunak Arduino) . (Mengenai pemahasan lebih rinci tentang perangkat lunak Arduino akan dibahas pada artikel terpisah). ATmega328 pada Arduino Uno sudah tersedia preburned dengan bootloader (preburned dan bootloader apa bahasa Indonesianya?) yang memungkinkan Anda untuk meng-upload kode baru tanpa menggunakan programmer hardware eksternal. Hal ini karena komunikasi yang terjadi menggunakan protokol asli STK500. Anda juga dapat melewati (bypass) bootloader dan program mikrokontroler melalui pin header ICSP (In-Circuit Serial Programming). Chip ATmega16U2 (atau 8U2 pada board Rev. 1 dan Rev. 2) source code firmware tersedia. ATmega16U2/8U2 dapat dimuat dengan bootloader DFU, yang dapat diaktifkan melalui: Pada papan Revisi 1: Menghubungkan jumper solder di bagian belakang papan (dekat dengan peta Italia) dan kemudian akan me-reset 8U2. Pada papan Revisi 2: Ada resistor yang menghubungkan jalur HWB 8U2/16U2 ke ground, sehingga lebih mudah untuk dimasukkan ke dalam mode DFU. Kemudian Anda dapat menggunakan Atmel FLIP software (sistem operasi Windows) atau DFU programmer (sistem operasi Mac OS X dan Linux) untuk memuat firmware baru. Atau Anda dapat menggunakan pin header ISP dengan programmer eksternal (overwrite DFU bootloader).","title":"Pemrograman"},{"location":"papan/mengenal-arduino-uno/#reset-software-otomatis","text":"Daripada menekan tombol reset sebelum upload, Arduino Uno didesain dengan cara yang memungkinkan Anda untuk me-reset melalui perangkat lunak yang berjalan pada komputer yang terhubung. Salah satu jalur kontrol hardware (DTR) mengalir dari ATmega8U2/16U2 dan terhubung ke jalur reset dari ATmega328 melalui kapasitor 100 nanofarad. Bila jalur ini di-set rendah/low, jalur reset drop cukup lama untuk me-reset chip. Perangkat lunak Arduino menggunakan kemampuan ini untuk memungkinkan Anda meng-upload kode dengan hanya menekan tombol upload pada perangkat lunak Arduino. Ini berarti bahwa bootloader memiliki rentang waktu yang lebih pendek, seperti menurunkan DTR dapat terkoordinasi (berjalan beriringan) dengan dimulainya upload. Pengaturan ini juga memiliki implikasi lain. Ketika Arduino Uno terhubung dengan komputer yang menggunakan sistem operasi Mac OS X atau Linux, papan Arduino akan di-reset setiap kali dihubungkan dengan software komputer (melalui USB). Dan setengah detik kemudian atau lebih, bootloader berjalan pada papan Arduino Uno. Proses reset melalui program ini digunakan untuk mengabaikan data yang cacat (yaitu apapun selain meng-upload kode baru), ia akan memotong dan membuang beberapa byte pertama dari data yang dikirim ke papan setelah sambungan dibuka. Jika sebuah sketsa dijalankan pada papan untuk menerima satu kali konfigurasi atau menerima data lain ketika pertama kali dijalankan, pastikan bahwa perangkat lunak diberikan waktu untuk berkomunikasi dengan menunggu satu detik setelah terkoneksi dan sebelum mengirim data. Arduino Uno memiliki trek jalur yang dapat dipotong untuk menonaktifkan fungsi auto-reset. Pad di kedua sisi jalur dapat hubungkan dengan disolder untuk mengaktifkan kembali fungsi auto-reset. Pad berlabel \"RESET-EN\". Anda juga dapat menonaktifkan auto-reset dengan menghubungkan resistor 110 ohm dari 5V ke jalur reset.","title":"Reset (Software) Otomatis"},{"location":"papan/mengenal-arduino-uno/#perlindungan-beban-berlebih-pada-usb","text":"Arduino Uno memiliki polyfuse reset yang melindungi port USB komputer Anda dari hubungan singkat dan arus lebih. Meskipun pada dasarnya komputer telah memiliki perlindungan internal pada port USB mereka sendiri, sekring memberikan lapisan perlindungan tambahan. Jika arus lebih dari 500 mA dihubungkan ke port USB, sekring secara otomatis akan memutuskan sambungan sampai hubungan singkat atau overload dihapus/dibuang.","title":"Perlindungan Beban Berlebih pada USB"},{"location":"papan/mengenal-arduino-uno/#karakteristik-fisik","text":"Panjang dan lebar maksimum PCB Arduino Uno adalah 2.7 x 2.1 inch (6,8 x 5,3 cm), dengan konektor USB dan jack power menonjol melampaui batas dimensi. Empat lubang sekrup memungkinkan papan terpasang pada suatu permukaan atau wadah. Perhatikan bahwa jarak antara pin digital 7 dan 8 adalah 160 mil (0.16\"), tidak seperti pin lainnya dengan kelipatan genap berjarak 100 mil.","title":"Karakteristik Fisik"},{"location":"papan/mengenal-arduino-uno/#daftar-pustaka","text":"Arduino Uno (Halaman diakses pada tanggal 5 Agustus 2014, 06:51 AM)","title":"Daftar Pustaka"},{"location":"papan/mikrokontroler/","text":"Mengenal Mikrokontroler \u00b6 Memang cukup membingungkan ketika mendengar istilah Mikrokontroler dan Mikroprosesor. Bagi para pengguna yang masih awam kedua istilah diatas dianggap sama, bahkan ada yang menganggap hanya beda istilah saja. Anggapan tersebut tidak salah 100% namun juga tidak benar 100%. Mikrokontroler dan Mikroprosesor adalah dua benda yang beda target penggunaan, beda kelengkapan fungsinya dan beda perusahaan yang awal menciptakan, namun berangkat dari ide yang sama, arsitektur yang sama, bahkan dari tahun lahir yang hampir sama pula. Lalu apa sebenarnya Mikrokontroler dan Mikroprosesor? Dalam dunia komputer dan mikroelektronik, banyak pengguna yang menghabiskan banyak dana untuk memiliki Mikroprosesor. Sebagian besar orang mengabaikan sebuah penemuan penting yang sempat mencapai kejayaann pada masanya, penemuan itu adalah Mikrokontroler. Kita tidak menyadari bahwa disekitar rumah kita, ada sekitar 5 hingga 20 perangkat elektronik yang dikendalikan oleh Mikrokontroler. Begitulah faktanya, karena lebih dari 2 miliar Mikrokontroler diproduksi setiap tahunnya. Hal ini berarti, sangat tidak mungkin manusia di era sekarang ini hidup tanpa Mikrokontroler. Mikrokontroler merupakan kepingan komputer terintegrasi yang mengendalikan sebagian besar perangkat elektronik disekitar kita yang hampir setiap hari digunakan, dari mulai gadget, mesin cuci, mesin pembuat kopi, remote kontrol, mainan anak-anak, televisi, hingga ke kendaraan. Lalu bagaimana ide tentang Mikrokontroler dan Mikroprosesor ini muncul? Lalu siapa yang pertama kali membuatnya? Mikrokontroler \u00b6 Mikrokontroler atau MCU (singkatan dari Microcontroller Unit) atau ada juga yang menyebut Mikrokomputer adalah komputer kecil pada sirkuit terpadu (IC) tunggal yang didalamnya berisi inti prosesor, memori, dan periferal Input/Output terprogram. Program memori dalam bentuk Ferroelectric RAM, NOR \ufb02ash atau OTP ROM juga sering ditanamkan didalam kepingan Mikrokontroler, serta sejumlah kecil RAM. Karena itulah, Mikrokontroler dapat berdiri sendiri untuk menjalankan suatu fungsi tanpa perlu bantuan perangkat penunjang kinerja. Gambar 1. Blok Diagram Mikrokontroler Sangat kontras dengan Mikroprosesor yang membutuhkan perangkat eksternal sebagai penunjang kinerja agar bisa menjalankan suatu fungsi. Perangkat penunjang kinerja tersebut misalnya; RAM, ROM, chip Input/Output (BIOS), dan lain sebagainya. Yang kesemuanya itu adalah perangkat terpisah yang dihubungkan ke Mikroprosesor dengan sebuah perantara (biasanya ada di motherboard). Sejarah Mikrokontroler \u00b6 Selama kurun waktu 1970 hingga 1971, perusahaan Intel sedang bersemangat untuk menciptakan Mikroprosesor pertama didunia. 1971 Intel merilis Mikroprosesor pertamanya yaitu Intel 4004 4-bit, kemudian diikuti Intel 8008 dan beberapa Mikroprosesor yang lebih mumpuni tersedia dipasaran beberapa tahun berikutnya. Namun, kedua Mikroprosesor tersebut membutuhkan perangkat eksternal lain untuk dapat bekerja menjalankan suatu fungsi dan ini tentunya akan meningkatkan biaya total pembuatan suatu perangkat, sehingga sangat mustahil menciptakan peralatan komputerisasi yang ekonomis. Gary Boone dan Michael Cochran, insinyur di Texas Instruments bekerja pada konsep yang hampir sama dengan Intel diawal-awal tahun 1970-an. Gambar 2. Mikroprosesor Intel 4004, 1971 Pada mulanya bisnis di Departemen MOS Texas Instruments adalah bisnis yang sesuai pesanan, dimana perusahaan seperti halnya pabrik kalkulator desktop datang ke Texas Instruments dengan beberapa set pengajuan spesifik. Texas Instruments kemudian mengkonversi spesifikasi tersebut ke dalam kepingan chip terpisah, yang terdiri dari empat, lima atau enam chip untuk menjalankan atau melaksanakan suatu spesifikasi dari perusahaan-perusahaan populer seperti Canon, Olympia, atau Olivetti. Untuk perusahaan-perusahaan tersebut, pekerjaan Texas Instruments sangatlah menakjubkan karena mampu memberikan pelayanan yang memuaskan dengan menekan banyak unit hanya menjadi sekitar empat, lima atau enam chip saja. Saat itu teknologi yang sangat populer adalah TTL, yang membutuhkan sekitar 100 hingga 200 chip. Sangat wajar jika bisnis ini merupakan bisnis yang menggairahkan bagi Texas Instruments. Gambar 3. Kalkulator Texas Instruments, 1974 Selama waktu itu Gary Boone melakukan penelitian yang lebih luas dengan melibatkan beberapa orang dari negara lain seperti Jerman, Itali, dan dari beberapa negara lainnya. Mereka mencoba memahami kebutuhkan pelanggan-pelanggan baru dan menyelesaikan pesanannya. Boone pada akhirnya merasa bosan setelah melakukan hal tersebut berulang kali. Selain itu, sejak proyek-proyek sebelumnya berhasil dan mereka memiliki sekumpulan pelanggan-pelanggan setia, pelanggan-pelanggan baru meminta pekerjaan yang sama seperti yang orang lain pesan ditahun-tahun sebelumnya. Sehingga, ini berarti menjadi tuntutan untuk melakukan hal yang sama, lagi dan lagi pada setiap proyek yang dikerjakan. Aturan umum di Texas Instruments adalah \"one riot, one ranger\" yang berarti \"satu chip, satu insinyur\". Jadi, jika Texas Instruments memiliki 12 insinyur desainer MOS maka mereka di pecah menjadi tiga atau empat bagian untuk mengerjakan satu proyek diwaktu yang sama. Dan itu membutuhkan waktu sekitar enam bulan untuk menyelesaikan satu proyek. Oleh karena itu, kapasitas bisnis adalah jumlah insinyur di bagi jumlah chip, satu kasus dalam setiap enam bulan. Walaupun permintaan dari masing-masing proyek berbeda secara detail, namun pada prinsip umum semua proses pekerjaan adalah sama saja. Hal ini membuat para insinyur merasa lelah untuk mengerjakan proyek-proyek yang monoton. Mereka bekerja dalam jangka waktu yang cukup lama dan mereka merasa telah melakukan yang terbaik untuk menyelesaikan suatu proyek. Boone dan para insinyur akhirnya memikirkan acuan satu arah yang dibutuhkan konsumen dan potongan rangkaian atau blok-blok fungsi dengan metode lain. Boone dapat menemukan penggunaan komponen yang sama, ia dan yang lainnya mempertimbangkan gagasan simulasi, \"Baiklah, mungkin jika sekarang kita memiliki beberapa byte didalam penyimpanan data, beberapa byte didalam penyimpanan program, dan memiliki beberapa bit untuk memindai antarmuka keyboard, maka itu akan mencakup semua spesifikasi yang kira-kira saya ketahui\". Sebagai penemuan terbaik dari gagasan ini maka lahirlah kepingan Mikrokontroler yang petama kali, tepatnya di bulan September 1971 yaitu TMS0100. Gambar 4. Mikrokontroler Pertama TMS0100 Salah satu aspek teknis yang penting sekali adalah bahwa desain teknologi pada saat itu sangat tidak efisien dalam memanfaatkan silicon. Arsitektur yang berbeda kemudian harus dipilih sehingga struktur lebih teratur dan penggunaan memori lebih ditekan, selain itu, pitch-matching juga harus diberi penekanan sehingga konsep bit-slice cocok di berbagai kebutuhan pada masing-masing 4 bit dari penambah 4 bit ditata menjadi dimensi yang sama dalam hal fisik. Hanya dengan itu akan ada kecocokan dan keselarasan didalam pitch. Pada akhirnya, faktor lain dari tiga atau empat dalam hal kepadatan silikon akan tercapai. Terlepas dari kendala arsitektur terutama pada orientasi memori dan pitch-matching, kemudian Mikrokontroler diciptakan lebih baik dari pada teknologi sebelumya (disebut TTL) dan akhirnya mampu memaksimalkan penggunaan silicon yang lebih efisien. Gambar 5. Bagian Mikrokontroler TMS0100 merupakan kepingan tunggal yang digunakan untuk mengendalikan mesin kalkulator. Setelah Mikrokontroler pertama ini berhasil, Gary Boone dan Michael Cochran kemudian mengembangkan desainnya, lahirlah turunan TMS0100 yaitu TMX1795. Pada tanggal 31 Agustus 1971, Boone mendaftarkan hak paten hasil penemuannya untuk mesin pengolah kepingan tunggal (single-chip). Tanggal 4 September 1973, Gary Boone memperoleh penghargaan U.S. Patent 3,757,306. Berbekal pengalaman selama proses pembuatan TMS0100 dan Prototipe Mikrokontroler 8-bit buatannya, Boone kemudian mendesain Mikrokontroler 4-bit seri TMS1000. Boone memperoleh penghargaan U.S. Patent 4,074,351 untuk penemuan Mikrokontroler Modern. Setelah dilakukan beberapa perbaikan kecil, Texas Instruments merilis mikrokontroler TMS1000 untuk dijual ke industri elektronik di tahun 1974. Mikrokontroler ini tersedia dalam berbagai konfigurasi ukuran ROM dan RAM. Keluarga TMS1000 dijual kepasaran dengan harga murah, sehingga meraih sukses besar dan disukai oleh industri elektronika saat itu. Selain karena harganya yang murah, keluarga TMS1000 dapat diprogram untuk melakukan fungsi yang berbeda, sehingga beberapa industri elektronik saat itu menciptakan banyak produk seperti oven microwave, video permainan, mesin cuci, jukebox, mainan anak-anak, alat-alat, permainan dan ratusan produk elektronik lainnya. Sampai tahun 1983, keluarga TMS1000 terjual lebih dari 100 juta keping. Wow!!! Gambar 6. Mikrokontroler TMS1000, 1974 Mikrokontroler Seri TMS1000 \u00b6 Setelah kesuksesan TMS1000 dipasaran, Texas Instruments kemudian mengembangkan keluarga TMS1000 menjadi beberapa varian seperti pada tabel dibawah ini: Nomor Seri ROM RAM I/O Pin Teknologi Catatan TMS1000 1KB 64x4 23 pMOS - TMS1000C 1KB 64x4 23 CMOS Identik dengan TMS1000, CMOS TMS1018 - 64x4 4 pMOS - TMS1070 1KB 64x4 - pMOS Built-in VF display controller TMS1098 - 128x4 - pMOS - TMS1099 - 64x4 - pMOS - TMS1099C - 64x4 - CMOS Identik dengan TMS1099, CMOS TMS1100 2KB 128x4 - pMOS - TMS1117 2KB 128x4 - pMOS - TMS1200 1KB 64x4 - pMOS - TMS1200C 1KB 64x4 - CMOS Identik dengan TMS1200, CMOS TMS1270 1KB 64x4 - pMOS - TMS1300 2KB 128x8 23 pMOS - TMS1400 4KB 128x4 22 pMOS - TMS1600 4KB 128x4 33 pMOS - TMS1700 512B 32x4 21 pMOS - TMS2000 1KB 64x4 - nMOS versi nMOS untuk TMS1000 TMS2100 2KB 128x4 - nMOS versi nMOS untuk TMS1100 TMS2200 1KB 64x4 - nMOS versi nMOS untuk TMS1200 TMS2300 2KB 128x4 - nMOS versi nMOS untuk TMS1300 TMS2098 - 128x4 - nMOS Contoh Developer TMS2099 - 164x4 - nMOS Contoh Developer Mikrokontroler Intel \u00b6 Disisi perusahaan lain, sebagai tanggapan terhadap keberadaan kepingan tunggal Mikrokontroler TMS1000, Intel tidak mau ketinggalan mengembangkan Mikrokontroler. Intel mengembangkan sistem komputer pada chip yang dioptimalkan untuk aplikasi kontrol, maka lahirlah Mikrokontroler Intel pertama yaitu Intel 8048 (termasuk 8048, 8035, dan 8749). Seri MCS-48 termasuk didalamnya Intel 8048 dirilis ke pasar pada tahun 1976, 2 tahun lebih lambat dari pada TMS1000. Intel 8048 menggabungkan RAM dan ROM didalam satu kepingan, menggunakan teknologi NMOS, dan menggunakan arsitektur Harvard yang telah dimodifikasi. Chip ini ditanamkan sebagai pengendali pada Keyboard PC produk IBM. Chip ini akan ditemukan didalam 1 miliar keyboard PC dan berbagai aplikasi lainnya. Pada saat itu Presiden Intel, Lukas J. Valenter, menyatakan bahwa mikrokontroler ini adalah salah satu yang paling sukses dalam sejarah perusahaan Intel, dan anggaran divisi ini ditambah lebih dari 25%. Gambar 7. Mikrokontroler Intel 8048, 1977 Pada tahun 1980, Intel kembali memperkenalkan seri MCS-51, termasuk didalamnya Mikrokontroler 8051 dengan teknologi CMOS dan ini menjadi Mikrokontroler paling populer yang digunakan. Bahkan Intel 8051 digunakan hingga hari ini, sehingga menjadi salah satu Mikrokontroler yang berumur panjang. Embedded Design \u00b6 Sebuah mikrokontroler dapat dianggap sebagai sistem mandiri dengan prosesor, memori dan periferal dan dapat digunakan sebagai sistem embedded (sistem-tertanam). Mayoritas mikrokontroler yang digunakan saat ini tertanam di mesin secara langsung, seperti di mobil, telepon, peralatan, dan peripheral untuk sistem komputer. Sementara beberapa embedded system yang sangat canggih, banyak memiliki persyaratan minimal untuk memori dan panjang program, dengan tidak ada sistem operasi, dan kompleksitas perangkat lunak yang rendah. Perangkat khusus input dan output meliputi switch, relay, solenoid, LED , Layar LCD kecil, perangkat frekuensi radio, dan sensor-sensor untuk data seperti suhu, kelembaban, tingkat cahaya dan lain-lain. Embedded sistem biasanya tidak memiliki keyboard, layar, disk, printer, atau perangkat lain yang biasa ditemukan di I/O dari komputer pribadi, dan mungkin tidak memiliki perangkat interaksi manusia apapun. Gambar 8. Arduino Mega2560 Erasable Programmable Memory \u00b6 Sekitar tahun 1990, mikrokontroler terus dikembangkan, salah satu teknologi yang cukup populer adalah Erasable Programmable ROM (EPROM), yaitu memori yang dapat dihapus dan diprogram ulang. Mikrokontroler ini memiliki jendela kaca transparan pada bagian atasnya, jika bagian ini terpapar sinar ultraviolet maka memori akan terhapus. Tipe ini biasanya digunakan hanya sebagai prototipe. Tipe lainnya adalah Programmed ROM oleh produsen, varian PROM hanya bisa diprogram sekali. Varian ini di tandai dengan penunjukan OTP (one-time programmable). PROM adalah jenis yang sama seperti halnya EPROM, tetapi karena tidak ada cara untuk memasukan sinar ultraviolet kedalam chip, maka memori tidak dapat dihapus. Versi yang bisa dihapus memerlukan jendela kuarsa, membuat versi ini lebih mahal dibandingkan versi OTP yang biasanya terbuat dari plastik buram. Gambar 9. Intel 8749 UV EPROM, 1980 Tahun 1993, pengenalan memori jenis EEPROM (Electrically Erasable Programmable ROM) yang memungkinkan memori mikrokontroler dihapus dengan cepat secara elektris tanpa paket yang mahal seperti halnya EPROM, membuat proses prototipe lebih cepat dan In System Programming. Teknologi ini diawali oleh perusahaan Microchip pada chip seri PIC16x84. Teknologi EEPROM telah tersedia sebelumnya, tapi EEPROM sebelumnya lebih mahal dan kurang tahan lama, sehingga tidak cocok untuk mikrokontroler berbiaya murah dan diproduksi secara massal. Pada tahun yang sama, perusahaan Atmel memperkenalkan mikrokontroler pertama yang menggunakan Flash Memory, khusus jenis EEPROM. Kemudian perusahaan lain dengan cepat mengikuti, dengan menggunakan kedua jenis memori tersebut. Interupsi \u00b6 Mikrokontroler harus menyediakan real-time (dapat ditebak, meskipun tidak harus cepat) untuk menanggapi peristiwa dalam sistem tertanam yang mereka kendalikan. Bila ada kejadian tertentu, sebuah sistem interupsi mendapatkan sinyal dari prosesor untuk menangguhkan pengolahan urutan instruksi saat ini dan untuk memulai layanan interupsi rutin (ISR, atau \"interrupt handler\") yang akan melakukan proses pengolahan dibutuhkan berdasarkan sumber interrupt, sebelum kembali ke urutan instruksi asli. Sumber interrupt mungkin perangkat yang berdiri sendiri, dan sering termasuk peristiwa seperti internal timer overflow, menyelesaikan konversi analog ke digital, perubahan tingkat logika pada masukan seperti dari tombol yang ditekan, dan data yang diterima melalui link komunikasi. Di mana konsumsi daya adalah hal yang penting seperti pada perangkat yang menggunakan baterai, interupsi juga dapat membangunkan sebuah mikrokontroler dari keadaan tidur berdaya rendah dimana prosesor dihentikan sampai diperlukan untuk melakukan sesuatu oleh peristiwa (perangkat) disekitarnya. Program \u00b6 Biasanya program mikrokontroler harus dapat dimasukan kedalam memori yang tersedia didalam chip, karena akan menjadi mahal jika harus menyediakan sistem dengan perangkat eksternal, atau memori yang dapat di-upgrade. Compiler dan Assembler digunakan untuk mengkonversi kedua bahasa kode tingkat-tinggi dan bahasa assembly menjadi kode kompak mesin agar bisa disimpan di dalam memori mikrokontroler. Jenis memori tergantung pada perangkat, memori program mungkin permanen, read-only memory yang hanya bisa diprogram oleh pabrik, atau mungkin flash memory, atau read-only memory yang dapat dihapus. Produsen sering membuat versi khusus dari mikrokontroler mereka untuk membantu pengembangan perangkat keras dan perangkat lunak dari sistem target. Awalnya adalah veri EPROM yang memiliki \"jendela\" di bagian atas perangkat yang mana memori program dapat dihapus dengan sinar ultraviolet, siap diprograman ulang setelah pemrograman (\"burn\") dan siklus tes. Sejak tahun 1998, versi EPROM ini menjadi langka dan telah digantikan oleh EEPROM dan Flash, yang lebih mudah digunakan (dapat dihapus secara elektronik) dan lebih murah untuk diproduksi. Versi lain mungkin ROM diakses sebagai perangkat eksternal daripada ditanamkan sebagai memori internal, namun ini menjadi langka karena meluasnya ketersediaan mikrokontroler programmer yang lebih murah. Penggunaan perangkat field-programmable pada mikrokontroler memungkinkan pembaruan pada firmware atau revisi pabrik yang terlambat untuk produk yang telah siap dipasarkan tetapi belum direvisi. Memori Programmable juga mengurangi waktu yang diperlukan untuk penyebaran produk baru. Di mana ratusan ribu perangkat identik yang dibutuhkan, menggunakan bagian yang terprogram pada saat pembuatan akan menjadi lebih ekonomis. Ini bagian \"pelindung program\" memiliki program yang telah ditetapkan dalam cara yang sama seperti logika chip, pada saat yang sama pula. Mikrokontroler dapat disesuaikan dalam menggabungkan blok logika digital yang dapat dipersonalisasi untuk kemampuan pemrosesan tambahan, peripheral dan antarmuka yang disesuaikan dengan kebutuhan aplikasi. Salah satu contohnya adalah AT91CAP yang diproduksi oleh perusahaan Atmel. Fitur Lain Mikrokontroler \u00b6 Selain fitur yang sudah dibahas sebelumnya, ada beberapa fitur lain yang sekarang banyak ditemukan pada berbagai seri mikrokontroler, baik buatan perusahaan Atmel, Microchip, NXP, atau perusahaan lainnya. Diantaranya yaitu: GPIO : Mikrokontroler biasanya terdiri dari beberapa tujuan umum pin input/output (GPIO; General Purpose Input/Output). Pin GPIO dikonfigurasi oleh perangkat lunak yang digunakan sebagai jalur input (masukan) atau keluaran (output). Ketika pin GPIO dikonfigurasi sebagai input, maka biasanya disandingkan dengan perangkat sensor pembaca atau sinyal eksternal. Namun, jika pin GPIO dikonfigurasi sebagai output, biasanya digunakan untuk menggerakan perangkat eksternal seperti LED atau Motor secara tidak langsung, yaitu melalui sumber daya eksternal. Konverter : Banyak Mikrokontroler dengan sistem-tertanam harus membaca sensor yang menghasilkan sinyal analog. Maka dari itulah ditanamkan perangkat konverter analog ke digital (ADC; Analog-to-Digital Converter). Sejak prosesor dibuat hanya mampu untuk menafsirkan dan memproses data digital, yaitu 1 dan 0, prosesor tidak dapat melakukan apa-apa dengan sinyal analog yang dapat dikirimkan kepadanya oleh perangkat lain. Jadi analog ke digital digunakan untuk mengkonversi data yang masuk dan mengubahnya ke dalam bentuk data yang prosesor dapat mengenalinya. Sebuah fitur yang kurang umum pada beberapa mikrokontroler adalah konverter digital-ke-analog (DAC; Digital-to-Analog Converter) yang memungkinkan prosesor untuk mengeluarkan sinyal analog atau tingkatan tegangan. PIT : Selain konverter, banyak mikroprosesor menyediakan berbagai timer juga. Salah satu jenis yang paling umum dari timer adalah Programmable Interval Timer (PIT). Sebuah PIT digunakan untuk menghitung mundur dari suatu nilai ke nilai nol, atau sampai dengan kapasitas hitungan tertentu, hingga sampai ke nol. Setelah mencapai nol, ia akan mengirimkan interupsi ke prosesor menunjukkan bahwa mereka telah selesai menghitung. Hal ini berguna untuk perangkat seperti termostat, yang secara berkala menguji suhu di sekitar mereka untuk melihat apakah mereka perlu mengaktifkan AC, pemanas, atau yang lainnya. PWM : Tersedia juga fasilitas blok Pulse Width Modulation (PWM) yang memungkinkan CPU untuk mengontrol konverter daya, beban resistif, motor, dan lain sebagainya, tanpa menggunakan banyak sumber daya CPU di waktu pengulangan yang singkat. UART : Universal Asynchronous Receiver/Transmitter (UART) blok yang memungkinkan untuk menerima dan mengirim data melalui jalur serial dengan sangat sedikit beban pada CPU. Lainnya : Perangkat yang terintegrasi pada chip juga sering mencakup kemampuan untuk berkomunikasi dengan perangkat lain (chip) dalam format digital seperti Inter-Integrated Circuit (I2C), Serial Peripheral Interface (SPI), Universal Serial Bus (USB), dan juga Ethernet. Integrasi yang Lebih Tinggi \u00b6 Mikrokontroler mungkin tidak mengimplementasikan alamat eksternal atau data bus karena mereka mengintegrasikan RAM dan memori non-volatile pada chip yang sama dengan CPU. Menggunakan pin yang lebih sedikit, chip dapat dibuat lebih kecil, dengan paket yang lebih murah. Mengintegrasikan memori dan peripheral lainnya pada satu chip dan mengujinya sebagai satu unit meningkatkan biaya pembuatan chip, tetapi sering mengakibatkan penurunan biaya total dari sistem tertanam secara keseluruhan. Bahkan jika biaya dari CPU yang telah terintegrasi peripheral sedikit lebih mahal dari biaya CPU dan periferal eksternal, melibatkan lebih sedikit chip biasanya memungkinkan sebuah papan sirkuit yang lebih kecil dan lebih murah, dan mengurangi tenaga kerja yang dibutuhkan untuk merakit dan menguji papan sirkuit, selain itu cenderung menurunkan tingkat kecacatan untuk perakitan akhir. Mikrokontroler adalah suatu sirkuit terpadu yang biasanya dilengkapi fitur berikut: Central Processing Unit - kisaran dari yang kecil dan sederhana yaitu prosesor 4-bit hingga yang kompleks dengan prosesor 32-bit atau 64-bit Volatile Memory (RAM) untuk penyimpanan data ROM, EPROM, EEPROM atau Flash memory untuk program dan penyimpanan parameter operasi Memiliki sedikit input dan output, yang digunakan untuk mengendalikan atau mendeteksi status logika pada masing-masing pin Serial Input/Output seperti halnya serial port (UART) Antarmuka komunikasi serial lainya seperti I2C, Serial Peripheral Interface dan Controller Area Network untuk koneksi antar sistem Perangkat lain seperti pewaktu, penghitung peristiwa, generator PWM, dan watchdog (pengawas kejadian) Generator Pulse, seringkali digunakan osilator seperti Crystal, Resonator, Sirkuit RC Termasuk beberapa ADC dan beberapa DAC Dukungan pemrograman didalam sirkuit (in-circuit programming) dan debugging didalam sirkuit (in-circuit debugging) Integrasi ini secara drastis akan mengurangi jumlah chip, jumlah kabel, dan memperkecil area papan sirkuit yang diperlukan untuk menghasilkan sistem yang hampir sama dengan chip terpisah. Jumlah pin sedikit, karena beberapa pin dapat dihubungkan dengan perangkat internal lainnya dengan fungsi pin yang dikonfigurasi oleh perangkat lunak. Hal ini memberikan keleluasan dalam penggunaanya diberbagai aplikasi daripada jika pin telah ditentukan memiliki fungsi khusus. Beberapa mikrokontroler menggunakan arsitektur Harvard: bus memori terpisah untuk instruksi dan data, yang memungkinkan akses untuk pengambilan diwaktu yang bersamaan. Yang mana arsitektur Harvard digunakan, instruksi untuk prosesor mungkin saja memiliki ukuran sedikit berbeda dari pada panjang memori internal dan register. Sebagai contoh; 12-bit instruksi digunakan dengan register 8-bit. Keputusan untuk mengintegrasikan periferal seringkali kali sulit. Vendor mikrokontroler sering menjual frekwensi operasi dan fleksibilitas desain sistem kepasar tertentu bagi para pelanggan untuk menekan biaya secara keseluruhan. Produsen harus mampu meminimalkan ukuran chip dengan beberapa penambahan fungsi. Arsitektur mikrokontroler sangat bervariasi. Beberapa desain memasukan fungsi umum dari inti mikroprosesor, dengan satu atau lebih ROM, RAM, dan atau fungsi I/O yang terintegrasi didalam paket. Sedangkan desain lain khusus dibuat untuk tujuan aplikasi kontrol. Sekumpulan instruksi mikrokontroler biasanya memiliki banyak instruksi yang bertujuan untuk memanipulasi bit agar tercipta program pengendalian yang lebih kompak. Sebagai contoh, prosesor pada umumnya memerlukan beberapa instruksi untuk melakukan pemeriksaan sebuah bit pada register dan percabangannya jika bit tersebut telah ditentukan, dimana mikrokontroler memiliki instruksi tunggal untuk menetapkan fungsi yang diperlukan. Mikrokontroler biasanya tidak memiliki prosesor pembantu perhitungan, jadi perhitungan aritmatika dilakukan oleh perangkat lunak. Lingkup Pemrograman \u00b6 Mikrokontroler awalnya diprogram hanya dalam bahasa assembly, tetapi berbagai bahasa pemrograman tingkat tinggi, seperti C, Python dan JavaScript, sekarang juga umum digunakan untuk menargetkan mikrokontroler dan sistem-tertanam. Bahasa tersebut ada yang dirancang khusus, namun ada juga bahasa dengan tujuan umum seperti bahasa pemrograman C. Compiler untuk bahasa dengan tujuan umum biasanya akan memiliki beberapa pembatasan serta memerlukan perangkat tambahan untuk lebih mendukung karakteristik unik dari mikrokontroler. Beberapa mikrokontroler memiliki perangkat lunak khusus untuk membantu pengembang dalam membuat aplikasi tertentu. Vendor mikrokontroler juga biasanya sering membuat alat yang bebas untuk dibuat dan dikembangkan agar lebih mudah dalam mengadopsi perangkat keras yang mereka buat. Simulator dalam bentuk perangkat lunak biasanya tersedia untuk beberapa mikrokontroler. Ini memungkinkan pengembang untuk menganalisis tentang perilaku mikrokontroler dan program sebelum mereka menggunakan komponen yang sebenarnya. Sebuah simulator akan menunjukkan keadaan internal prosesor dan juga output, serta memungkinkan sinyal masukan yang akan dihasilkan. Namun, simulator memiliki beberapa keterbatasan, salah satunya yaitu simulator tidak dapat mensimulasikan banyak perangkat keras didalam sistem, kondisi seperti ini tentunya menyulitkan pengguna untuk mengetahui kinerja sebenarnya secara fisik. Mikrokontroler baru-baru mengintegrasikan sirkuit on-chip debug yang mampu diakses oleh emulator melalui JTAG, memungkinkan debugging dari firmware dengan debugger. Real-time ICE memungkinkan untuk melihat dan atau memanipulasi status internal yang sedang berjalan. ICE tracing dapat merekam program yang dijalankan dan status MCU sebelum atau sesudah dipicu. Interrupt Latency Coming soon... Jenis Mikrokontroler Coming soon... Volume \u00b6 Biaya produksi menurun dari waktu ke waktu, mikrokontroler 8-bit termurah dijual di bawah $0,25 dalam jumlah ribuan pada tahun 2009, dan beberapa mikrokontroler 32-bit dijual sekitar $1 untuk jumlah yang sama. Saat ini mikrokontroler dengan harga murah tersedia untuk para penggemar mikrokontroler, dengan komunitas online besar pada jenis prosesor tertentu. Di masa depan, MRAM berpotensi dapat digunakan di mikrokontroler karena memiliki daya tahan yang tak terbatas dan biaya yang terus menurun pada proses pembuatan wafer semikonduktor. Pada tahun 2002, sekitar 55% dari semua CPU yang terjual di dunia adalah mikrokontroler 8-bit dan mikroprosesor. Lebih dari dua miliar mikrokontroler 8-bit terjual pada tahun 1997, dan menurut Semico, lebih dari empat miliar mikrokontroler 8-bit terjual pada tahun 2006. Baru-baru ini, Semico telah mengklaim pasar MCU tumbuh 36,5% pada tahun 2010 dan 12% pada tahun 2011. Sebuah rumah khusus di negara maju cenderung memiliki hanya empat jenis umum mikroprosesor tetapi terbentuk sekitar tiga lusin mikrokontroler. Sebuah mobil khusus kelas menengah memiliki sebanyak 30 atau lebih mikrokontroler. Mereka juga dapat ditemukan di banyak perangkat listrik seperti mesin cuci, oven microwave, dan telepon. Secara historis, segmen 8-bit telah mendominasi pasar MCU. 16-bit mikrokontroler menjadi kategori volume MCU yang terbesar pada tahun 2011, menyalip perangkat 8-bit untuk pertama kalinya di tahun itu. IC Insights percaya peningkatan pasar MCU akan mengalami perubahan substansial dalam lima tahun ke depan dengan perangkat 32-bit yang terus meraih pangsa lebih besar dari penjualan dan volume unit. Tahun 2017, MCU 32-bit diharapkan dapat meraih 55% dari penjualan mikrokontroler. Dalam hal volume unit, MCU 32-bit diharapkan mencatat 38% dari penjualan mikrokontroler pada tahun 2017, sedangkan perangkat 16-bit akan mewakili 34% dari total, dan desain 4/8-bit diperkirakan memperoleh 28% dari unit yang terjual tahun itu. Pasar MCU 32-bit diperkirakan akan tumbuh pesat karena meningkatnya permintaan untuk tingkat yang lebih presisi dalam sistem pengolahan-embedded dan pertumbuhan konektivitas pengguna Internet. Pada beberapa tahun ke depan, MCU 32-bit kompleks diharapkan melakukan perhitungan lebih dari 25% dari kekuatan pemrosesan dalam kendaraan. IC Insights, Pasar MCU sedang migrasi ke 32-bit dan Perangkat berbasis ARM Pada tahun 2012, menyusul krisis global - penurunan penjualan terburuk yang pernah terjadi dan pemulihan dan rata-rata harga jual turun 17% - penurunan terbesar sejak tahun 1980-an, harga rata-rata untuk mikrokontroler adalah 0,88 USD ($0,69 untuk 4/8-bit, $0,59 untuk 16-bit, $1,76 untuk 32-bit). Pada tahun 2012, penjualan di seluruh dunia dari mikrokontroler 8-bit adalah sekitar $4 milyar karena mikrokontroler tipe ini begitu dibutuhkan untuk pengembangan teknologi yang lebih baik. Pada tahun 2012, mikrokontroler 4-bit juga mengalami penjualan yang signifikan. Pada 2015, mikrokontroler 8-bit dapat dibeli dengan harga $0,311 (1.000 unit), 16-bit seharga $0,385 (1.000 unit), dan 32-bit seharga $0,378 (1.000 unit tapi dapat juga seharga $ 0,35 untuk 5.000 unit).","title":"Mengenal Mikrokontroler"},{"location":"papan/mikrokontroler/#mengenal-mikrokontroler","text":"Memang cukup membingungkan ketika mendengar istilah Mikrokontroler dan Mikroprosesor. Bagi para pengguna yang masih awam kedua istilah diatas dianggap sama, bahkan ada yang menganggap hanya beda istilah saja. Anggapan tersebut tidak salah 100% namun juga tidak benar 100%. Mikrokontroler dan Mikroprosesor adalah dua benda yang beda target penggunaan, beda kelengkapan fungsinya dan beda perusahaan yang awal menciptakan, namun berangkat dari ide yang sama, arsitektur yang sama, bahkan dari tahun lahir yang hampir sama pula. Lalu apa sebenarnya Mikrokontroler dan Mikroprosesor? Dalam dunia komputer dan mikroelektronik, banyak pengguna yang menghabiskan banyak dana untuk memiliki Mikroprosesor. Sebagian besar orang mengabaikan sebuah penemuan penting yang sempat mencapai kejayaann pada masanya, penemuan itu adalah Mikrokontroler. Kita tidak menyadari bahwa disekitar rumah kita, ada sekitar 5 hingga 20 perangkat elektronik yang dikendalikan oleh Mikrokontroler. Begitulah faktanya, karena lebih dari 2 miliar Mikrokontroler diproduksi setiap tahunnya. Hal ini berarti, sangat tidak mungkin manusia di era sekarang ini hidup tanpa Mikrokontroler. Mikrokontroler merupakan kepingan komputer terintegrasi yang mengendalikan sebagian besar perangkat elektronik disekitar kita yang hampir setiap hari digunakan, dari mulai gadget, mesin cuci, mesin pembuat kopi, remote kontrol, mainan anak-anak, televisi, hingga ke kendaraan. Lalu bagaimana ide tentang Mikrokontroler dan Mikroprosesor ini muncul? Lalu siapa yang pertama kali membuatnya?","title":"Mengenal Mikrokontroler"},{"location":"papan/mikrokontroler/#mikrokontroler","text":"Mikrokontroler atau MCU (singkatan dari Microcontroller Unit) atau ada juga yang menyebut Mikrokomputer adalah komputer kecil pada sirkuit terpadu (IC) tunggal yang didalamnya berisi inti prosesor, memori, dan periferal Input/Output terprogram. Program memori dalam bentuk Ferroelectric RAM, NOR \ufb02ash atau OTP ROM juga sering ditanamkan didalam kepingan Mikrokontroler, serta sejumlah kecil RAM. Karena itulah, Mikrokontroler dapat berdiri sendiri untuk menjalankan suatu fungsi tanpa perlu bantuan perangkat penunjang kinerja. Gambar 1. Blok Diagram Mikrokontroler Sangat kontras dengan Mikroprosesor yang membutuhkan perangkat eksternal sebagai penunjang kinerja agar bisa menjalankan suatu fungsi. Perangkat penunjang kinerja tersebut misalnya; RAM, ROM, chip Input/Output (BIOS), dan lain sebagainya. Yang kesemuanya itu adalah perangkat terpisah yang dihubungkan ke Mikroprosesor dengan sebuah perantara (biasanya ada di motherboard).","title":"Mikrokontroler"},{"location":"papan/mikrokontroler/#sejarah-mikrokontroler","text":"Selama kurun waktu 1970 hingga 1971, perusahaan Intel sedang bersemangat untuk menciptakan Mikroprosesor pertama didunia. 1971 Intel merilis Mikroprosesor pertamanya yaitu Intel 4004 4-bit, kemudian diikuti Intel 8008 dan beberapa Mikroprosesor yang lebih mumpuni tersedia dipasaran beberapa tahun berikutnya. Namun, kedua Mikroprosesor tersebut membutuhkan perangkat eksternal lain untuk dapat bekerja menjalankan suatu fungsi dan ini tentunya akan meningkatkan biaya total pembuatan suatu perangkat, sehingga sangat mustahil menciptakan peralatan komputerisasi yang ekonomis. Gary Boone dan Michael Cochran, insinyur di Texas Instruments bekerja pada konsep yang hampir sama dengan Intel diawal-awal tahun 1970-an. Gambar 2. Mikroprosesor Intel 4004, 1971 Pada mulanya bisnis di Departemen MOS Texas Instruments adalah bisnis yang sesuai pesanan, dimana perusahaan seperti halnya pabrik kalkulator desktop datang ke Texas Instruments dengan beberapa set pengajuan spesifik. Texas Instruments kemudian mengkonversi spesifikasi tersebut ke dalam kepingan chip terpisah, yang terdiri dari empat, lima atau enam chip untuk menjalankan atau melaksanakan suatu spesifikasi dari perusahaan-perusahaan populer seperti Canon, Olympia, atau Olivetti. Untuk perusahaan-perusahaan tersebut, pekerjaan Texas Instruments sangatlah menakjubkan karena mampu memberikan pelayanan yang memuaskan dengan menekan banyak unit hanya menjadi sekitar empat, lima atau enam chip saja. Saat itu teknologi yang sangat populer adalah TTL, yang membutuhkan sekitar 100 hingga 200 chip. Sangat wajar jika bisnis ini merupakan bisnis yang menggairahkan bagi Texas Instruments. Gambar 3. Kalkulator Texas Instruments, 1974 Selama waktu itu Gary Boone melakukan penelitian yang lebih luas dengan melibatkan beberapa orang dari negara lain seperti Jerman, Itali, dan dari beberapa negara lainnya. Mereka mencoba memahami kebutuhkan pelanggan-pelanggan baru dan menyelesaikan pesanannya. Boone pada akhirnya merasa bosan setelah melakukan hal tersebut berulang kali. Selain itu, sejak proyek-proyek sebelumnya berhasil dan mereka memiliki sekumpulan pelanggan-pelanggan setia, pelanggan-pelanggan baru meminta pekerjaan yang sama seperti yang orang lain pesan ditahun-tahun sebelumnya. Sehingga, ini berarti menjadi tuntutan untuk melakukan hal yang sama, lagi dan lagi pada setiap proyek yang dikerjakan. Aturan umum di Texas Instruments adalah \"one riot, one ranger\" yang berarti \"satu chip, satu insinyur\". Jadi, jika Texas Instruments memiliki 12 insinyur desainer MOS maka mereka di pecah menjadi tiga atau empat bagian untuk mengerjakan satu proyek diwaktu yang sama. Dan itu membutuhkan waktu sekitar enam bulan untuk menyelesaikan satu proyek. Oleh karena itu, kapasitas bisnis adalah jumlah insinyur di bagi jumlah chip, satu kasus dalam setiap enam bulan. Walaupun permintaan dari masing-masing proyek berbeda secara detail, namun pada prinsip umum semua proses pekerjaan adalah sama saja. Hal ini membuat para insinyur merasa lelah untuk mengerjakan proyek-proyek yang monoton. Mereka bekerja dalam jangka waktu yang cukup lama dan mereka merasa telah melakukan yang terbaik untuk menyelesaikan suatu proyek. Boone dan para insinyur akhirnya memikirkan acuan satu arah yang dibutuhkan konsumen dan potongan rangkaian atau blok-blok fungsi dengan metode lain. Boone dapat menemukan penggunaan komponen yang sama, ia dan yang lainnya mempertimbangkan gagasan simulasi, \"Baiklah, mungkin jika sekarang kita memiliki beberapa byte didalam penyimpanan data, beberapa byte didalam penyimpanan program, dan memiliki beberapa bit untuk memindai antarmuka keyboard, maka itu akan mencakup semua spesifikasi yang kira-kira saya ketahui\". Sebagai penemuan terbaik dari gagasan ini maka lahirlah kepingan Mikrokontroler yang petama kali, tepatnya di bulan September 1971 yaitu TMS0100. Gambar 4. Mikrokontroler Pertama TMS0100 Salah satu aspek teknis yang penting sekali adalah bahwa desain teknologi pada saat itu sangat tidak efisien dalam memanfaatkan silicon. Arsitektur yang berbeda kemudian harus dipilih sehingga struktur lebih teratur dan penggunaan memori lebih ditekan, selain itu, pitch-matching juga harus diberi penekanan sehingga konsep bit-slice cocok di berbagai kebutuhan pada masing-masing 4 bit dari penambah 4 bit ditata menjadi dimensi yang sama dalam hal fisik. Hanya dengan itu akan ada kecocokan dan keselarasan didalam pitch. Pada akhirnya, faktor lain dari tiga atau empat dalam hal kepadatan silikon akan tercapai. Terlepas dari kendala arsitektur terutama pada orientasi memori dan pitch-matching, kemudian Mikrokontroler diciptakan lebih baik dari pada teknologi sebelumya (disebut TTL) dan akhirnya mampu memaksimalkan penggunaan silicon yang lebih efisien. Gambar 5. Bagian Mikrokontroler TMS0100 merupakan kepingan tunggal yang digunakan untuk mengendalikan mesin kalkulator. Setelah Mikrokontroler pertama ini berhasil, Gary Boone dan Michael Cochran kemudian mengembangkan desainnya, lahirlah turunan TMS0100 yaitu TMX1795. Pada tanggal 31 Agustus 1971, Boone mendaftarkan hak paten hasil penemuannya untuk mesin pengolah kepingan tunggal (single-chip). Tanggal 4 September 1973, Gary Boone memperoleh penghargaan U.S. Patent 3,757,306. Berbekal pengalaman selama proses pembuatan TMS0100 dan Prototipe Mikrokontroler 8-bit buatannya, Boone kemudian mendesain Mikrokontroler 4-bit seri TMS1000. Boone memperoleh penghargaan U.S. Patent 4,074,351 untuk penemuan Mikrokontroler Modern. Setelah dilakukan beberapa perbaikan kecil, Texas Instruments merilis mikrokontroler TMS1000 untuk dijual ke industri elektronik di tahun 1974. Mikrokontroler ini tersedia dalam berbagai konfigurasi ukuran ROM dan RAM. Keluarga TMS1000 dijual kepasaran dengan harga murah, sehingga meraih sukses besar dan disukai oleh industri elektronika saat itu. Selain karena harganya yang murah, keluarga TMS1000 dapat diprogram untuk melakukan fungsi yang berbeda, sehingga beberapa industri elektronik saat itu menciptakan banyak produk seperti oven microwave, video permainan, mesin cuci, jukebox, mainan anak-anak, alat-alat, permainan dan ratusan produk elektronik lainnya. Sampai tahun 1983, keluarga TMS1000 terjual lebih dari 100 juta keping. Wow!!! Gambar 6. Mikrokontroler TMS1000, 1974","title":"Sejarah Mikrokontroler"},{"location":"papan/mikrokontroler/#mikrokontroler-seri-tms1000","text":"Setelah kesuksesan TMS1000 dipasaran, Texas Instruments kemudian mengembangkan keluarga TMS1000 menjadi beberapa varian seperti pada tabel dibawah ini: Nomor Seri ROM RAM I/O Pin Teknologi Catatan TMS1000 1KB 64x4 23 pMOS - TMS1000C 1KB 64x4 23 CMOS Identik dengan TMS1000, CMOS TMS1018 - 64x4 4 pMOS - TMS1070 1KB 64x4 - pMOS Built-in VF display controller TMS1098 - 128x4 - pMOS - TMS1099 - 64x4 - pMOS - TMS1099C - 64x4 - CMOS Identik dengan TMS1099, CMOS TMS1100 2KB 128x4 - pMOS - TMS1117 2KB 128x4 - pMOS - TMS1200 1KB 64x4 - pMOS - TMS1200C 1KB 64x4 - CMOS Identik dengan TMS1200, CMOS TMS1270 1KB 64x4 - pMOS - TMS1300 2KB 128x8 23 pMOS - TMS1400 4KB 128x4 22 pMOS - TMS1600 4KB 128x4 33 pMOS - TMS1700 512B 32x4 21 pMOS - TMS2000 1KB 64x4 - nMOS versi nMOS untuk TMS1000 TMS2100 2KB 128x4 - nMOS versi nMOS untuk TMS1100 TMS2200 1KB 64x4 - nMOS versi nMOS untuk TMS1200 TMS2300 2KB 128x4 - nMOS versi nMOS untuk TMS1300 TMS2098 - 128x4 - nMOS Contoh Developer TMS2099 - 164x4 - nMOS Contoh Developer","title":"Mikrokontroler Seri TMS1000"},{"location":"papan/mikrokontroler/#mikrokontroler-intel","text":"Disisi perusahaan lain, sebagai tanggapan terhadap keberadaan kepingan tunggal Mikrokontroler TMS1000, Intel tidak mau ketinggalan mengembangkan Mikrokontroler. Intel mengembangkan sistem komputer pada chip yang dioptimalkan untuk aplikasi kontrol, maka lahirlah Mikrokontroler Intel pertama yaitu Intel 8048 (termasuk 8048, 8035, dan 8749). Seri MCS-48 termasuk didalamnya Intel 8048 dirilis ke pasar pada tahun 1976, 2 tahun lebih lambat dari pada TMS1000. Intel 8048 menggabungkan RAM dan ROM didalam satu kepingan, menggunakan teknologi NMOS, dan menggunakan arsitektur Harvard yang telah dimodifikasi. Chip ini ditanamkan sebagai pengendali pada Keyboard PC produk IBM. Chip ini akan ditemukan didalam 1 miliar keyboard PC dan berbagai aplikasi lainnya. Pada saat itu Presiden Intel, Lukas J. Valenter, menyatakan bahwa mikrokontroler ini adalah salah satu yang paling sukses dalam sejarah perusahaan Intel, dan anggaran divisi ini ditambah lebih dari 25%. Gambar 7. Mikrokontroler Intel 8048, 1977 Pada tahun 1980, Intel kembali memperkenalkan seri MCS-51, termasuk didalamnya Mikrokontroler 8051 dengan teknologi CMOS dan ini menjadi Mikrokontroler paling populer yang digunakan. Bahkan Intel 8051 digunakan hingga hari ini, sehingga menjadi salah satu Mikrokontroler yang berumur panjang.","title":"Mikrokontroler Intel"},{"location":"papan/mikrokontroler/#embedded-design","text":"Sebuah mikrokontroler dapat dianggap sebagai sistem mandiri dengan prosesor, memori dan periferal dan dapat digunakan sebagai sistem embedded (sistem-tertanam). Mayoritas mikrokontroler yang digunakan saat ini tertanam di mesin secara langsung, seperti di mobil, telepon, peralatan, dan peripheral untuk sistem komputer. Sementara beberapa embedded system yang sangat canggih, banyak memiliki persyaratan minimal untuk memori dan panjang program, dengan tidak ada sistem operasi, dan kompleksitas perangkat lunak yang rendah. Perangkat khusus input dan output meliputi switch, relay, solenoid, LED , Layar LCD kecil, perangkat frekuensi radio, dan sensor-sensor untuk data seperti suhu, kelembaban, tingkat cahaya dan lain-lain. Embedded sistem biasanya tidak memiliki keyboard, layar, disk, printer, atau perangkat lain yang biasa ditemukan di I/O dari komputer pribadi, dan mungkin tidak memiliki perangkat interaksi manusia apapun. Gambar 8. Arduino Mega2560","title":"Embedded Design"},{"location":"papan/mikrokontroler/#erasable-programmable-memory","text":"Sekitar tahun 1990, mikrokontroler terus dikembangkan, salah satu teknologi yang cukup populer adalah Erasable Programmable ROM (EPROM), yaitu memori yang dapat dihapus dan diprogram ulang. Mikrokontroler ini memiliki jendela kaca transparan pada bagian atasnya, jika bagian ini terpapar sinar ultraviolet maka memori akan terhapus. Tipe ini biasanya digunakan hanya sebagai prototipe. Tipe lainnya adalah Programmed ROM oleh produsen, varian PROM hanya bisa diprogram sekali. Varian ini di tandai dengan penunjukan OTP (one-time programmable). PROM adalah jenis yang sama seperti halnya EPROM, tetapi karena tidak ada cara untuk memasukan sinar ultraviolet kedalam chip, maka memori tidak dapat dihapus. Versi yang bisa dihapus memerlukan jendela kuarsa, membuat versi ini lebih mahal dibandingkan versi OTP yang biasanya terbuat dari plastik buram. Gambar 9. Intel 8749 UV EPROM, 1980 Tahun 1993, pengenalan memori jenis EEPROM (Electrically Erasable Programmable ROM) yang memungkinkan memori mikrokontroler dihapus dengan cepat secara elektris tanpa paket yang mahal seperti halnya EPROM, membuat proses prototipe lebih cepat dan In System Programming. Teknologi ini diawali oleh perusahaan Microchip pada chip seri PIC16x84. Teknologi EEPROM telah tersedia sebelumnya, tapi EEPROM sebelumnya lebih mahal dan kurang tahan lama, sehingga tidak cocok untuk mikrokontroler berbiaya murah dan diproduksi secara massal. Pada tahun yang sama, perusahaan Atmel memperkenalkan mikrokontroler pertama yang menggunakan Flash Memory, khusus jenis EEPROM. Kemudian perusahaan lain dengan cepat mengikuti, dengan menggunakan kedua jenis memori tersebut.","title":"Erasable Programmable Memory"},{"location":"papan/mikrokontroler/#interupsi","text":"Mikrokontroler harus menyediakan real-time (dapat ditebak, meskipun tidak harus cepat) untuk menanggapi peristiwa dalam sistem tertanam yang mereka kendalikan. Bila ada kejadian tertentu, sebuah sistem interupsi mendapatkan sinyal dari prosesor untuk menangguhkan pengolahan urutan instruksi saat ini dan untuk memulai layanan interupsi rutin (ISR, atau \"interrupt handler\") yang akan melakukan proses pengolahan dibutuhkan berdasarkan sumber interrupt, sebelum kembali ke urutan instruksi asli. Sumber interrupt mungkin perangkat yang berdiri sendiri, dan sering termasuk peristiwa seperti internal timer overflow, menyelesaikan konversi analog ke digital, perubahan tingkat logika pada masukan seperti dari tombol yang ditekan, dan data yang diterima melalui link komunikasi. Di mana konsumsi daya adalah hal yang penting seperti pada perangkat yang menggunakan baterai, interupsi juga dapat membangunkan sebuah mikrokontroler dari keadaan tidur berdaya rendah dimana prosesor dihentikan sampai diperlukan untuk melakukan sesuatu oleh peristiwa (perangkat) disekitarnya.","title":"Interupsi"},{"location":"papan/mikrokontroler/#program","text":"Biasanya program mikrokontroler harus dapat dimasukan kedalam memori yang tersedia didalam chip, karena akan menjadi mahal jika harus menyediakan sistem dengan perangkat eksternal, atau memori yang dapat di-upgrade. Compiler dan Assembler digunakan untuk mengkonversi kedua bahasa kode tingkat-tinggi dan bahasa assembly menjadi kode kompak mesin agar bisa disimpan di dalam memori mikrokontroler. Jenis memori tergantung pada perangkat, memori program mungkin permanen, read-only memory yang hanya bisa diprogram oleh pabrik, atau mungkin flash memory, atau read-only memory yang dapat dihapus. Produsen sering membuat versi khusus dari mikrokontroler mereka untuk membantu pengembangan perangkat keras dan perangkat lunak dari sistem target. Awalnya adalah veri EPROM yang memiliki \"jendela\" di bagian atas perangkat yang mana memori program dapat dihapus dengan sinar ultraviolet, siap diprograman ulang setelah pemrograman (\"burn\") dan siklus tes. Sejak tahun 1998, versi EPROM ini menjadi langka dan telah digantikan oleh EEPROM dan Flash, yang lebih mudah digunakan (dapat dihapus secara elektronik) dan lebih murah untuk diproduksi. Versi lain mungkin ROM diakses sebagai perangkat eksternal daripada ditanamkan sebagai memori internal, namun ini menjadi langka karena meluasnya ketersediaan mikrokontroler programmer yang lebih murah. Penggunaan perangkat field-programmable pada mikrokontroler memungkinkan pembaruan pada firmware atau revisi pabrik yang terlambat untuk produk yang telah siap dipasarkan tetapi belum direvisi. Memori Programmable juga mengurangi waktu yang diperlukan untuk penyebaran produk baru. Di mana ratusan ribu perangkat identik yang dibutuhkan, menggunakan bagian yang terprogram pada saat pembuatan akan menjadi lebih ekonomis. Ini bagian \"pelindung program\" memiliki program yang telah ditetapkan dalam cara yang sama seperti logika chip, pada saat yang sama pula. Mikrokontroler dapat disesuaikan dalam menggabungkan blok logika digital yang dapat dipersonalisasi untuk kemampuan pemrosesan tambahan, peripheral dan antarmuka yang disesuaikan dengan kebutuhan aplikasi. Salah satu contohnya adalah AT91CAP yang diproduksi oleh perusahaan Atmel.","title":"Program"},{"location":"papan/mikrokontroler/#fitur-lain-mikrokontroler","text":"Selain fitur yang sudah dibahas sebelumnya, ada beberapa fitur lain yang sekarang banyak ditemukan pada berbagai seri mikrokontroler, baik buatan perusahaan Atmel, Microchip, NXP, atau perusahaan lainnya. Diantaranya yaitu: GPIO : Mikrokontroler biasanya terdiri dari beberapa tujuan umum pin input/output (GPIO; General Purpose Input/Output). Pin GPIO dikonfigurasi oleh perangkat lunak yang digunakan sebagai jalur input (masukan) atau keluaran (output). Ketika pin GPIO dikonfigurasi sebagai input, maka biasanya disandingkan dengan perangkat sensor pembaca atau sinyal eksternal. Namun, jika pin GPIO dikonfigurasi sebagai output, biasanya digunakan untuk menggerakan perangkat eksternal seperti LED atau Motor secara tidak langsung, yaitu melalui sumber daya eksternal. Konverter : Banyak Mikrokontroler dengan sistem-tertanam harus membaca sensor yang menghasilkan sinyal analog. Maka dari itulah ditanamkan perangkat konverter analog ke digital (ADC; Analog-to-Digital Converter). Sejak prosesor dibuat hanya mampu untuk menafsirkan dan memproses data digital, yaitu 1 dan 0, prosesor tidak dapat melakukan apa-apa dengan sinyal analog yang dapat dikirimkan kepadanya oleh perangkat lain. Jadi analog ke digital digunakan untuk mengkonversi data yang masuk dan mengubahnya ke dalam bentuk data yang prosesor dapat mengenalinya. Sebuah fitur yang kurang umum pada beberapa mikrokontroler adalah konverter digital-ke-analog (DAC; Digital-to-Analog Converter) yang memungkinkan prosesor untuk mengeluarkan sinyal analog atau tingkatan tegangan. PIT : Selain konverter, banyak mikroprosesor menyediakan berbagai timer juga. Salah satu jenis yang paling umum dari timer adalah Programmable Interval Timer (PIT). Sebuah PIT digunakan untuk menghitung mundur dari suatu nilai ke nilai nol, atau sampai dengan kapasitas hitungan tertentu, hingga sampai ke nol. Setelah mencapai nol, ia akan mengirimkan interupsi ke prosesor menunjukkan bahwa mereka telah selesai menghitung. Hal ini berguna untuk perangkat seperti termostat, yang secara berkala menguji suhu di sekitar mereka untuk melihat apakah mereka perlu mengaktifkan AC, pemanas, atau yang lainnya. PWM : Tersedia juga fasilitas blok Pulse Width Modulation (PWM) yang memungkinkan CPU untuk mengontrol konverter daya, beban resistif, motor, dan lain sebagainya, tanpa menggunakan banyak sumber daya CPU di waktu pengulangan yang singkat. UART : Universal Asynchronous Receiver/Transmitter (UART) blok yang memungkinkan untuk menerima dan mengirim data melalui jalur serial dengan sangat sedikit beban pada CPU. Lainnya : Perangkat yang terintegrasi pada chip juga sering mencakup kemampuan untuk berkomunikasi dengan perangkat lain (chip) dalam format digital seperti Inter-Integrated Circuit (I2C), Serial Peripheral Interface (SPI), Universal Serial Bus (USB), dan juga Ethernet.","title":"Fitur Lain Mikrokontroler"},{"location":"papan/mikrokontroler/#integrasi-yang-lebih-tinggi","text":"Mikrokontroler mungkin tidak mengimplementasikan alamat eksternal atau data bus karena mereka mengintegrasikan RAM dan memori non-volatile pada chip yang sama dengan CPU. Menggunakan pin yang lebih sedikit, chip dapat dibuat lebih kecil, dengan paket yang lebih murah. Mengintegrasikan memori dan peripheral lainnya pada satu chip dan mengujinya sebagai satu unit meningkatkan biaya pembuatan chip, tetapi sering mengakibatkan penurunan biaya total dari sistem tertanam secara keseluruhan. Bahkan jika biaya dari CPU yang telah terintegrasi peripheral sedikit lebih mahal dari biaya CPU dan periferal eksternal, melibatkan lebih sedikit chip biasanya memungkinkan sebuah papan sirkuit yang lebih kecil dan lebih murah, dan mengurangi tenaga kerja yang dibutuhkan untuk merakit dan menguji papan sirkuit, selain itu cenderung menurunkan tingkat kecacatan untuk perakitan akhir. Mikrokontroler adalah suatu sirkuit terpadu yang biasanya dilengkapi fitur berikut: Central Processing Unit - kisaran dari yang kecil dan sederhana yaitu prosesor 4-bit hingga yang kompleks dengan prosesor 32-bit atau 64-bit Volatile Memory (RAM) untuk penyimpanan data ROM, EPROM, EEPROM atau Flash memory untuk program dan penyimpanan parameter operasi Memiliki sedikit input dan output, yang digunakan untuk mengendalikan atau mendeteksi status logika pada masing-masing pin Serial Input/Output seperti halnya serial port (UART) Antarmuka komunikasi serial lainya seperti I2C, Serial Peripheral Interface dan Controller Area Network untuk koneksi antar sistem Perangkat lain seperti pewaktu, penghitung peristiwa, generator PWM, dan watchdog (pengawas kejadian) Generator Pulse, seringkali digunakan osilator seperti Crystal, Resonator, Sirkuit RC Termasuk beberapa ADC dan beberapa DAC Dukungan pemrograman didalam sirkuit (in-circuit programming) dan debugging didalam sirkuit (in-circuit debugging) Integrasi ini secara drastis akan mengurangi jumlah chip, jumlah kabel, dan memperkecil area papan sirkuit yang diperlukan untuk menghasilkan sistem yang hampir sama dengan chip terpisah. Jumlah pin sedikit, karena beberapa pin dapat dihubungkan dengan perangkat internal lainnya dengan fungsi pin yang dikonfigurasi oleh perangkat lunak. Hal ini memberikan keleluasan dalam penggunaanya diberbagai aplikasi daripada jika pin telah ditentukan memiliki fungsi khusus. Beberapa mikrokontroler menggunakan arsitektur Harvard: bus memori terpisah untuk instruksi dan data, yang memungkinkan akses untuk pengambilan diwaktu yang bersamaan. Yang mana arsitektur Harvard digunakan, instruksi untuk prosesor mungkin saja memiliki ukuran sedikit berbeda dari pada panjang memori internal dan register. Sebagai contoh; 12-bit instruksi digunakan dengan register 8-bit. Keputusan untuk mengintegrasikan periferal seringkali kali sulit. Vendor mikrokontroler sering menjual frekwensi operasi dan fleksibilitas desain sistem kepasar tertentu bagi para pelanggan untuk menekan biaya secara keseluruhan. Produsen harus mampu meminimalkan ukuran chip dengan beberapa penambahan fungsi. Arsitektur mikrokontroler sangat bervariasi. Beberapa desain memasukan fungsi umum dari inti mikroprosesor, dengan satu atau lebih ROM, RAM, dan atau fungsi I/O yang terintegrasi didalam paket. Sedangkan desain lain khusus dibuat untuk tujuan aplikasi kontrol. Sekumpulan instruksi mikrokontroler biasanya memiliki banyak instruksi yang bertujuan untuk memanipulasi bit agar tercipta program pengendalian yang lebih kompak. Sebagai contoh, prosesor pada umumnya memerlukan beberapa instruksi untuk melakukan pemeriksaan sebuah bit pada register dan percabangannya jika bit tersebut telah ditentukan, dimana mikrokontroler memiliki instruksi tunggal untuk menetapkan fungsi yang diperlukan. Mikrokontroler biasanya tidak memiliki prosesor pembantu perhitungan, jadi perhitungan aritmatika dilakukan oleh perangkat lunak.","title":"Integrasi yang Lebih Tinggi"},{"location":"papan/mikrokontroler/#lingkup-pemrograman","text":"Mikrokontroler awalnya diprogram hanya dalam bahasa assembly, tetapi berbagai bahasa pemrograman tingkat tinggi, seperti C, Python dan JavaScript, sekarang juga umum digunakan untuk menargetkan mikrokontroler dan sistem-tertanam. Bahasa tersebut ada yang dirancang khusus, namun ada juga bahasa dengan tujuan umum seperti bahasa pemrograman C. Compiler untuk bahasa dengan tujuan umum biasanya akan memiliki beberapa pembatasan serta memerlukan perangkat tambahan untuk lebih mendukung karakteristik unik dari mikrokontroler. Beberapa mikrokontroler memiliki perangkat lunak khusus untuk membantu pengembang dalam membuat aplikasi tertentu. Vendor mikrokontroler juga biasanya sering membuat alat yang bebas untuk dibuat dan dikembangkan agar lebih mudah dalam mengadopsi perangkat keras yang mereka buat. Simulator dalam bentuk perangkat lunak biasanya tersedia untuk beberapa mikrokontroler. Ini memungkinkan pengembang untuk menganalisis tentang perilaku mikrokontroler dan program sebelum mereka menggunakan komponen yang sebenarnya. Sebuah simulator akan menunjukkan keadaan internal prosesor dan juga output, serta memungkinkan sinyal masukan yang akan dihasilkan. Namun, simulator memiliki beberapa keterbatasan, salah satunya yaitu simulator tidak dapat mensimulasikan banyak perangkat keras didalam sistem, kondisi seperti ini tentunya menyulitkan pengguna untuk mengetahui kinerja sebenarnya secara fisik. Mikrokontroler baru-baru mengintegrasikan sirkuit on-chip debug yang mampu diakses oleh emulator melalui JTAG, memungkinkan debugging dari firmware dengan debugger. Real-time ICE memungkinkan untuk melihat dan atau memanipulasi status internal yang sedang berjalan. ICE tracing dapat merekam program yang dijalankan dan status MCU sebelum atau sesudah dipicu. Interrupt Latency Coming soon... Jenis Mikrokontroler Coming soon...","title":"Lingkup Pemrograman"},{"location":"papan/mikrokontroler/#volume","text":"Biaya produksi menurun dari waktu ke waktu, mikrokontroler 8-bit termurah dijual di bawah $0,25 dalam jumlah ribuan pada tahun 2009, dan beberapa mikrokontroler 32-bit dijual sekitar $1 untuk jumlah yang sama. Saat ini mikrokontroler dengan harga murah tersedia untuk para penggemar mikrokontroler, dengan komunitas online besar pada jenis prosesor tertentu. Di masa depan, MRAM berpotensi dapat digunakan di mikrokontroler karena memiliki daya tahan yang tak terbatas dan biaya yang terus menurun pada proses pembuatan wafer semikonduktor. Pada tahun 2002, sekitar 55% dari semua CPU yang terjual di dunia adalah mikrokontroler 8-bit dan mikroprosesor. Lebih dari dua miliar mikrokontroler 8-bit terjual pada tahun 1997, dan menurut Semico, lebih dari empat miliar mikrokontroler 8-bit terjual pada tahun 2006. Baru-baru ini, Semico telah mengklaim pasar MCU tumbuh 36,5% pada tahun 2010 dan 12% pada tahun 2011. Sebuah rumah khusus di negara maju cenderung memiliki hanya empat jenis umum mikroprosesor tetapi terbentuk sekitar tiga lusin mikrokontroler. Sebuah mobil khusus kelas menengah memiliki sebanyak 30 atau lebih mikrokontroler. Mereka juga dapat ditemukan di banyak perangkat listrik seperti mesin cuci, oven microwave, dan telepon. Secara historis, segmen 8-bit telah mendominasi pasar MCU. 16-bit mikrokontroler menjadi kategori volume MCU yang terbesar pada tahun 2011, menyalip perangkat 8-bit untuk pertama kalinya di tahun itu. IC Insights percaya peningkatan pasar MCU akan mengalami perubahan substansial dalam lima tahun ke depan dengan perangkat 32-bit yang terus meraih pangsa lebih besar dari penjualan dan volume unit. Tahun 2017, MCU 32-bit diharapkan dapat meraih 55% dari penjualan mikrokontroler. Dalam hal volume unit, MCU 32-bit diharapkan mencatat 38% dari penjualan mikrokontroler pada tahun 2017, sedangkan perangkat 16-bit akan mewakili 34% dari total, dan desain 4/8-bit diperkirakan memperoleh 28% dari unit yang terjual tahun itu. Pasar MCU 32-bit diperkirakan akan tumbuh pesat karena meningkatnya permintaan untuk tingkat yang lebih presisi dalam sistem pengolahan-embedded dan pertumbuhan konektivitas pengguna Internet. Pada beberapa tahun ke depan, MCU 32-bit kompleks diharapkan melakukan perhitungan lebih dari 25% dari kekuatan pemrosesan dalam kendaraan. IC Insights, Pasar MCU sedang migrasi ke 32-bit dan Perangkat berbasis ARM Pada tahun 2012, menyusul krisis global - penurunan penjualan terburuk yang pernah terjadi dan pemulihan dan rata-rata harga jual turun 17% - penurunan terbesar sejak tahun 1980-an, harga rata-rata untuk mikrokontroler adalah 0,88 USD ($0,69 untuk 4/8-bit, $0,59 untuk 16-bit, $1,76 untuk 32-bit). Pada tahun 2012, penjualan di seluruh dunia dari mikrokontroler 8-bit adalah sekitar $4 milyar karena mikrokontroler tipe ini begitu dibutuhkan untuk pengembangan teknologi yang lebih baik. Pada tahun 2012, mikrokontroler 4-bit juga mengalami penjualan yang signifikan. Pada 2015, mikrokontroler 8-bit dapat dibeli dengan harga $0,311 (1.000 unit), 16-bit seharga $0,385 (1.000 unit), dan 32-bit seharga $0,378 (1.000 unit tapi dapat juga seharga $ 0,35 untuk 5.000 unit).","title":"Volume"},{"location":"sensor/accelerometer-adxl335/","text":"Accelerometer ADXL335 \u00b6 About ADXL 335 Accelerometer \u00b6 What is Acceleration and ADXL 335 Accelerometer? Acceleration is a process in which velocity is changed with respect to time and it is a vector quantity. Similarly, velocity is a speed and direction. There are two ways for explaining acceleration of anything first one is change in speed and second one is change in direction. Sometimes both are changed simultaneously. If we talk about ADXL 335 accelerometer, then this accelerometer is a device that is used for measuring acceleration of any object. It measures the acceleration in the form of analog inputs, in three dimension direction such as X,Y and Z. It is low noise and less power consume device. When it is used for acceleration measure purposes then it is interfaced with any type of controller such as microcontroller or Arduino etc. It is mostly used in construction working machines such as drilling ,driving piles and demolition etc., human activities machines such running, walking, dancing and skipping etc. It is easily available in market or online shop. Pin Configure of ADXL 335 Accelerometer \u00b6 Every ADXL 335 accelerometer consists of five pins which are used for different purposes. Its pin configuration is shown in below table and this ADXL 335 accelerometer is connected with any controller according to this table. Pin Configuration 1 This is VCC pin and is used for power on the ADLX 335 accelerometer. It is connected with 3.3V dc power source 2 This is ground pin and is used for supplying ground to this ADLX 335 accelerometer. It is connected with source ground 3 This is X pin and is used for analog input in x axis dimension. This pin provides analog input signal to controller which is measured by ADLX 335 accelerometer 4 This is Y pin and is used for analog input in y axis dimension. This pin provides analog input signal to controller which is measured by ADLX 335 accelerometer 5 This is Z pin and is used for analog input in Z axis dimension. This pin provides analog input signal to controller which is measured by ADLX 335 accelerometer Working Principle of ADXL 335 Accelerometer \u00b6 Currently different types of accelerometers are available in market which are used for different purposes. Some works on the principle of MEMS( micro electro mechanical sensor) working. Which consists of a small mass which is etched into silicon surface and then integrated into a small circuit. When force is applied on this mass then it covers some displacement, so acceleration is produced in this mass according to newton second law of motion F= ma which is sensed by its sensor. Similarly, if we talk about analog accelerometers then they work on two principles such as capacitive sensing and piezo electric sensing. Both have different advantages and disadvantages. Similary,ADXL335 accelerometer is an analog accelerometer therefore it works on the principle of capacitive sensing. In capacitive sensing accelerometer, when it is moved in any direction then its capacitance is changed. When this capacitance is changed then its analog voltages are changed which is sensed by its interfacing controller. Interfacing Diagram \u00b6 For gaining proper result form ADXL 335 accelerometer, a controller is necessary for interfacing purposes. We can interface with it any type of controller but here we shell only tell the user how interface the Arduino board with ADXL 335 accelerometer. Sample Sketch \u00b6 Finding the roll and pitch of the device using analog voltages of accelerometer module and displaying them on serial monitor of Arduino. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include <math.h> const int x_out = A1 ; /* connect x_out of module to A1 of UNO board */ const int y_out = A2 ; /* connect y_out of module to A2 of UNO board */ const int z_out = A3 ; /* connect z_out of module to A3 of UNO board */ void setup () { Serial . begin ( 9600 ); } void loop () { int x_adc_value , y_adc_value , z_adc_value ; double x_g_value , y_g_value , z_g_value ; double roll , pitch , yaw ; x_adc_value = analogRead ( x_out ); /* Digital value of voltage on x_out pin */ y_adc_value = analogRead ( y_out ); /* Digital value of voltage on y_out pin */ z_adc_value = analogRead ( z_out ); /* Digital value of voltage on z_out pin */ Serial . print ( \"x = \" ); Serial . print ( x_adc_value ); Serial . print ( \" \\t\\t \" ); Serial . print ( \"y = \" ); Serial . print ( y_adc_value ); Serial . print ( \" \\t\\t \" ); Serial . print ( \"z = \" ); Serial . print ( z_adc_value ); Serial . print ( \" \\t\\t \" ); //delay(100); x_g_value = ( ( ( ( double )( x_adc_value * 5 ) / 1024 ) - 1.65 ) / 0.330 ); /* Acceleration in x-direction in g units */ y_g_value = ( ( ( ( double )( y_adc_value * 5 ) / 1024 ) - 1.65 ) / 0.330 ); /* Acceleration in y-direction in g units */ z_g_value = ( ( ( ( double )( z_adc_value * 5 ) / 1024 ) - 1.80 ) / 0.330 ); /* Acceleration in z-direction in g units */ roll = ( ( ( atan2 ( y_g_value , z_g_value ) * 180 ) / 3.14 ) + 180 ); /* Formula for roll */ pitch = ( ( ( atan2 ( z_g_value , x_g_value ) * 180 ) / 3.14 ) + 180 ); /* Formula for pitch */ //yaw = ( ( (atan2(x_g_value,y_g_value) * 180) / 3.14 ) + 180 ); /* Formula for yaw */ /* Not possible to measure yaw using accelerometer. Gyroscope must be used if yaw is also required */ Serial . print ( \"Roll = \" ); Serial . print ( roll ); Serial . print ( \" \\t \" ); Serial . print ( \"Pitch = \" ); Serial . print ( pitch ); Serial . print ( \" \\n\\n \" ); delay ( 1000 ); }","title":"Accelerometer ADXL335"},{"location":"sensor/accelerometer-adxl335/#accelerometer-adxl335","text":"","title":"Accelerometer ADXL335"},{"location":"sensor/accelerometer-adxl335/#about-adxl-335-accelerometer","text":"What is Acceleration and ADXL 335 Accelerometer? Acceleration is a process in which velocity is changed with respect to time and it is a vector quantity. Similarly, velocity is a speed and direction. There are two ways for explaining acceleration of anything first one is change in speed and second one is change in direction. Sometimes both are changed simultaneously. If we talk about ADXL 335 accelerometer, then this accelerometer is a device that is used for measuring acceleration of any object. It measures the acceleration in the form of analog inputs, in three dimension direction such as X,Y and Z. It is low noise and less power consume device. When it is used for acceleration measure purposes then it is interfaced with any type of controller such as microcontroller or Arduino etc. It is mostly used in construction working machines such as drilling ,driving piles and demolition etc., human activities machines such running, walking, dancing and skipping etc. It is easily available in market or online shop.","title":"About ADXL 335 Accelerometer"},{"location":"sensor/accelerometer-adxl335/#pin-configure-of-adxl-335-accelerometer","text":"Every ADXL 335 accelerometer consists of five pins which are used for different purposes. Its pin configuration is shown in below table and this ADXL 335 accelerometer is connected with any controller according to this table. Pin Configuration 1 This is VCC pin and is used for power on the ADLX 335 accelerometer. It is connected with 3.3V dc power source 2 This is ground pin and is used for supplying ground to this ADLX 335 accelerometer. It is connected with source ground 3 This is X pin and is used for analog input in x axis dimension. This pin provides analog input signal to controller which is measured by ADLX 335 accelerometer 4 This is Y pin and is used for analog input in y axis dimension. This pin provides analog input signal to controller which is measured by ADLX 335 accelerometer 5 This is Z pin and is used for analog input in Z axis dimension. This pin provides analog input signal to controller which is measured by ADLX 335 accelerometer","title":"Pin Configure of ADXL 335 Accelerometer"},{"location":"sensor/accelerometer-adxl335/#working-principle-of-adxl-335-accelerometer","text":"Currently different types of accelerometers are available in market which are used for different purposes. Some works on the principle of MEMS( micro electro mechanical sensor) working. Which consists of a small mass which is etched into silicon surface and then integrated into a small circuit. When force is applied on this mass then it covers some displacement, so acceleration is produced in this mass according to newton second law of motion F= ma which is sensed by its sensor. Similarly, if we talk about analog accelerometers then they work on two principles such as capacitive sensing and piezo electric sensing. Both have different advantages and disadvantages. Similary,ADXL335 accelerometer is an analog accelerometer therefore it works on the principle of capacitive sensing. In capacitive sensing accelerometer, when it is moved in any direction then its capacitance is changed. When this capacitance is changed then its analog voltages are changed which is sensed by its interfacing controller.","title":"Working Principle of ADXL 335 Accelerometer"},{"location":"sensor/accelerometer-adxl335/#interfacing-diagram","text":"For gaining proper result form ADXL 335 accelerometer, a controller is necessary for interfacing purposes. We can interface with it any type of controller but here we shell only tell the user how interface the Arduino board with ADXL 335 accelerometer.","title":"Interfacing Diagram"},{"location":"sensor/accelerometer-adxl335/#sample-sketch","text":"Finding the roll and pitch of the device using analog voltages of accelerometer module and displaying them on serial monitor of Arduino. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include <math.h> const int x_out = A1 ; /* connect x_out of module to A1 of UNO board */ const int y_out = A2 ; /* connect y_out of module to A2 of UNO board */ const int z_out = A3 ; /* connect z_out of module to A3 of UNO board */ void setup () { Serial . begin ( 9600 ); } void loop () { int x_adc_value , y_adc_value , z_adc_value ; double x_g_value , y_g_value , z_g_value ; double roll , pitch , yaw ; x_adc_value = analogRead ( x_out ); /* Digital value of voltage on x_out pin */ y_adc_value = analogRead ( y_out ); /* Digital value of voltage on y_out pin */ z_adc_value = analogRead ( z_out ); /* Digital value of voltage on z_out pin */ Serial . print ( \"x = \" ); Serial . print ( x_adc_value ); Serial . print ( \" \\t\\t \" ); Serial . print ( \"y = \" ); Serial . print ( y_adc_value ); Serial . print ( \" \\t\\t \" ); Serial . print ( \"z = \" ); Serial . print ( z_adc_value ); Serial . print ( \" \\t\\t \" ); //delay(100); x_g_value = ( ( ( ( double )( x_adc_value * 5 ) / 1024 ) - 1.65 ) / 0.330 ); /* Acceleration in x-direction in g units */ y_g_value = ( ( ( ( double )( y_adc_value * 5 ) / 1024 ) - 1.65 ) / 0.330 ); /* Acceleration in y-direction in g units */ z_g_value = ( ( ( ( double )( z_adc_value * 5 ) / 1024 ) - 1.80 ) / 0.330 ); /* Acceleration in z-direction in g units */ roll = ( ( ( atan2 ( y_g_value , z_g_value ) * 180 ) / 3.14 ) + 180 ); /* Formula for roll */ pitch = ( ( ( atan2 ( z_g_value , x_g_value ) * 180 ) / 3.14 ) + 180 ); /* Formula for pitch */ //yaw = ( ( (atan2(x_g_value,y_g_value) * 180) / 3.14 ) + 180 ); /* Formula for yaw */ /* Not possible to measure yaw using accelerometer. Gyroscope must be used if yaw is also required */ Serial . print ( \"Roll = \" ); Serial . print ( roll ); Serial . print ( \" \\t \" ); Serial . print ( \"Pitch = \" ); Serial . print ( pitch ); Serial . print ( \" \\n\\n \" ); delay ( 1000 ); }","title":"Sample Sketch"},{"location":"tnt/memilih-arduino/","text":"Memilih Arduino Uno Untuk Pemula \u00b6 Arduino Uno Original, Arduino Compatible dan Arduino Clone menjadi sangat membingungkan bagi para pemula yang hendak belajar tentang pemrograman Arduino. Arikel ini membahas tips dan trik menentukan pilihan papan Arduino Uno yang tepat terutama bagi pemula. Tepat sesuai dengan tujuan penggunaan dan tepat sesuai dengan dana yang dimiliki oleh penggunanya. Informasi tentang jenis-jenis Arduino yang ada dipasaran Indonesia tidak terlalu jelas, bahkan beberapa penjual Arduino sengaja tidak memberikan informasi detail tentang Arduino Uno yang dijualnya. Arduino Uno merupakan salah satu varian dari keluarga Arduino. Seperti dibahas sebelumnya mengenai \" Apa itu Arduino? \", diharapkan ada sedikit gambaran mengenai fungsi, spesifikasi dan hal-hal lain tentang Arduino. Ketika akan memulai belajar tentang Arduino, terutama pemula, maka kita akan dihadapkan pada pemilihan yang tepat tentang papan Arduino yang akan digunakan. Beberapa pertanyaan akan muncul dalam benak para pengguna pemula, diantaranya: Arduino tipe apa yang akan digunakan untuk belajar? Hal ini karena ada banyak tipe atau varian dari keluarga Arduino. Ada Arduino Uno, Arduino Leonardo, Arduino Nano, Arduino Pro Mini, Arduino Pro Micro, Arduino Mega2560, Arduino Mega ADK, Arduino Yun, dan masih ada beberapa varian lagi baik yang dikembangkan oleh perusahaan Arduino-nya atau yang dikembangkan oleh perusahaan rekanan. Jika papan Arduino yang akan dibeli bertujuan sebagai sarana pembelajaran, maka lebih baik anda menggunakan papan Arduno Uno. Hal ini karena papan Arduino Uno merupakan papan standar yang banyak digunakan sebagai awal pembelajaran pemrograman robotika diseluruh dunia, mudah didapat, dan relatif lebih murah. Pilih Arduino Original atau Arduino Compatible? Pertanyaan ini yang paling membingungkan karena berhubungan dengan anggaran yang akan digunakan. Rasa takut dan bingung membuat para pengguna pemula sering membatalkan pembelian. \"Apa bedanya sih papan Arduino original dengan papan Arduino compatible? Kok harganya beda jauh...? Beli murah takutnya bajakan, beli yang mahal tidak ada dananya...\" Arduino Uno Original \u00b6 Arduino Uno Original adalah papan Arduino Uno yang dibuat oleh perusahaan yang ditunjuk oleh perusahaan Arduino dan dijual pada situs resmi Arduino dan atau pada toko yang telah menjalin kerjasama secara resmi dengan perusahaan Arduino. Gambar 1. Arduino Uno Original Namun, kita bisa saja menemukan papan Arduino original di toko-toko yang tidak secara resmi tercantum sebagai pihak yang ditunjuk oleh perusahaan Arduino. Dibawah ini adalah toko-toko resmi di Indonesia yang menjual papan Arduino dengan kualitas original: DigiWare Surabaya (DigiWare, Surabaya, East Java, Indonesia) Email: onlineorder@digiwarestore.com Phone/Fax : +62-31-5039460 Whatsapp: 62-81-259 989 885 Line: @digiware_store Situs: DigiWare DigiWare Bandung (DigiWare, Bandung, West Java, Indonesia) Email: digiware.bandung@digiwarestore.com Phone: +62-22-7276690 Whatsapp: 62-82-126 168 065 Line: @digiware_store RDD Technologies Bandung - Indonesia Tel. +62811540593 Whatsapp: +6281321099180 Email: support@rdd-tech.com Situs: RDD Technologies Arduino Uno Compatible \u00b6 Sedangkan Arduino Uno Compatible adalah papan Arduino Uno yang dibuat dan dikembangkan oleh perusahaan rekanan yang bukan bagian atau bawahan perusahaan Arduino. Perusahaan ini membuat papan yang memiliki fungsi sama dengan Arduino Uno tetapi tidak menggunakan nama \"Arduino Uno\". Hal ini karena sifat Arduino yang open hardware sehingga siapapun bisa membuat dan menjual papan Arduino-nya dengan syarat \"tidak menggunakan nama yang sama dengan merk dagang produk yang dibuat oleh perusahaan Arduino\" kecuali perusahaan tersebut telah mendapat ijin dari pihak Arduino untuk menggunakan nama merk dagang tersebut. Beberapa perusahaan membuat papan Arduino Compatible dengan melakukan beberapa perubahan rangkaian dan komponen namun tetap memiliki fungsi dan perlakukan yang sama dengan Ardiuno Uno asli. Gambar 2. Arduino Uno Compatible Beberapa merk dagang papan Arduino yang dibuat oleh pihak rekanan misalnya; RedBoard dibuat oleh Sparkfun, Seeeduino dibuat oleh Seeed Studio, Arduino Nano dibuat oleh Gravitech, Freeduino dibuat oleh Freeduino, dan masih banyak lagi Arduino Uno Compatible lainnya. Beberapa papan diberi nama menggunakan merk dagang \"Arduino\", penggunaan merk dagang ini diperbolehkan jika telah di beri ijin oleh perusahaan Arduino. Namun sebenarnya pihak Arduino tidak pernah menyatakan bahwa papan-papan Arduino yang dibuat oleh pihak lain diperbolehkan dengan sebutan Arduino Uno Compatible. Pihak Arduino tetap menyatakan bahwa Arduino Compatible adalah palsu atau bajakan. Dan pihak rekanan sebagai pembuat papan Arduino Compatible pun tidak pernah menyatakan produk mereka dengan istilah Arduino Compatible. Misal Sparkfun, perusahaan ini tidak pernah menyebut RedBoard itu sebagai Arduino Uno Compatible, mereka tetap menyatakan dengan nama RedBoard tanpa menggunakan kata \"Arduino\", \"Uno\" ataupun \"Compatible\". Arduino Uno Palsu \u00b6 Arduino Uno Palsu atau dikenal dipasaran dengan nama Arduino Uno Clone adalah papan Arduino Uno yang dibuat oleh orang atau perusahaan tanpa nama dengan segala halnya sama persis dengan papan Arduino Uno original. Menggunakan merk dagang \"Arduino Uno\", dengan warna yang hampir sama, dengan tata letak yang sama, dengan komponen yang hampir sama, segala halnya disamakan dengan Arduino Uno original. Gambar 3. Arduino Uno Palsu Bahkan penulis memiliki satu papan Arduino Uno Palsu dengan kualitas yang hampir sama dengan aslinya yang dipasaran Indonesia sering di kenal dengan \"Arduino Uno Grade A\". Arduino Uno Grade A memiliki tata letak komponen yang sangat rapi, kualitas cat yang bagus, masking atas bawah yang bagus, komponen dengan kualitas lumayan bagus, walaupun sebenarnya jika kita jeli akan ditemukan beberapa perbedaan mencolok. Yang menjadi pertanyaan \"Kenapa mereka harus membajak?\". Padahal jika diberi nama lain, misal \"Henduino\" maka papan tersebut akan masuk kategori Arduino Compatible. Papan Arduino dikembangkan dibawah lisensi Open Source Open Hardware yang ini berarti siapapun dapat membuat, mengembangkan dan menjualnya kepasaran internasional dengan syarat \"tidak menggunakan merk dagang yang sama dan tidak membuat papan dengan segala hal yang sama, harus ada pengembangan atau modifikasi\". Arduino Uno bajakan dijual dengan harga sangat murah jika dibandingkan dengan Arduino Uno original. Dalam hal ini penulis tidak menyarankan apa-apa, apakah harus original atau bajakan. Kembali kepada anda sebagai pengguna. Perbedaan Arduino Original dengan Arduino Palsu \u00b6 Mau menggunakan Arduino Uno original, compatible, atau bahkan clone adalah menjadi hak para penggunanya. Namun untuk para pembuat papan Arduino Clone, semestinya mereka tidak menggunakan merk dagang \"Arduino\" hal ini karena pengembang Arduino sudah bermurah hati dengan lisensi Open Hardware untuk papan Arduino-nya dan lisensi Open Source untuk perangkat lunak Arduino IDE-nya. Penggunaan merk dagang \"Arduino\" hanya akan menyakiti dan merugikan perusahaan Arduino serta membingungkan dan merugikan konsumen. Kita sebagai konsumen diharapkan bijak dan jeli dalam merencakan pembelian papan Arduino. Dibawah ini ada beberapa indikator yang bisa kita gunakan untuk mengidentifikasi papan Arduino yang original dan yang bajakan. Warna Warna otentik papan Arduino adalah percampuran antara warna hijau dengan biru atau warna klasik lebut dan seperti warna pudar. Sedangkan papan Arduino palsu biasanya berwarna biru hingga warna biru tajam (dominan warna biru). Gambar 4. Warna Papan Arduino Original dan Bajakan Logo Pada bagian logo Arduino, kita akan menemukan perbedaan yang cukup jelas. Perhatikan logo asli Arduino, dan bandingkan dengan yang palsu. Logo pada papan palsu tercetak kurang tajam, lubang pada huruf \"A\" menghilang, bagian tepi garis logo bergelombang dan kurang rapi terutama pada bagian lengkungan logo. Gambar 5. Logo Huruf Arduino Original dan Bajakan Huruf Amati huruf dengan hati-hati pada kata \"Arduino\" dan \"Uno\" yang tertulis pada papan, maka akan ditemukan perbedaan. Jenis huruf Arduino di rancang secara khusus, sedangkan pada papan Arduino palsu atau bajakan cenderung diabaikan atau tidak sama persis. Perhatikan huruf \"O\" pada gambar! Peta Perhatikan juga bagian peta. Pada papan asli tampak dengan jelas peta negara Itali hal ini untuk menghormati tempat kelahiran Arduino. Sedangkan pada papan Arduino palsu peta tidak begitu jelas bahkan seperti layang-layang terbang. Gambar 6. Peta Arduino Original dan Bajakan Jalur dan konektor Pada papan Arduino Asli terlihat jalur dan konektor antar komponen tampak rapi dan teranyam dengan indah. Sedangkan pada papan Arduino Palsu tampak berantakan dan jelek. Gambar 7. Jalur Komponen Arduino Original dan Bajakan Komponen Komponen merupakan bagian yang paling sulit untuk dipalsukan. Komponen dengan kode 501K yang terletak dekat dengan Regulator Tegangan biasanya berwarna hijau pada papan Arduino palsu. Sebenarnya yang berwarna hijau memiliki properti yang hampir sama dengan yang digunakan pada papan Arduino Asli dengan warna emas-hitam. Hal ini menjadi hal spesial bagi Arduino Asli karena komponen ini merupakan komponen yang paling sulit di cari. Kata Kunci (Keyword) Sebenarnya para pembuat dan penjual papan Arduino palsu tahu bahwa mereka melanggar merk dagang. Makanya dalam menjualnya pun mereka tidak berani terang-terangan dengan mengatakan/menuliskan \"Arduino Uno\". Biasanya mereka menggunakan kata kunci pendekatan, misal; Arduino Uno Compatible, Arduino Uno Clone, Uno for Arduino, Arduino Uno Grade A, dan beberapa kata kunci yang mirip. Harga Inilah bagian yang paling mencolok diantara perbedaan yang sudah disebut diatas. Papan Arduino Palsu atau Clone dijual dengan harga sangat murah hingga 50% jika dibandingkan dengan harga papan Arduino Original. Papan Arduino Palsu dijual rata-rata setengah dari harga Arduino asli. Bahkan biasanya penjual memberikan tambahan berupa kabel data USB. ATmega328 DIP Chip dan SMD Chip \u00b6 Pihak Arduino telah mengembangkan 2 versi Arduino Uno, yaitu Arduino Uno dengan mikrokontroller ATmega328 tipe DIP (Dual-Inline Package) dan Arduino Uno dengan mikrokontroller ATmega328 tipe SMD (Small Mount Device). Tipe DIP merupakan papan Arduino yang paling banyak kita temukan dipasaran. Chip mikrokontroller dipasang pada sebuah socket untuk memudahkan penggantian jika suatu hari mikrokontroller tersebut sudah habis masa guna-nya. Tipe DIP sangat cocok untuk para pemula yang sedang belajar dan sering melakukan upload kode. Gambar 8. Arduino Uno SMD dan Arduino Uno DIP Sedangkan tipe SMD menggunakan mikrokontroller berbentuk kecil yang tertanam langsung pada papan tanpa bisa dilepas. Jika masa guna-nya telah habis maka kita sulit untuk menggantinya. Tipe ini cocok digunakan untuk proyek robotik yang tidak terlalu sering melakukan upload kode. Dari sisi harga, tipe SMD lebih murah dibandingkan dengan tipe DIP. Jika anda sedang belajar tentang pemrograman Arduino penulis menyarankan untuk memilih Arduino Uno dengan mikrokontroller tipe DIP. USB-to-Serial Chip \u00b6 USB-to-Serial Chip yang digunakan pada Arduino Uno ada beberapa jenis, yaitu; ATmega16U2, FTDI dan CH340. Arduino Uno yang menggunakan USB-to-Serial dengan chip ATmega16U2 biasanya dibandrol dengan harga tertinggi. Sedangkan papan Arduino Uno yang menggunakan USB-to-Serial dengan chip FTDI dijual lebih murah. Gambar 9. USB-to-Serial Chip pada Arduino Uno Sedangkan yang termurah adalah papan Arduino Uno yang menggunakan USB-to-Serial dengan chip CH340, bahkan perbadaan harganya sangat jauh jika dibandingkan dengan yang menggunakan chip ATmega16U2 ataupun chip FTDI. Papan Arduino Uno yang menggunakan USB-to-Serial dengan chip CH340 dapat dipastikan sebagai papan Arduino Bajakan. Karena tidak ada satu varian pun Arduino yang menggunakan USB-to-Serial CH340. Namun demikian, papan Arduino Uno dengan USB-to-Serial CH340 tetap mampu bekerja dengan baik layaknya yang menggunakan chip FTDI ataupun ATmega16U2. Rekomendasi Pembelian \u00b6 Untuk menentukan pilihan tepat tentang papan Arduino Uno yang akan dibeli maka kita harus mampu mendefinisikan maksud dan tujuan kita. Pada dasarnya ada 2 kepentingan, yaitu; (1) Membeli Arduino untuk belajar dan, (2) Membeli Arduino untuk sebuah proyek yang berhubungan dengan dana orang lain. Jika rencananya untuk belajar tentang pemrograman Arduino maka akan lebih tepat untuk membeli Arduino Uno dengan harga murah, terlepas dari masalah original atau pun bajakan. Sesuaikan saja dengan ketersediaan dana yang anda miliki. Arduino dengan harga murah akan memaksimalkan proses pembelajaran, sedikit rasa takut baik takut rusak maupun takut masa guna-nya habis. Jika rencananya untuk membuat proyek yang berhubungan dengan dana orang lain, maka akan lebih tepat untuk menggunakan Arduino berkualitas (Original). Hal ini karena Arduino original terjaga kualitasnya. Selain itu jika kita menggunakan Arduino Original berarti kita telah menjaga keberlangsungan perusahaan Arduino. Harga yang mahal setara dengan apa yang diberikan oleh perusahaan Arduino kepada penggunanya. Secara langsung kita telah membantu pendanaan perusahaan Arduino dan telah menciptakan: Pengembangan hardware open source baru dan terbaru. Dokumentasi yang lebih baik. Sertifikat CE/FCC. Kontrol Kualitas (Quality Control). Memanajemen Komunitas. Penerbitan Tutorial. Menyumbang proyek open source lainnya. Memelihara hosting/pemeliharaan website dan forum. Kesimpulan \u00b6 Sebagai penegasan, bahwa di pasaran hanya ada 2 kategori, yaitu Original (Asli) dan Palsu (Bajakan). Tidak ada istilah compatible untuk mengkamuflasekan kualitas palsu. Artikel diatas menggunakan istilah compatible sebenarnya hanya untuk memudahkan pembagian papan Arduino yang beredar dipasaran. RedBoard, Seeduino, Arduino Nano, Freeduino adalah tetap masuk kategori original (asli) tetapi karena tidak dibuat oleh perusahaan Arduino maka dimasukan kategori compatible untuk mempermudah pemahaman. Dan harus diingat, istilah compatible yang digunakan di pasaran Indonesia maupun internasional tetap mengacu pada papan Arduino bajakan. Jika kita ingin membantu pengembangan Arduino maka belilah Arduino Original atau Asli. Memang lebih mahal tapi dana tersebut digunakan untuk penelitian dan pengembangan Arduino dimasa mendatang. Tapi dana saya tidak cukup untuk membeli kualitas original? Ah itu sih terserah anda... Jika dana tidak mencukupi untuk membeli kualitas original sebenarnya kita masih bisa untuk membuatnya sendiri tanpa harus membeli bajakan. Pada artikel mendatang akan dibahas cara membuat sendiri papan Arduino dengan fungsi sama dengan proses dan rangkaian yang lebih sederhana. Mau??? Daftar Pustaka \u00b6 How to spot a counterfeit Arduino Distributor Resmi Arduino","title":"Memilih Arduino Uno"},{"location":"tnt/memilih-arduino/#memilih-arduino-uno-untuk-pemula","text":"Arduino Uno Original, Arduino Compatible dan Arduino Clone menjadi sangat membingungkan bagi para pemula yang hendak belajar tentang pemrograman Arduino. Arikel ini membahas tips dan trik menentukan pilihan papan Arduino Uno yang tepat terutama bagi pemula. Tepat sesuai dengan tujuan penggunaan dan tepat sesuai dengan dana yang dimiliki oleh penggunanya. Informasi tentang jenis-jenis Arduino yang ada dipasaran Indonesia tidak terlalu jelas, bahkan beberapa penjual Arduino sengaja tidak memberikan informasi detail tentang Arduino Uno yang dijualnya. Arduino Uno merupakan salah satu varian dari keluarga Arduino. Seperti dibahas sebelumnya mengenai \" Apa itu Arduino? \", diharapkan ada sedikit gambaran mengenai fungsi, spesifikasi dan hal-hal lain tentang Arduino. Ketika akan memulai belajar tentang Arduino, terutama pemula, maka kita akan dihadapkan pada pemilihan yang tepat tentang papan Arduino yang akan digunakan. Beberapa pertanyaan akan muncul dalam benak para pengguna pemula, diantaranya: Arduino tipe apa yang akan digunakan untuk belajar? Hal ini karena ada banyak tipe atau varian dari keluarga Arduino. Ada Arduino Uno, Arduino Leonardo, Arduino Nano, Arduino Pro Mini, Arduino Pro Micro, Arduino Mega2560, Arduino Mega ADK, Arduino Yun, dan masih ada beberapa varian lagi baik yang dikembangkan oleh perusahaan Arduino-nya atau yang dikembangkan oleh perusahaan rekanan. Jika papan Arduino yang akan dibeli bertujuan sebagai sarana pembelajaran, maka lebih baik anda menggunakan papan Arduno Uno. Hal ini karena papan Arduino Uno merupakan papan standar yang banyak digunakan sebagai awal pembelajaran pemrograman robotika diseluruh dunia, mudah didapat, dan relatif lebih murah. Pilih Arduino Original atau Arduino Compatible? Pertanyaan ini yang paling membingungkan karena berhubungan dengan anggaran yang akan digunakan. Rasa takut dan bingung membuat para pengguna pemula sering membatalkan pembelian. \"Apa bedanya sih papan Arduino original dengan papan Arduino compatible? Kok harganya beda jauh...? Beli murah takutnya bajakan, beli yang mahal tidak ada dananya...\"","title":"Memilih Arduino Uno Untuk Pemula"},{"location":"tnt/memilih-arduino/#arduino-uno-original","text":"Arduino Uno Original adalah papan Arduino Uno yang dibuat oleh perusahaan yang ditunjuk oleh perusahaan Arduino dan dijual pada situs resmi Arduino dan atau pada toko yang telah menjalin kerjasama secara resmi dengan perusahaan Arduino. Gambar 1. Arduino Uno Original Namun, kita bisa saja menemukan papan Arduino original di toko-toko yang tidak secara resmi tercantum sebagai pihak yang ditunjuk oleh perusahaan Arduino. Dibawah ini adalah toko-toko resmi di Indonesia yang menjual papan Arduino dengan kualitas original: DigiWare Surabaya (DigiWare, Surabaya, East Java, Indonesia) Email: onlineorder@digiwarestore.com Phone/Fax : +62-31-5039460 Whatsapp: 62-81-259 989 885 Line: @digiware_store Situs: DigiWare DigiWare Bandung (DigiWare, Bandung, West Java, Indonesia) Email: digiware.bandung@digiwarestore.com Phone: +62-22-7276690 Whatsapp: 62-82-126 168 065 Line: @digiware_store RDD Technologies Bandung - Indonesia Tel. +62811540593 Whatsapp: +6281321099180 Email: support@rdd-tech.com Situs: RDD Technologies","title":"Arduino Uno Original"},{"location":"tnt/memilih-arduino/#arduino-uno-compatible","text":"Sedangkan Arduino Uno Compatible adalah papan Arduino Uno yang dibuat dan dikembangkan oleh perusahaan rekanan yang bukan bagian atau bawahan perusahaan Arduino. Perusahaan ini membuat papan yang memiliki fungsi sama dengan Arduino Uno tetapi tidak menggunakan nama \"Arduino Uno\". Hal ini karena sifat Arduino yang open hardware sehingga siapapun bisa membuat dan menjual papan Arduino-nya dengan syarat \"tidak menggunakan nama yang sama dengan merk dagang produk yang dibuat oleh perusahaan Arduino\" kecuali perusahaan tersebut telah mendapat ijin dari pihak Arduino untuk menggunakan nama merk dagang tersebut. Beberapa perusahaan membuat papan Arduino Compatible dengan melakukan beberapa perubahan rangkaian dan komponen namun tetap memiliki fungsi dan perlakukan yang sama dengan Ardiuno Uno asli. Gambar 2. Arduino Uno Compatible Beberapa merk dagang papan Arduino yang dibuat oleh pihak rekanan misalnya; RedBoard dibuat oleh Sparkfun, Seeeduino dibuat oleh Seeed Studio, Arduino Nano dibuat oleh Gravitech, Freeduino dibuat oleh Freeduino, dan masih banyak lagi Arduino Uno Compatible lainnya. Beberapa papan diberi nama menggunakan merk dagang \"Arduino\", penggunaan merk dagang ini diperbolehkan jika telah di beri ijin oleh perusahaan Arduino. Namun sebenarnya pihak Arduino tidak pernah menyatakan bahwa papan-papan Arduino yang dibuat oleh pihak lain diperbolehkan dengan sebutan Arduino Uno Compatible. Pihak Arduino tetap menyatakan bahwa Arduino Compatible adalah palsu atau bajakan. Dan pihak rekanan sebagai pembuat papan Arduino Compatible pun tidak pernah menyatakan produk mereka dengan istilah Arduino Compatible. Misal Sparkfun, perusahaan ini tidak pernah menyebut RedBoard itu sebagai Arduino Uno Compatible, mereka tetap menyatakan dengan nama RedBoard tanpa menggunakan kata \"Arduino\", \"Uno\" ataupun \"Compatible\".","title":"Arduino Uno Compatible"},{"location":"tnt/memilih-arduino/#arduino-uno-palsu","text":"Arduino Uno Palsu atau dikenal dipasaran dengan nama Arduino Uno Clone adalah papan Arduino Uno yang dibuat oleh orang atau perusahaan tanpa nama dengan segala halnya sama persis dengan papan Arduino Uno original. Menggunakan merk dagang \"Arduino Uno\", dengan warna yang hampir sama, dengan tata letak yang sama, dengan komponen yang hampir sama, segala halnya disamakan dengan Arduino Uno original. Gambar 3. Arduino Uno Palsu Bahkan penulis memiliki satu papan Arduino Uno Palsu dengan kualitas yang hampir sama dengan aslinya yang dipasaran Indonesia sering di kenal dengan \"Arduino Uno Grade A\". Arduino Uno Grade A memiliki tata letak komponen yang sangat rapi, kualitas cat yang bagus, masking atas bawah yang bagus, komponen dengan kualitas lumayan bagus, walaupun sebenarnya jika kita jeli akan ditemukan beberapa perbedaan mencolok. Yang menjadi pertanyaan \"Kenapa mereka harus membajak?\". Padahal jika diberi nama lain, misal \"Henduino\" maka papan tersebut akan masuk kategori Arduino Compatible. Papan Arduino dikembangkan dibawah lisensi Open Source Open Hardware yang ini berarti siapapun dapat membuat, mengembangkan dan menjualnya kepasaran internasional dengan syarat \"tidak menggunakan merk dagang yang sama dan tidak membuat papan dengan segala hal yang sama, harus ada pengembangan atau modifikasi\". Arduino Uno bajakan dijual dengan harga sangat murah jika dibandingkan dengan Arduino Uno original. Dalam hal ini penulis tidak menyarankan apa-apa, apakah harus original atau bajakan. Kembali kepada anda sebagai pengguna.","title":"Arduino Uno Palsu"},{"location":"tnt/memilih-arduino/#perbedaan-arduino-original-dengan-arduino-palsu","text":"Mau menggunakan Arduino Uno original, compatible, atau bahkan clone adalah menjadi hak para penggunanya. Namun untuk para pembuat papan Arduino Clone, semestinya mereka tidak menggunakan merk dagang \"Arduino\" hal ini karena pengembang Arduino sudah bermurah hati dengan lisensi Open Hardware untuk papan Arduino-nya dan lisensi Open Source untuk perangkat lunak Arduino IDE-nya. Penggunaan merk dagang \"Arduino\" hanya akan menyakiti dan merugikan perusahaan Arduino serta membingungkan dan merugikan konsumen. Kita sebagai konsumen diharapkan bijak dan jeli dalam merencakan pembelian papan Arduino. Dibawah ini ada beberapa indikator yang bisa kita gunakan untuk mengidentifikasi papan Arduino yang original dan yang bajakan. Warna Warna otentik papan Arduino adalah percampuran antara warna hijau dengan biru atau warna klasik lebut dan seperti warna pudar. Sedangkan papan Arduino palsu biasanya berwarna biru hingga warna biru tajam (dominan warna biru). Gambar 4. Warna Papan Arduino Original dan Bajakan Logo Pada bagian logo Arduino, kita akan menemukan perbedaan yang cukup jelas. Perhatikan logo asli Arduino, dan bandingkan dengan yang palsu. Logo pada papan palsu tercetak kurang tajam, lubang pada huruf \"A\" menghilang, bagian tepi garis logo bergelombang dan kurang rapi terutama pada bagian lengkungan logo. Gambar 5. Logo Huruf Arduino Original dan Bajakan Huruf Amati huruf dengan hati-hati pada kata \"Arduino\" dan \"Uno\" yang tertulis pada papan, maka akan ditemukan perbedaan. Jenis huruf Arduino di rancang secara khusus, sedangkan pada papan Arduino palsu atau bajakan cenderung diabaikan atau tidak sama persis. Perhatikan huruf \"O\" pada gambar! Peta Perhatikan juga bagian peta. Pada papan asli tampak dengan jelas peta negara Itali hal ini untuk menghormati tempat kelahiran Arduino. Sedangkan pada papan Arduino palsu peta tidak begitu jelas bahkan seperti layang-layang terbang. Gambar 6. Peta Arduino Original dan Bajakan Jalur dan konektor Pada papan Arduino Asli terlihat jalur dan konektor antar komponen tampak rapi dan teranyam dengan indah. Sedangkan pada papan Arduino Palsu tampak berantakan dan jelek. Gambar 7. Jalur Komponen Arduino Original dan Bajakan Komponen Komponen merupakan bagian yang paling sulit untuk dipalsukan. Komponen dengan kode 501K yang terletak dekat dengan Regulator Tegangan biasanya berwarna hijau pada papan Arduino palsu. Sebenarnya yang berwarna hijau memiliki properti yang hampir sama dengan yang digunakan pada papan Arduino Asli dengan warna emas-hitam. Hal ini menjadi hal spesial bagi Arduino Asli karena komponen ini merupakan komponen yang paling sulit di cari. Kata Kunci (Keyword) Sebenarnya para pembuat dan penjual papan Arduino palsu tahu bahwa mereka melanggar merk dagang. Makanya dalam menjualnya pun mereka tidak berani terang-terangan dengan mengatakan/menuliskan \"Arduino Uno\". Biasanya mereka menggunakan kata kunci pendekatan, misal; Arduino Uno Compatible, Arduino Uno Clone, Uno for Arduino, Arduino Uno Grade A, dan beberapa kata kunci yang mirip. Harga Inilah bagian yang paling mencolok diantara perbedaan yang sudah disebut diatas. Papan Arduino Palsu atau Clone dijual dengan harga sangat murah hingga 50% jika dibandingkan dengan harga papan Arduino Original. Papan Arduino Palsu dijual rata-rata setengah dari harga Arduino asli. Bahkan biasanya penjual memberikan tambahan berupa kabel data USB.","title":"Perbedaan Arduino Original dengan Arduino Palsu"},{"location":"tnt/memilih-arduino/#atmega328-dip-chip-dan-smd-chip","text":"Pihak Arduino telah mengembangkan 2 versi Arduino Uno, yaitu Arduino Uno dengan mikrokontroller ATmega328 tipe DIP (Dual-Inline Package) dan Arduino Uno dengan mikrokontroller ATmega328 tipe SMD (Small Mount Device). Tipe DIP merupakan papan Arduino yang paling banyak kita temukan dipasaran. Chip mikrokontroller dipasang pada sebuah socket untuk memudahkan penggantian jika suatu hari mikrokontroller tersebut sudah habis masa guna-nya. Tipe DIP sangat cocok untuk para pemula yang sedang belajar dan sering melakukan upload kode. Gambar 8. Arduino Uno SMD dan Arduino Uno DIP Sedangkan tipe SMD menggunakan mikrokontroller berbentuk kecil yang tertanam langsung pada papan tanpa bisa dilepas. Jika masa guna-nya telah habis maka kita sulit untuk menggantinya. Tipe ini cocok digunakan untuk proyek robotik yang tidak terlalu sering melakukan upload kode. Dari sisi harga, tipe SMD lebih murah dibandingkan dengan tipe DIP. Jika anda sedang belajar tentang pemrograman Arduino penulis menyarankan untuk memilih Arduino Uno dengan mikrokontroller tipe DIP.","title":"ATmega328 DIP Chip dan SMD Chip"},{"location":"tnt/memilih-arduino/#usb-to-serial-chip","text":"USB-to-Serial Chip yang digunakan pada Arduino Uno ada beberapa jenis, yaitu; ATmega16U2, FTDI dan CH340. Arduino Uno yang menggunakan USB-to-Serial dengan chip ATmega16U2 biasanya dibandrol dengan harga tertinggi. Sedangkan papan Arduino Uno yang menggunakan USB-to-Serial dengan chip FTDI dijual lebih murah. Gambar 9. USB-to-Serial Chip pada Arduino Uno Sedangkan yang termurah adalah papan Arduino Uno yang menggunakan USB-to-Serial dengan chip CH340, bahkan perbadaan harganya sangat jauh jika dibandingkan dengan yang menggunakan chip ATmega16U2 ataupun chip FTDI. Papan Arduino Uno yang menggunakan USB-to-Serial dengan chip CH340 dapat dipastikan sebagai papan Arduino Bajakan. Karena tidak ada satu varian pun Arduino yang menggunakan USB-to-Serial CH340. Namun demikian, papan Arduino Uno dengan USB-to-Serial CH340 tetap mampu bekerja dengan baik layaknya yang menggunakan chip FTDI ataupun ATmega16U2.","title":"USB-to-Serial Chip"},{"location":"tnt/memilih-arduino/#rekomendasi-pembelian","text":"Untuk menentukan pilihan tepat tentang papan Arduino Uno yang akan dibeli maka kita harus mampu mendefinisikan maksud dan tujuan kita. Pada dasarnya ada 2 kepentingan, yaitu; (1) Membeli Arduino untuk belajar dan, (2) Membeli Arduino untuk sebuah proyek yang berhubungan dengan dana orang lain. Jika rencananya untuk belajar tentang pemrograman Arduino maka akan lebih tepat untuk membeli Arduino Uno dengan harga murah, terlepas dari masalah original atau pun bajakan. Sesuaikan saja dengan ketersediaan dana yang anda miliki. Arduino dengan harga murah akan memaksimalkan proses pembelajaran, sedikit rasa takut baik takut rusak maupun takut masa guna-nya habis. Jika rencananya untuk membuat proyek yang berhubungan dengan dana orang lain, maka akan lebih tepat untuk menggunakan Arduino berkualitas (Original). Hal ini karena Arduino original terjaga kualitasnya. Selain itu jika kita menggunakan Arduino Original berarti kita telah menjaga keberlangsungan perusahaan Arduino. Harga yang mahal setara dengan apa yang diberikan oleh perusahaan Arduino kepada penggunanya. Secara langsung kita telah membantu pendanaan perusahaan Arduino dan telah menciptakan: Pengembangan hardware open source baru dan terbaru. Dokumentasi yang lebih baik. Sertifikat CE/FCC. Kontrol Kualitas (Quality Control). Memanajemen Komunitas. Penerbitan Tutorial. Menyumbang proyek open source lainnya. Memelihara hosting/pemeliharaan website dan forum.","title":"Rekomendasi Pembelian"},{"location":"tnt/memilih-arduino/#kesimpulan","text":"Sebagai penegasan, bahwa di pasaran hanya ada 2 kategori, yaitu Original (Asli) dan Palsu (Bajakan). Tidak ada istilah compatible untuk mengkamuflasekan kualitas palsu. Artikel diatas menggunakan istilah compatible sebenarnya hanya untuk memudahkan pembagian papan Arduino yang beredar dipasaran. RedBoard, Seeduino, Arduino Nano, Freeduino adalah tetap masuk kategori original (asli) tetapi karena tidak dibuat oleh perusahaan Arduino maka dimasukan kategori compatible untuk mempermudah pemahaman. Dan harus diingat, istilah compatible yang digunakan di pasaran Indonesia maupun internasional tetap mengacu pada papan Arduino bajakan. Jika kita ingin membantu pengembangan Arduino maka belilah Arduino Original atau Asli. Memang lebih mahal tapi dana tersebut digunakan untuk penelitian dan pengembangan Arduino dimasa mendatang. Tapi dana saya tidak cukup untuk membeli kualitas original? Ah itu sih terserah anda... Jika dana tidak mencukupi untuk membeli kualitas original sebenarnya kita masih bisa untuk membuatnya sendiri tanpa harus membeli bajakan. Pada artikel mendatang akan dibahas cara membuat sendiri papan Arduino dengan fungsi sama dengan proses dan rangkaian yang lebih sederhana. Mau???","title":"Kesimpulan"},{"location":"tnt/memilih-arduino/#daftar-pustaka","text":"How to spot a counterfeit Arduino Distributor Resmi Arduino","title":"Daftar Pustaka"},{"location":"tnt/the-untold-history-of-arduino/","text":"The Untold History of Arduino \u00b6 Why Are You Writing This? \u00b6 Hello. My name is Hernando Barrag\u00e1n . Through the years, and more recently due to the affairs between Arduino LLC and Arduino S.R.L. , I have received a lot of questions from people about the history of Wiring and, of course, Arduino. I was also shown this US Federal Courts website , which presents documents citing my work to support the plaintiff's claims which, in my opinion, contribute to the distortion of information surrounding my work. The history of Arduino has been told by many people, and no two stories match. I want to clarify some facts around the history of Arduino, with proper supported references and documents, to better communicate to people who are interested, about Arduino's origin. As well, I will attempt to correct some things that have distorted my role or work by pointing out common mistakes, misleading information, and poor journalism. I will go through a summary of the history first, then I will answer a series of questions that I have been often asked over the years. Why Did You Create Wiring? \u00b6 I started Wiring in 2003 as my Master's thesis project at the Interaction Design Institute Ivrea (IDII) in Italy. The objective of the thesis was to make it easy for artists and designers to work with electronics, by abstracting away the often complicated details of electronics so they can focus on their own objectives. The full thesis document can be downloaded here: http://people.interactionivrea.org/h.barragan/thesis/thesis_low_res.pdf Massimo Banzi and Casey Reas (known for his work on Processing ) were supervisors for my thesis. The project received plenty of attention at IDII, and was used for several other projects from 2004, up until the closure of the school in 2005. Because of my thesis, I was proud to graduate with distinction; the only individual at IDII in 2004 to receive the distinction. I continued the development of Wiring while working at the Universidad de Los Andes in Colombia, where I began teaching as an instructor in Interaction Design. What Wiring is, and why it was created can be extracted from the abstract section of my thesis document. Please keep in mind that it was 2003, and these premises are not to be taken lightly. You may have heard them before recited as proclamations: \"... Current prototyping tools for electronics and programming are mostly targeted to engineering, robotics and technical audiences. They are hard to learn, and the programming languages are far from useful in contexts outside a specific technology ...\" \"... It can also be used to teach and learn computer programming and prototyping with electronics...\" \"Wiring builds on Processing...\" These were the key resulting elements of Wiring: Simple integrated development environment (IDE), based on the Processing.org IDE running on Microsoft Windows, Mac OS X, and Linux to create software programs or \"sketches\" 1 , with a simple editor Simple \"language\" or programming \"framework\" for microcontrollers Complete toolchain integration (transparent to user) Bootloader for easy uploading of programs Serial monitor to inspect and send data from/to the microcontroller Open source software Open source hardware designs based on an Atmel microcontroller Comprehensive online reference for the commands and libraries, examples, tutorials, forum and a showcase of projects done using Wiring How Was Wiring Created? \u00b6 Through the thesis document, it is possible to understand the design process I followed. Considerable research and references to prior work has served as a basis for my work. To quickly illustrate the process, a few key points are provided below. The Language \u00b6 Have you ever wondered where those commands come from? Probably one of the most distinctive things, that is widely known and used today by Arduino users in their sketches, is the set of commands I created as the language definition for Wiring. pinMode () digitalRead () digitalWrite () analogRead () analogWrite () delay () millis () etc... Abstracting the microcontroller pins as numbers was, without a doubt, a major decision, possible because the syntax was defined prior to implementation in any hardware platform. All the language command naming and syntax were the result of an exhaustive design process I conducted, which included user testing with students, observation, analysis, adjustment and iteration. As I developed the hardware prototypes, the language also naturally developed. It wasn't until after the final prototype had been made that the language became solid and refined. If you are still curious about the design process, it is detailed in the thesis document, including earlier stages of command naming and syntax that were later discarded. The Hardware \u00b6 From a designer's point of view, this was probably the most difficult part to address. I asked for or bought evaluation boards from different microcontroller manufacturers. Here are some key moments in the hardware design for Wiring. Prototype 1 \u00b6 The first prototype for Wiring used the Parallax Javelin Stamp microcontroller. It was a natural option since it was programmed in a subset of the Java language, which was already being used by Processing. Problem: as described in the thesis document on page 40, compiling, linking and uploading of user's programs relied on Parallax's proprietary tools. Since Wiring was planned as open source software, the Javelin Stamp was simply not a viable option. Above: Cupcake indexer in progress For the next prototypes, microcontrollers were chosen on a basis of availability of open source tools for compiling, linking and uploading the user's code. This led to discarding the very popular Microchip PIC family of microcontrollers very early, because, at the time (circa 2003), Microchip did not have an open source toolchain. Prototype 2 \u00b6 For the second Wiring hardware prototype, the Atmel ARM-based AT91R40008 microcontroller was selected, which lead to excellent results. The first sketch examples were developed and command naming testing began. For example, pinWrite () used to be the name of the now ubiquitous digitalWrite () . The Atmel R40008 served as a test bed for the digital input/output API and the serial communications API, during my evaluation of its capabilities. The Atmel R40008 was a very powerful microcontroller, but was far too complex for a hands-on approach because it was almost impossible to solder by hand onto a printed circuit board. For more information on this prototype, see page 42 in the thesis document. Prototype 3 \u00b6 The previous prototype experiments led to the third prototype, where the microcontroller was downscaled to one still powerful, yet with the possibility of tinkering with it without the requirements of specialized equipment or on-board extra peripherals. I selected the Atmel ATmega128 microcontroller and bought an Atmel STK500 evaluation board with a special socket for the ATmega128. Photo of Atmel STK500 with ATmega128 expansion. Tests with the STK500 were immediately successful, so I bought a MAVRIC board from BDMICRO with the ATmega128 soldered. Brian Dean's work on his MAVRIC boards were unparalleled at that time, and his work drove him to build a software tool to easily upload new programs to his board. It is still used today in the Arduino software, and is called \"avrdude\". As traditional COM ports were disappearing from computers, I selected FTDI hardware for communication through a USB port on the host computer. FTDI provided drivers for Windows, Mac OS X and Linux which was required for the Wiring environment to work on all platforms. Photo of BDMICRO MAVRIC-II used for the third Wiring hardware prototype. Photo of an FTDI FT232BM evaluation board used in the third Wiring hardware prototype. The FTDI evaluation board was interfaced with the MAVRIC board and tested with the third Wiring prototype. Testing with the BDMICRO MAVRIC-II board and FTDI-FT232BM. In early 2004, based on the prototype using the MAVRIC board (Prototype 3), I used Brian Dean's and Pascal Stang's schematic designs as a reference to create the first Wiring board design. It had the following features: ATmega128 FTDI232BM for serial to USB conversion An on-board LED connected to a pin A power LED and serial RX/TX LEDs I used Eagle PCB from Cadsoft to design the schematic and printed circuit board. Wiring board schematic. Wiring board printed circuit board layout. Along with the third prototype, the final version of the API was tested and refined. More examples were added and I wrote the first LED blink example that is still used today as the first sketch that a user runs on an Arduino board to learn the environment. Even more examples were developed to support liquid crystal displays (LCDs), serial port communication, servo motors, etc. and even to interface Wiring with Processing via serial communication. Details can be found on page 50 in the thesis document. In March 2004, 25 Wiring printed circuit boards were ordered and manufactured at SERP , and paid for by IDII. I hand-soldered these 25 boards and started to conduct usability tests with some of my classmates at IDII. It was an exciting time! Photos of the first Wiring board Continuing the Development \u00b6 After graduating from IDII in 2004, I moved back to Colombia, and began teaching as an instructor in Interaction Design at the Universidad de Los Andes. As I continued to develop Wiring, IDII decided to print and assemble a batch of 100 Wiring boards to teach physical computing at IDII in late 2004. Bill Verplank (a former IDII faculty member) asked Massimo Banzi to send 10 of the boards to me for use in my classes in Colombia. In 2004, Faculty member Yaniv Steiner , former student of Giorgio Olivero and Paolo Sancis, started the Instant Soup Project , based on Wiring at IDII. First Major Success - Strangely Familiar \u00b6 In the autumn of 2004, Wiring was used to teach physical computing at IDII through a project called Strangely Familiar, consisting of 22 students, and 11 successful projects. Four faculty members ran the 4-week project: Massimo Banzi Heather Martin Yaniv Steiner Reto Wettach It turned out to be a resounding success for both the students as well as the professors and teachers. Strangely Familiar demonstrated the potential of Wiring as an innovation platform for interaction design. On December 16 th , 2004, Bill Verplank sent an email to me saying: [The projects] were wonderful. Everyone had things working. Five of the projects had motors in them! The most advanced (from two MIT grads - architect and mathematician) allowed drawing a profile in Proce55ing and feeling it with a wheel/motor run by Wiring... It is clear that one of the elements of success was [the] use of the Wiring board. Here is the brief for the course: http://wiring.org.co/exhibition/images/brief.pdf Here is a booklet with the resulting projects: http://wiring.org.co/exhibition/images/book01.pdf Tug Tug phones by Haiyan Zhang (with Aram Armstrong) Commitment Radio by David Chiu and Alexandra Deschamps-Sonsino Speak Out by Tristam Sparks and Andreea Cherlaru (with Ana Camila Amorim) Feel the Music I by James Tichenor and David A. Mellis The Amazing All Band Radio by Oren Horev & Myriel Milicevic (with Marcos Weskamp) The Rest of the World \u00b6 In May 2005, I contracted Advanced Circuits in the USA to print the first 200 printed circuit boards outside of IDII, and assembled them in Colombia. I began selling and shipping boards to various schools and universities, and by the end of 2005, Wiring was being used around the world. \"Wiring's Reach by 2005\" graphic, provided by Collin Reisdorf When Did Arduino Begin and Why Weren't You a Member of the Arduino Team? \u00b6 The Formation of Arduino \u00b6 When IDII manufactured the first set of Wiring boards, the cost was probably around USD$50 each. (I don't know what the actual cost was, as I wasn't involved in the process. However, I was selling the boards from Colombia for about USD$60.) This was a considerable drop in price from the boards that were currently available, but it was still a significant cost for most people. In 2005, Massimo Banzi, along with David Mellis (an IDII student at the time) and David Cuartielles, added support for the cheaper ATmega8 microcontroller to Wiring. Then they forked (or copied) the Wiring source code and started running it as a separate project, called Arduino. There was no need to create a separate project, as I would have gladly helped them and developed support for the ATmega8 and any other microcontrollers. I had planned to do this all along. I had inadvertantly taken a photo of some notes about my plans for Wiring, in the photo of Karmen Franinovic (former IDII student from 2002 to 2004) testing a stretch sensor for a lamp in March 2004. Wiring and Arduino shared many of the early development done by Nicholas Zambetti , a former IDII student in the same class as David Mellis. For a brief time, Nicholas had been considered a member of the Arduino Team. Around the same time, Gianluca Martino (he was a consultant at SERP, the printed circuit board factory at Ivrea where the first Wiring boards were made), joined the Arduino Team to help with manufacturing and hardware development. So, to reduce the cost of their boards, Gianluca, with some help from David Cuartielles, developed cheaper hardware by using the ATmega8. Apparently this is the first \"Arduino\" prototype - dubbed Wiring Lite. I think Massimo Banzi designed this one, but I'm unsure. Arduino Extreme v2 - \"Second production version of the Arduino USB boards. This has been properly engineered by Gianluca Martino.\" Tom Igoe (a faculty member at the ITP at NYU 2 ) was invited by Massimo Banzi to IDII for a workshop and became part of the Arduino Team. To this day, I do not know exactly why the Arduino Team forked the code from Wiring. It was also puzzling why we didn't work together. So, to answer the question, I was never asked to become a member of the Arduino Team. Even though I was perplexed by the Arduino Team forking the code, I continued development on Wiring, and almost all of the improvements that had been made to Wiring, by me and plenty of contributors, were merged into the Arduino source code. I tried to ignore the fact that they were still taking my work and also wondered about the redundancy and waste of resources in duplicating efforts. By the end of 2005, I started to work with Casey Reas on a chapter for the book \" Processing: A Programming Handbook for Visual Artists and Designers .\" The chapter presents a short history of electronics in the Arts. It includes examples for interfacing Processing with Wiring and Arduino. I presented those examples in both platforms and made sure the examples included worked for both Wiring and Arduino. The book got a second edition in 2013 and the chapter was revised again by Casey and me, and the extension has been made available online since 2014. Did The Arduino Team Work with Wiring Before Arduino? \u00b6 Yes, each of them had experience with Wiring before creating Arduino. Massimo Banzi taught with Wiring at IDII from 2004. Massimo Banzi teaching interaction design at IDII with Wiring boards in 2004. David Mellis was a student at IDII from 2004 to 2005. A blurry version of David Mellis learning physical computing with Wiring in 2004. In January 2005, IDII hired David Cuartielles to develop a couple of plug-in boards for the Wiring board, for motor control and bluetooth connectivity. Two plug-in boards developed at IDII by David Cuartielles and his brother. Bluetooth shield on the left, and a motor controller shield on the right. I showed early versions of Wiring to Tom Igoe during a visit to ITP in New York in 2003. At the time, he had no experience with Atmel hardware, as Tom was using PIC microcontrollers at ITP as an alternative to the costly platforms like Parallax Basic Stamp or Basic X. One of Tom's recommendations at this visit was: \"well, do it for PIC, because this is what we use here.\" Years later, in 2007, Tom Igoe released the first edition of the \"Making Things Talk\" book published by O'Reilly 3 , which presents the use of both Wiring and Arduino. Gianluca Martino originally worked for SERP (the factory that made the first 25 Wiring circuit boards) and later he founded Smart Projects SRL (April 1 st , 2004). Smart Projects made the first batch of 100 Wiring boards for IDII to teach physical computing in 2004. What is Programma2003 and How is it Related to You or to Wiring? \u00b6 Programma2003 was a Microchip PIC microcontroller board developed by Massimo Banzi in 2003. After using BasicX to teach Physical computing in the winter of 2002, Massimo decided to do a board using the PIC chip in 2003. The problem with the PIC microcontrollers was that there wasn't an open source toolchain available at the time, to use a language like C to program them. Programma2003 board designed by Massimo Banzi in 2003 Because of the lack of an open source toolchain, Massimo decided to use an environment called JAL (Just Another Language) to program the PIC microcontroller. JAL was created by Wouter van Ooijen. It consisted of the JAL compiler, linker, uploader, bootloader and examples for the PIC. However, the software would only run on Windows. To make JAL easier to use, Massimo used the base examples from JAL and simplified some of them for the distribution package for IDII. However, in 2003, most students at IDII used Mac computers. So I volunteered to help Massimo by making a small and simple environment for Mac OS X so students with a Mac could use it as well. In my thesis document, I characterized Programma2003 as a non-viable model to follow, since other more comprehensive tools were already available in the market. The main problems were: the language is far from useful in any other context (e.g. you can't program your computer using JAL) it's arcane syntax and the hardware design made it highly unlikely to go somewhere in the future for teaching and learning the board didn't have a power LED (a design flaw) It was impossible to know if it was powered or not (frustrating/dangerous in a learning environment) and an additional RS232 to USB expensive converter was required to connect it to a computer. As a gesture to help Massimo's Programma2003 project, I also wrote something I called Programma2003 Interface, which basically interfaced any serial communication between a microcontroller and a computer with the network. This expanded the prototyping toolbox at IDII. It allowed students to use software like Adobe Flash (formerly Macromedia) to communicate with a microcontroller. Programma2003 Interface Code Why Hasn't Arduino Acknowledged Wiring Better? \u00b6 I don't know. The reference to Wiring on the Arduino.cc website, although it has improved slightly over time, is misleading as it tries to attribute Wiring to Programma2003. Arduino.cc website version of Arduino's History from https://www.arduino.cc/en/Main/Credits Adding to the confusion is this Flickr photo album by Massimo Banzi: https://www.flickr.com/photos/mbanzi/albums/72157633136997919/with/8610131426/ It is called \"Teaching: IDII 2004 Strangely Familiar\". Strangely Familiar was taught with Wiring (see above). This photo album seems to associate the Programma2003 with the class, but it was, in fact, never used. It is odd that the Wiring boards are absent from the album, however one Wiring board picture does appear. It is no secret that the acknowledgement of Wiring has been very limited in the past. Back in 2013, at Open Hardware Summit at MIT, during the panel \"Implications of Open Source Business: Forking and Attribution\", David Mellis acknowledges, for the first time, that the Arduino Team hadn't done a very good job acknowledging Wiring. Unfortunately, he didn't go into details why they hadn't. The Plaintiff vs. The Defendant \u00b6 I've been quiet about everything that has happened with Arduino for a long time. But now that people are fraudulently saying that my work is their's, I feel like I need to speak up about the past. For example, in the ongoing case between Arduino LLC and Arduino S.R.L., there is a claim , by the Plaintiff, such that: 34. Banzi is the creator of the Programma2003 Development Platform, a precursor of the many ARDUINO-branded products. See: http://sourceforge.net/projects/programma2003/ . Banzi was also the Master's Thesis advisor of Hernando Barragan whose work would result in the Wiring Development Platform which inspired Arduino. Here is what, in my opinion, is wrong with that claim: The Programma2003 was not a Development Platform, it was simply a board. There was no software developed by the Plaintiff to accompany that board. The link is empty, there are no files in that Sourceforge repository, so why present an empty repository as evidence? The idea that the mere fact that Banzi was my thesis advisor gives him some sort of higher claim to the work done on Wiring, is, to say the least, frustrating to read. Further on: 39. The Founders, assisted by Nicholas Zambetti, another student at IDII, undertook and developed a project in which they designed a platform and environment for microcontroller boards (\"Boards\") to replace the Wiring Development Project. Banzi gave the project its name, the ARDUINO project. Here are the questions I'd ask \"The Founders:\" Why did the \"Wiring Development Project\" need to be replaced? Did you ask the developer if he would work with you? Did you not like the original name? (Banzi gave the project its name, after all) I know it might be done now and again, but, in my opinion, it is unethical and a bad example for academics to do something like this with the work of a student. Educators, more than anybody else, should avoid taking advantage of their student's work. In a way, I still feel violated by \"The Founders\" for calling my work their's. It may be legal to take an open source software and hardware project's model, philosophy, discourse, and the thousands of hours of work by its author, exert a branding exercise on it, and release it to the world as something \"new\" or \"inspired\", but... is it right? Continuous Misleading Information \u00b6 Someone once said: \"If we don't make things ultra clear, people draw their own conclusions and they become facts even if we never said anything like that.\" 4 It seems to me that this is universally true, and especially if you mislead people with only slight alterations of the truth, you can have control over their conclusions. Here are a couple of mainstream examples of misleading information. The Infamous Diagram \u00b6 http://blog.experientia.com/uploads/2013/10/Interaction_Ivrea_arduino.pdf This diagram was produced to tell the story of the prototyping tools developed at IDII. It was beautifully done by Giorgio Olivero, using the content provided by the school in 2005, and released in 2006. The projects presented in the red blobs, although they were made with Wiring, appear to be associated with Arduino at a time when Arduino didn't even exist , nor was even close to being ready to do them. Some of the authors of the projects inquired about the mistake, and why their projects were shifted to Arduino, but received no response. Despite the fact that nothing was changed in this highly public document, I have to thank the support of the students who pointed it out and inquired about it. The Arduino Documentary \u00b6 Another very public piece of media from 2010 was The Arduino Documentary (written and directed by Ra\u00fal Alaejos, Rodrigo Calvo). This one is very interesting, especially seeing it today in 2016. I think the idea of doing a documentary is very good, especially for a project with such a rich history. Here are some parts that present some interesting contradictions: 1:45 - \"We wanted it to be open source so that everybody could come and help, and contribute.\" It is suggested here that Wiring was closed source. Because part of Wiring was based on Processing, and Processing was GPL open source, as well as all the libraries, Wiring, and hence Arduino, had to be open source. It was not an option to have it be closed source. Also, the insinuation that they made the software easier is misleading, since nothing changed in the language, which is the essence of the project's simplicity. 3:20 - David Cuartielles already knew about Wiring, as he was hired to design two plug-in boards for it by IDII in 2005 as pointed out earlier in this document. David Mellis learned physical computing using Wiring as a student at IDII in 2004. Interestingly, Gianluca came in as the person who was able to design the board itself (he wasn't just a contractor for manufacturing); he was part of the \"Arduino Team\". 8:53 - David Cuartielles is presenting at the Media Lab in Madrid, in July 2005: \"Arduino is the last project, I finished it last week. I talked to Ivrea's technical director and told him: Wouldn't it be great if we can do something we offer for free? he says - For free? - Yeah!\" David comes across here as the author of a project that he completed \"last week\", and convincing the \"technical director\" at IDII to offer it for free. 18:56 - Massimo Banzi: For us at the beginning it was a specific need: we knew the school was closing and we were afraid that lawyers would show up one day and say - Everything here goes into a box and gets forgotten about. - So we thought - OK, if we open everything about this, then we can survive the closing of the school - So that was the first step. This one is very special. It misleadingly presents the fact of making Arduino open source as the consequence of the school closing. This poses a question: why would a bunch of lawyers \"put in a box\" a project based on other open source projects? It is almost puerile. The problem is, common people might think this is true, forming altruistic reasons for the team to make Arduino open source. Absence of Recognition Beyond Wiring \u00b6 There seems to be a trend in how the Arduino Team fails to recognize significant parties that contributed to their success. In October 2013, Jan-Christoph Zoels (a former IDII faculty member) wrote to the IDII community mail list, a message presenting the article released at Core77 about the Intel-Arduino news on Wired UK : A proud moment to see Intel referring to an Interaction Ivrea initiative. And a good investment too: Arduino development was started and developed at Interaction Design Institute Ivrea with an original funding of circa 250.000\u20ac. Another good decision was to keep Arduino as open source at the end of Interaction Ivrea in 2005 before merging with Domus. To which Massimo Banzi responded: I would like to point out that we never got any funding from Ivrea for Arduino (apart from buying 50 of them in the last year of the institute) 250.000 EUR is ridiculous\u2026 This article must be retracted now Sorry JC but you had nothing to do.with this.... You can't possibly try to get credit for.something you hadn't been involved with It was nice, however, to get this a few days later in the same email thread: Distorted Public Information \u00b6 In this section, I just wanted to show a fraction of the many different articles (and other press) that have been written about Arduino, which include its history that is rarely told the same way twice. So, please, read them at your leisure, and form your own opinions, and, definitely, ask questions! Poor Journalism \u00b6 It is rare to see well researched journalism these days. The articles below are excellent examples of that postulate. Wired \u00b6 In a 2008 Wired interview , Banzi explains how he did Arduino in a weekend: The two decided to design their own board and enlisted one of Banzi's students\u2014David Mellis\u2014to write the programming language for it. In two days, Mellis banged out the code ; three days more and the board was complete. They called it the Arduino, after a nearby pub, and it was an instant hit with the students. This article has been written without any fact checking. It certainly doesn't help that the interviewee isn't telling them the right information. IEEE Spectrum \u00b6 Here is a 2011 IEEE Spectrum article , titled \"The Making of Arduino\". Again, the history is taken verbatim from the interviewee. I was not contacted before the article was published, even though I was mentioned. And I doubt that anyone from IDII was contacted. Just one of the many confusing parts of Arduino's history is in this quote: Since the purpose was to create a quick and easily accessible platform, they felt they'd be better off opening up the project to as many people as possible rather than keeping it closed. It was never closed. Circuits Today \u00b6 A 2014 article from Circuits Today has a very confusing opening: It was in the Interactive Design Institute [sic] that a hardware thesis was contributed for a wiring design by a Colombian student named Hernando Barragan. The title of the thesis was \"Arduino\u2013La rivoluzione dell'open hardware\" (\"Arduino \u2013 The Revolution of Open Hardware\"). Yes, it sounded a little different from the usual thesis but none would have imagined that it would carve a niche in the field of electronics. A team of five developers worked on this thesis and when the new wiring platform was complete, they worked to make it much lighter, less expensive, and available to the open source community. The title of my thesis is obviously wrong. There weren't five \"developers\" working on the thesis. And the code was always open source. Again, I wasn't contacted for reference. Makezine \u00b6 In a 2013 interview by Dale Dougherty with Massimo Banzi , once again the story changes: Wiring had an expensive board, about $100, because it used an expensive chip. I didn't like that, and the student developer and I disagreed. In this version of the story by Massimo Banzi, Arduino originated from Wiring, but it is implied that I was insistent on having an expensive board. Regarding the \"disagreement\": I never had a discussion with Massimo Banzi about the board being too expensive. I wish that he and I would have had more discussions on such matters, as I had with other advisors and colleagues, as I find it very enriching. The closest thing to a disagreement took place after a successful thesis presentation event, where Massimo showed some odd behaviour towards me. Because he was my advisor, I was at a disadvantage, but I asked Massimo why he was behaving badly towards me, to which I received no answer. I felt threatened, and it was very awkward. His odd behaviour extended to those who collaborated with me on Wiring later on. I decided that we could make an open source version of Wiring, starting from scratch. I asked Gianluca Martino [now one of the five Arduino partners] to help me manufacture the first prototypes, the first boards. Here, Massimo is again implying that Wiring wasn't open source, which it was. And also that they would build the software from \"scratch\", which they didn't. Academic Mistakes \u00b6 I understand how easy it is to engage people with good storytelling and compelling tales, but academics are expected to do their homework, and at least check the facts behind unsubstantiated statements. In this book, Making Futures: Marginal Notes on Innovation, Design, and Democracy Hardcover \u2013 October 31, 2014 by Pelle Ehn (Editor), Elisabet M. Nilsson (Editor), Richard Topgaard (Editor): Chapter 8: How Deep is Your Love? On Open-Source Hardware (David Cuartielles) Info In 2005, at the Interaction Design Institute Ivrea, we had the vision that making a small prototyping platform aimed at designers would help them getting a better understanding of technology. David Cuartielles' version of Arduino's history doesn't even include Wiring. This book has been released chapter by chapter under Creative Commons: http://dspace.mah.se/handle/2043/17985 More Links for Your Perusal \u00b6 Wiring as predecessor to Arduino: http://ptgmedia.pearsoncmg.com/images/9780321906045/samplepages/9780321906045.pdf Interview with Ben Fry and Casey Reas: http://rhizome.org/editorial/2009/sep/23/interview-with-casey-reas-and-ben-fry/ Safari Books Online, Casey Reas, Getting Started with Processing, Chapter One, Family Tree: https://www.safaribooksonline.com/library/view/getting-started-with/9781449379827/ch01.html Nicholas Zambetti Arduino Project Page: http://www.zambetti.com/projects/arduino/ (Nicholas did a lot of work with both Wiring and Arduino) Articles About Arduino vs. Arduino \u00b6 Wired Italy - What's happening in Arduino? http://www.wired.it/gadget/computer/2015/02/12/arduino-nel-caos-situazione/ Repubblica Italy - Massimo Banzi: \"The Reason of the War for Arduino\" http://playground.blogautore.repubblica.it/2015/02/11/la-guerra-per-arduino-la-perla-hi-tech-italiana-nel-caos/ Makezine - Massimo Banzi Fighting for Arduino http://makezine.com/2015/03/19/massimo-banzi-fighting-for-arduino/ Hackaday - Federico Musto of Arduino SRL discusses Arduino legal situation http://hackaday.com/2015/07/23/hackaday-interviews-federico-musto-of-arduino-srl/ Hackaday - Federico Musto of Arduino SRL shows us new products and new directions http://hackaday.com/2016/01/04/new-products-and-new-directions-an-interview-with-federico-musto-of-arduino-srl/ Video \u00b6 Massimo going to Ted Talk -- candid (2012-08-06) This is a candid view of Massimo just before performing at a TED Talk. You can make your own mind up about the majority of the video, however, the most interesting comment, in my opinion, is at the end , where he says: Massimo going to Ted Talk ... Innovation without asking for permission. So, in a way, Open Source allows you to be innovative without asking for permission. Thank You! \u00b6 Thank you for taking time to read this. I think it is very important, not just in the academic world, to properly acknowledge the origin of things. As I learned from fantastic educators, doing this properly not only enriches your work, but also positions it better to allow others to investigate and see where your ideas come from. Maybe they will find other alternatives or improve what was done and better position their own ideas. Personally, watching the outreach of what I created back in 2003 in so many different contexts, seeing those commands bringing to life people's ideas and creations from all over the world, has brought me so many satisfactions, surprises, new questions, ideas, awareness and friendships. I am thankful for that. I think it is important to know the past to avoid making the same mistakes in the future. Sometimes I wish I would have had a chance to talk about this differently, for a different motif. Instead, many times I have come across journalists and common people compromised in their independence. Either they had direct business with Arduino, or simply wanted to avoid upsetting Massimo Banzi. Or there are the close-minded individuals following a cause and refusing to see or hear anything different from what they believe. And then there are the individuals who are just part of the crowd that reproduce what they are told to reproduce. For those others, this document is an invitation to trust your curiosity, to question, to dig deeper in whatever interests you and is important to you as an individual or as a member of a community. I'll see you soon, Hernando. The notion of a \"Sketch\" within the context of writing programs comes from Processing and previously from Design by Numbers (DBN). It was extended by Wiring within the context of prototyping with electronics or \"sketching\" with hardware. \u21a9 Interactive Telecommunications Program at New York University \u21a9 Page 34, ISBN-13: 978-0596510510 ISBN-10: 0596510519, http://www.amazon.com/Making-Things-Talk-Practical-Connecting/dp/0596510519/ref=sr_1_2?ie=UTF8&sr=8-2&keywords=Making+Things+Talk \u21a9 https://groups.google.com/a/arduino.cc/d/msg/developers/HEKecd0qhS4/nADS2jW6DgAJ \u21a9","title":"The Untold History of Arduino"},{"location":"tnt/the-untold-history-of-arduino/#the-untold-history-of-arduino","text":"","title":"The Untold History of Arduino"},{"location":"tnt/the-untold-history-of-arduino/#why-are-you-writing-this","text":"Hello. My name is Hernando Barrag\u00e1n . Through the years, and more recently due to the affairs between Arduino LLC and Arduino S.R.L. , I have received a lot of questions from people about the history of Wiring and, of course, Arduino. I was also shown this US Federal Courts website , which presents documents citing my work to support the plaintiff's claims which, in my opinion, contribute to the distortion of information surrounding my work. The history of Arduino has been told by many people, and no two stories match. I want to clarify some facts around the history of Arduino, with proper supported references and documents, to better communicate to people who are interested, about Arduino's origin. As well, I will attempt to correct some things that have distorted my role or work by pointing out common mistakes, misleading information, and poor journalism. I will go through a summary of the history first, then I will answer a series of questions that I have been often asked over the years.","title":"Why Are You Writing This?"},{"location":"tnt/the-untold-history-of-arduino/#why-did-you-create-wiring","text":"I started Wiring in 2003 as my Master's thesis project at the Interaction Design Institute Ivrea (IDII) in Italy. The objective of the thesis was to make it easy for artists and designers to work with electronics, by abstracting away the often complicated details of electronics so they can focus on their own objectives. The full thesis document can be downloaded here: http://people.interactionivrea.org/h.barragan/thesis/thesis_low_res.pdf Massimo Banzi and Casey Reas (known for his work on Processing ) were supervisors for my thesis. The project received plenty of attention at IDII, and was used for several other projects from 2004, up until the closure of the school in 2005. Because of my thesis, I was proud to graduate with distinction; the only individual at IDII in 2004 to receive the distinction. I continued the development of Wiring while working at the Universidad de Los Andes in Colombia, where I began teaching as an instructor in Interaction Design. What Wiring is, and why it was created can be extracted from the abstract section of my thesis document. Please keep in mind that it was 2003, and these premises are not to be taken lightly. You may have heard them before recited as proclamations: \"... Current prototyping tools for electronics and programming are mostly targeted to engineering, robotics and technical audiences. They are hard to learn, and the programming languages are far from useful in contexts outside a specific technology ...\" \"... It can also be used to teach and learn computer programming and prototyping with electronics...\" \"Wiring builds on Processing...\" These were the key resulting elements of Wiring: Simple integrated development environment (IDE), based on the Processing.org IDE running on Microsoft Windows, Mac OS X, and Linux to create software programs or \"sketches\" 1 , with a simple editor Simple \"language\" or programming \"framework\" for microcontrollers Complete toolchain integration (transparent to user) Bootloader for easy uploading of programs Serial monitor to inspect and send data from/to the microcontroller Open source software Open source hardware designs based on an Atmel microcontroller Comprehensive online reference for the commands and libraries, examples, tutorials, forum and a showcase of projects done using Wiring","title":"Why Did You Create Wiring?"},{"location":"tnt/the-untold-history-of-arduino/#how-was-wiring-created","text":"Through the thesis document, it is possible to understand the design process I followed. Considerable research and references to prior work has served as a basis for my work. To quickly illustrate the process, a few key points are provided below.","title":"How Was Wiring Created?"},{"location":"tnt/the-untold-history-of-arduino/#the-language","text":"Have you ever wondered where those commands come from? Probably one of the most distinctive things, that is widely known and used today by Arduino users in their sketches, is the set of commands I created as the language definition for Wiring. pinMode () digitalRead () digitalWrite () analogRead () analogWrite () delay () millis () etc... Abstracting the microcontroller pins as numbers was, without a doubt, a major decision, possible because the syntax was defined prior to implementation in any hardware platform. All the language command naming and syntax were the result of an exhaustive design process I conducted, which included user testing with students, observation, analysis, adjustment and iteration. As I developed the hardware prototypes, the language also naturally developed. It wasn't until after the final prototype had been made that the language became solid and refined. If you are still curious about the design process, it is detailed in the thesis document, including earlier stages of command naming and syntax that were later discarded.","title":"The Language"},{"location":"tnt/the-untold-history-of-arduino/#the-hardware","text":"From a designer's point of view, this was probably the most difficult part to address. I asked for or bought evaluation boards from different microcontroller manufacturers. Here are some key moments in the hardware design for Wiring.","title":"The Hardware"},{"location":"tnt/the-untold-history-of-arduino/#prototype-1","text":"The first prototype for Wiring used the Parallax Javelin Stamp microcontroller. It was a natural option since it was programmed in a subset of the Java language, which was already being used by Processing. Problem: as described in the thesis document on page 40, compiling, linking and uploading of user's programs relied on Parallax's proprietary tools. Since Wiring was planned as open source software, the Javelin Stamp was simply not a viable option. Above: Cupcake indexer in progress For the next prototypes, microcontrollers were chosen on a basis of availability of open source tools for compiling, linking and uploading the user's code. This led to discarding the very popular Microchip PIC family of microcontrollers very early, because, at the time (circa 2003), Microchip did not have an open source toolchain.","title":"Prototype 1"},{"location":"tnt/the-untold-history-of-arduino/#prototype-2","text":"For the second Wiring hardware prototype, the Atmel ARM-based AT91R40008 microcontroller was selected, which lead to excellent results. The first sketch examples were developed and command naming testing began. For example, pinWrite () used to be the name of the now ubiquitous digitalWrite () . The Atmel R40008 served as a test bed for the digital input/output API and the serial communications API, during my evaluation of its capabilities. The Atmel R40008 was a very powerful microcontroller, but was far too complex for a hands-on approach because it was almost impossible to solder by hand onto a printed circuit board. For more information on this prototype, see page 42 in the thesis document.","title":"Prototype 2"},{"location":"tnt/the-untold-history-of-arduino/#prototype-3","text":"The previous prototype experiments led to the third prototype, where the microcontroller was downscaled to one still powerful, yet with the possibility of tinkering with it without the requirements of specialized equipment or on-board extra peripherals. I selected the Atmel ATmega128 microcontroller and bought an Atmel STK500 evaluation board with a special socket for the ATmega128. Photo of Atmel STK500 with ATmega128 expansion. Tests with the STK500 were immediately successful, so I bought a MAVRIC board from BDMICRO with the ATmega128 soldered. Brian Dean's work on his MAVRIC boards were unparalleled at that time, and his work drove him to build a software tool to easily upload new programs to his board. It is still used today in the Arduino software, and is called \"avrdude\". As traditional COM ports were disappearing from computers, I selected FTDI hardware for communication through a USB port on the host computer. FTDI provided drivers for Windows, Mac OS X and Linux which was required for the Wiring environment to work on all platforms. Photo of BDMICRO MAVRIC-II used for the third Wiring hardware prototype. Photo of an FTDI FT232BM evaluation board used in the third Wiring hardware prototype. The FTDI evaluation board was interfaced with the MAVRIC board and tested with the third Wiring prototype. Testing with the BDMICRO MAVRIC-II board and FTDI-FT232BM. In early 2004, based on the prototype using the MAVRIC board (Prototype 3), I used Brian Dean's and Pascal Stang's schematic designs as a reference to create the first Wiring board design. It had the following features: ATmega128 FTDI232BM for serial to USB conversion An on-board LED connected to a pin A power LED and serial RX/TX LEDs I used Eagle PCB from Cadsoft to design the schematic and printed circuit board. Wiring board schematic. Wiring board printed circuit board layout. Along with the third prototype, the final version of the API was tested and refined. More examples were added and I wrote the first LED blink example that is still used today as the first sketch that a user runs on an Arduino board to learn the environment. Even more examples were developed to support liquid crystal displays (LCDs), serial port communication, servo motors, etc. and even to interface Wiring with Processing via serial communication. Details can be found on page 50 in the thesis document. In March 2004, 25 Wiring printed circuit boards were ordered and manufactured at SERP , and paid for by IDII. I hand-soldered these 25 boards and started to conduct usability tests with some of my classmates at IDII. It was an exciting time! Photos of the first Wiring board","title":"Prototype 3"},{"location":"tnt/the-untold-history-of-arduino/#continuing-the-development","text":"After graduating from IDII in 2004, I moved back to Colombia, and began teaching as an instructor in Interaction Design at the Universidad de Los Andes. As I continued to develop Wiring, IDII decided to print and assemble a batch of 100 Wiring boards to teach physical computing at IDII in late 2004. Bill Verplank (a former IDII faculty member) asked Massimo Banzi to send 10 of the boards to me for use in my classes in Colombia. In 2004, Faculty member Yaniv Steiner , former student of Giorgio Olivero and Paolo Sancis, started the Instant Soup Project , based on Wiring at IDII.","title":"Continuing the Development"},{"location":"tnt/the-untold-history-of-arduino/#first-major-success-strangely-familiar","text":"In the autumn of 2004, Wiring was used to teach physical computing at IDII through a project called Strangely Familiar, consisting of 22 students, and 11 successful projects. Four faculty members ran the 4-week project: Massimo Banzi Heather Martin Yaniv Steiner Reto Wettach It turned out to be a resounding success for both the students as well as the professors and teachers. Strangely Familiar demonstrated the potential of Wiring as an innovation platform for interaction design. On December 16 th , 2004, Bill Verplank sent an email to me saying: [The projects] were wonderful. Everyone had things working. Five of the projects had motors in them! The most advanced (from two MIT grads - architect and mathematician) allowed drawing a profile in Proce55ing and feeling it with a wheel/motor run by Wiring... It is clear that one of the elements of success was [the] use of the Wiring board. Here is the brief for the course: http://wiring.org.co/exhibition/images/brief.pdf Here is a booklet with the resulting projects: http://wiring.org.co/exhibition/images/book01.pdf Tug Tug phones by Haiyan Zhang (with Aram Armstrong) Commitment Radio by David Chiu and Alexandra Deschamps-Sonsino Speak Out by Tristam Sparks and Andreea Cherlaru (with Ana Camila Amorim) Feel the Music I by James Tichenor and David A. Mellis The Amazing All Band Radio by Oren Horev & Myriel Milicevic (with Marcos Weskamp)","title":"First Major Success - Strangely Familiar"},{"location":"tnt/the-untold-history-of-arduino/#the-rest-of-the-world","text":"In May 2005, I contracted Advanced Circuits in the USA to print the first 200 printed circuit boards outside of IDII, and assembled them in Colombia. I began selling and shipping boards to various schools and universities, and by the end of 2005, Wiring was being used around the world. \"Wiring's Reach by 2005\" graphic, provided by Collin Reisdorf","title":"The Rest of the World"},{"location":"tnt/the-untold-history-of-arduino/#when-did-arduino-begin-and-why-werent-you-a-member-of-the-arduino-team","text":"","title":"When Did Arduino Begin and Why Weren't You a Member of the Arduino Team?"},{"location":"tnt/the-untold-history-of-arduino/#the-formation-of-arduino","text":"When IDII manufactured the first set of Wiring boards, the cost was probably around USD$50 each. (I don't know what the actual cost was, as I wasn't involved in the process. However, I was selling the boards from Colombia for about USD$60.) This was a considerable drop in price from the boards that were currently available, but it was still a significant cost for most people. In 2005, Massimo Banzi, along with David Mellis (an IDII student at the time) and David Cuartielles, added support for the cheaper ATmega8 microcontroller to Wiring. Then they forked (or copied) the Wiring source code and started running it as a separate project, called Arduino. There was no need to create a separate project, as I would have gladly helped them and developed support for the ATmega8 and any other microcontrollers. I had planned to do this all along. I had inadvertantly taken a photo of some notes about my plans for Wiring, in the photo of Karmen Franinovic (former IDII student from 2002 to 2004) testing a stretch sensor for a lamp in March 2004. Wiring and Arduino shared many of the early development done by Nicholas Zambetti , a former IDII student in the same class as David Mellis. For a brief time, Nicholas had been considered a member of the Arduino Team. Around the same time, Gianluca Martino (he was a consultant at SERP, the printed circuit board factory at Ivrea where the first Wiring boards were made), joined the Arduino Team to help with manufacturing and hardware development. So, to reduce the cost of their boards, Gianluca, with some help from David Cuartielles, developed cheaper hardware by using the ATmega8. Apparently this is the first \"Arduino\" prototype - dubbed Wiring Lite. I think Massimo Banzi designed this one, but I'm unsure. Arduino Extreme v2 - \"Second production version of the Arduino USB boards. This has been properly engineered by Gianluca Martino.\" Tom Igoe (a faculty member at the ITP at NYU 2 ) was invited by Massimo Banzi to IDII for a workshop and became part of the Arduino Team. To this day, I do not know exactly why the Arduino Team forked the code from Wiring. It was also puzzling why we didn't work together. So, to answer the question, I was never asked to become a member of the Arduino Team. Even though I was perplexed by the Arduino Team forking the code, I continued development on Wiring, and almost all of the improvements that had been made to Wiring, by me and plenty of contributors, were merged into the Arduino source code. I tried to ignore the fact that they were still taking my work and also wondered about the redundancy and waste of resources in duplicating efforts. By the end of 2005, I started to work with Casey Reas on a chapter for the book \" Processing: A Programming Handbook for Visual Artists and Designers .\" The chapter presents a short history of electronics in the Arts. It includes examples for interfacing Processing with Wiring and Arduino. I presented those examples in both platforms and made sure the examples included worked for both Wiring and Arduino. The book got a second edition in 2013 and the chapter was revised again by Casey and me, and the extension has been made available online since 2014.","title":"The Formation of Arduino"},{"location":"tnt/the-untold-history-of-arduino/#did-the-arduino-team-work-with-wiring-before-arduino","text":"Yes, each of them had experience with Wiring before creating Arduino. Massimo Banzi taught with Wiring at IDII from 2004. Massimo Banzi teaching interaction design at IDII with Wiring boards in 2004. David Mellis was a student at IDII from 2004 to 2005. A blurry version of David Mellis learning physical computing with Wiring in 2004. In January 2005, IDII hired David Cuartielles to develop a couple of plug-in boards for the Wiring board, for motor control and bluetooth connectivity. Two plug-in boards developed at IDII by David Cuartielles and his brother. Bluetooth shield on the left, and a motor controller shield on the right. I showed early versions of Wiring to Tom Igoe during a visit to ITP in New York in 2003. At the time, he had no experience with Atmel hardware, as Tom was using PIC microcontrollers at ITP as an alternative to the costly platforms like Parallax Basic Stamp or Basic X. One of Tom's recommendations at this visit was: \"well, do it for PIC, because this is what we use here.\" Years later, in 2007, Tom Igoe released the first edition of the \"Making Things Talk\" book published by O'Reilly 3 , which presents the use of both Wiring and Arduino. Gianluca Martino originally worked for SERP (the factory that made the first 25 Wiring circuit boards) and later he founded Smart Projects SRL (April 1 st , 2004). Smart Projects made the first batch of 100 Wiring boards for IDII to teach physical computing in 2004.","title":"Did The Arduino Team Work with Wiring Before Arduino?"},{"location":"tnt/the-untold-history-of-arduino/#what-is-programma2003-and-how-is-it-related-to-you-or-to-wiring","text":"Programma2003 was a Microchip PIC microcontroller board developed by Massimo Banzi in 2003. After using BasicX to teach Physical computing in the winter of 2002, Massimo decided to do a board using the PIC chip in 2003. The problem with the PIC microcontrollers was that there wasn't an open source toolchain available at the time, to use a language like C to program them. Programma2003 board designed by Massimo Banzi in 2003 Because of the lack of an open source toolchain, Massimo decided to use an environment called JAL (Just Another Language) to program the PIC microcontroller. JAL was created by Wouter van Ooijen. It consisted of the JAL compiler, linker, uploader, bootloader and examples for the PIC. However, the software would only run on Windows. To make JAL easier to use, Massimo used the base examples from JAL and simplified some of them for the distribution package for IDII. However, in 2003, most students at IDII used Mac computers. So I volunteered to help Massimo by making a small and simple environment for Mac OS X so students with a Mac could use it as well. In my thesis document, I characterized Programma2003 as a non-viable model to follow, since other more comprehensive tools were already available in the market. The main problems were: the language is far from useful in any other context (e.g. you can't program your computer using JAL) it's arcane syntax and the hardware design made it highly unlikely to go somewhere in the future for teaching and learning the board didn't have a power LED (a design flaw) It was impossible to know if it was powered or not (frustrating/dangerous in a learning environment) and an additional RS232 to USB expensive converter was required to connect it to a computer. As a gesture to help Massimo's Programma2003 project, I also wrote something I called Programma2003 Interface, which basically interfaced any serial communication between a microcontroller and a computer with the network. This expanded the prototyping toolbox at IDII. It allowed students to use software like Adobe Flash (formerly Macromedia) to communicate with a microcontroller. Programma2003 Interface Code","title":"What is Programma2003 and How is it Related to You or to Wiring?"},{"location":"tnt/the-untold-history-of-arduino/#why-hasnt-arduino-acknowledged-wiring-better","text":"I don't know. The reference to Wiring on the Arduino.cc website, although it has improved slightly over time, is misleading as it tries to attribute Wiring to Programma2003. Arduino.cc website version of Arduino's History from https://www.arduino.cc/en/Main/Credits Adding to the confusion is this Flickr photo album by Massimo Banzi: https://www.flickr.com/photos/mbanzi/albums/72157633136997919/with/8610131426/ It is called \"Teaching: IDII 2004 Strangely Familiar\". Strangely Familiar was taught with Wiring (see above). This photo album seems to associate the Programma2003 with the class, but it was, in fact, never used. It is odd that the Wiring boards are absent from the album, however one Wiring board picture does appear. It is no secret that the acknowledgement of Wiring has been very limited in the past. Back in 2013, at Open Hardware Summit at MIT, during the panel \"Implications of Open Source Business: Forking and Attribution\", David Mellis acknowledges, for the first time, that the Arduino Team hadn't done a very good job acknowledging Wiring. Unfortunately, he didn't go into details why they hadn't.","title":"Why Hasn't Arduino Acknowledged Wiring Better?"},{"location":"tnt/the-untold-history-of-arduino/#the-plaintiff-vs-the-defendant","text":"I've been quiet about everything that has happened with Arduino for a long time. But now that people are fraudulently saying that my work is their's, I feel like I need to speak up about the past. For example, in the ongoing case between Arduino LLC and Arduino S.R.L., there is a claim , by the Plaintiff, such that: 34. Banzi is the creator of the Programma2003 Development Platform, a precursor of the many ARDUINO-branded products. See: http://sourceforge.net/projects/programma2003/ . Banzi was also the Master's Thesis advisor of Hernando Barragan whose work would result in the Wiring Development Platform which inspired Arduino. Here is what, in my opinion, is wrong with that claim: The Programma2003 was not a Development Platform, it was simply a board. There was no software developed by the Plaintiff to accompany that board. The link is empty, there are no files in that Sourceforge repository, so why present an empty repository as evidence? The idea that the mere fact that Banzi was my thesis advisor gives him some sort of higher claim to the work done on Wiring, is, to say the least, frustrating to read. Further on: 39. The Founders, assisted by Nicholas Zambetti, another student at IDII, undertook and developed a project in which they designed a platform and environment for microcontroller boards (\"Boards\") to replace the Wiring Development Project. Banzi gave the project its name, the ARDUINO project. Here are the questions I'd ask \"The Founders:\" Why did the \"Wiring Development Project\" need to be replaced? Did you ask the developer if he would work with you? Did you not like the original name? (Banzi gave the project its name, after all) I know it might be done now and again, but, in my opinion, it is unethical and a bad example for academics to do something like this with the work of a student. Educators, more than anybody else, should avoid taking advantage of their student's work. In a way, I still feel violated by \"The Founders\" for calling my work their's. It may be legal to take an open source software and hardware project's model, philosophy, discourse, and the thousands of hours of work by its author, exert a branding exercise on it, and release it to the world as something \"new\" or \"inspired\", but... is it right?","title":"The Plaintiff vs. The Defendant"},{"location":"tnt/the-untold-history-of-arduino/#continuous-misleading-information","text":"Someone once said: \"If we don't make things ultra clear, people draw their own conclusions and they become facts even if we never said anything like that.\" 4 It seems to me that this is universally true, and especially if you mislead people with only slight alterations of the truth, you can have control over their conclusions. Here are a couple of mainstream examples of misleading information.","title":"Continuous Misleading Information"},{"location":"tnt/the-untold-history-of-arduino/#the-infamous-diagram","text":"http://blog.experientia.com/uploads/2013/10/Interaction_Ivrea_arduino.pdf This diagram was produced to tell the story of the prototyping tools developed at IDII. It was beautifully done by Giorgio Olivero, using the content provided by the school in 2005, and released in 2006. The projects presented in the red blobs, although they were made with Wiring, appear to be associated with Arduino at a time when Arduino didn't even exist , nor was even close to being ready to do them. Some of the authors of the projects inquired about the mistake, and why their projects were shifted to Arduino, but received no response. Despite the fact that nothing was changed in this highly public document, I have to thank the support of the students who pointed it out and inquired about it.","title":"The Infamous Diagram"},{"location":"tnt/the-untold-history-of-arduino/#the-arduino-documentary","text":"Another very public piece of media from 2010 was The Arduino Documentary (written and directed by Ra\u00fal Alaejos, Rodrigo Calvo). This one is very interesting, especially seeing it today in 2016. I think the idea of doing a documentary is very good, especially for a project with such a rich history. Here are some parts that present some interesting contradictions: 1:45 - \"We wanted it to be open source so that everybody could come and help, and contribute.\" It is suggested here that Wiring was closed source. Because part of Wiring was based on Processing, and Processing was GPL open source, as well as all the libraries, Wiring, and hence Arduino, had to be open source. It was not an option to have it be closed source. Also, the insinuation that they made the software easier is misleading, since nothing changed in the language, which is the essence of the project's simplicity. 3:20 - David Cuartielles already knew about Wiring, as he was hired to design two plug-in boards for it by IDII in 2005 as pointed out earlier in this document. David Mellis learned physical computing using Wiring as a student at IDII in 2004. Interestingly, Gianluca came in as the person who was able to design the board itself (he wasn't just a contractor for manufacturing); he was part of the \"Arduino Team\". 8:53 - David Cuartielles is presenting at the Media Lab in Madrid, in July 2005: \"Arduino is the last project, I finished it last week. I talked to Ivrea's technical director and told him: Wouldn't it be great if we can do something we offer for free? he says - For free? - Yeah!\" David comes across here as the author of a project that he completed \"last week\", and convincing the \"technical director\" at IDII to offer it for free. 18:56 - Massimo Banzi: For us at the beginning it was a specific need: we knew the school was closing and we were afraid that lawyers would show up one day and say - Everything here goes into a box and gets forgotten about. - So we thought - OK, if we open everything about this, then we can survive the closing of the school - So that was the first step. This one is very special. It misleadingly presents the fact of making Arduino open source as the consequence of the school closing. This poses a question: why would a bunch of lawyers \"put in a box\" a project based on other open source projects? It is almost puerile. The problem is, common people might think this is true, forming altruistic reasons for the team to make Arduino open source.","title":"The Arduino Documentary"},{"location":"tnt/the-untold-history-of-arduino/#absence-of-recognition-beyond-wiring","text":"There seems to be a trend in how the Arduino Team fails to recognize significant parties that contributed to their success. In October 2013, Jan-Christoph Zoels (a former IDII faculty member) wrote to the IDII community mail list, a message presenting the article released at Core77 about the Intel-Arduino news on Wired UK : A proud moment to see Intel referring to an Interaction Ivrea initiative. And a good investment too: Arduino development was started and developed at Interaction Design Institute Ivrea with an original funding of circa 250.000\u20ac. Another good decision was to keep Arduino as open source at the end of Interaction Ivrea in 2005 before merging with Domus. To which Massimo Banzi responded: I would like to point out that we never got any funding from Ivrea for Arduino (apart from buying 50 of them in the last year of the institute) 250.000 EUR is ridiculous\u2026 This article must be retracted now Sorry JC but you had nothing to do.with this.... You can't possibly try to get credit for.something you hadn't been involved with It was nice, however, to get this a few days later in the same email thread:","title":"Absence of Recognition Beyond Wiring"},{"location":"tnt/the-untold-history-of-arduino/#distorted-public-information","text":"In this section, I just wanted to show a fraction of the many different articles (and other press) that have been written about Arduino, which include its history that is rarely told the same way twice. So, please, read them at your leisure, and form your own opinions, and, definitely, ask questions!","title":"Distorted Public Information"},{"location":"tnt/the-untold-history-of-arduino/#poor-journalism","text":"It is rare to see well researched journalism these days. The articles below are excellent examples of that postulate.","title":"Poor Journalism"},{"location":"tnt/the-untold-history-of-arduino/#wired","text":"In a 2008 Wired interview , Banzi explains how he did Arduino in a weekend: The two decided to design their own board and enlisted one of Banzi's students\u2014David Mellis\u2014to write the programming language for it. In two days, Mellis banged out the code ; three days more and the board was complete. They called it the Arduino, after a nearby pub, and it was an instant hit with the students. This article has been written without any fact checking. It certainly doesn't help that the interviewee isn't telling them the right information.","title":"Wired"},{"location":"tnt/the-untold-history-of-arduino/#ieee-spectrum","text":"Here is a 2011 IEEE Spectrum article , titled \"The Making of Arduino\". Again, the history is taken verbatim from the interviewee. I was not contacted before the article was published, even though I was mentioned. And I doubt that anyone from IDII was contacted. Just one of the many confusing parts of Arduino's history is in this quote: Since the purpose was to create a quick and easily accessible platform, they felt they'd be better off opening up the project to as many people as possible rather than keeping it closed. It was never closed.","title":"IEEE Spectrum"},{"location":"tnt/the-untold-history-of-arduino/#circuits-today","text":"A 2014 article from Circuits Today has a very confusing opening: It was in the Interactive Design Institute [sic] that a hardware thesis was contributed for a wiring design by a Colombian student named Hernando Barragan. The title of the thesis was \"Arduino\u2013La rivoluzione dell'open hardware\" (\"Arduino \u2013 The Revolution of Open Hardware\"). Yes, it sounded a little different from the usual thesis but none would have imagined that it would carve a niche in the field of electronics. A team of five developers worked on this thesis and when the new wiring platform was complete, they worked to make it much lighter, less expensive, and available to the open source community. The title of my thesis is obviously wrong. There weren't five \"developers\" working on the thesis. And the code was always open source. Again, I wasn't contacted for reference.","title":"Circuits Today"},{"location":"tnt/the-untold-history-of-arduino/#makezine","text":"In a 2013 interview by Dale Dougherty with Massimo Banzi , once again the story changes: Wiring had an expensive board, about $100, because it used an expensive chip. I didn't like that, and the student developer and I disagreed. In this version of the story by Massimo Banzi, Arduino originated from Wiring, but it is implied that I was insistent on having an expensive board. Regarding the \"disagreement\": I never had a discussion with Massimo Banzi about the board being too expensive. I wish that he and I would have had more discussions on such matters, as I had with other advisors and colleagues, as I find it very enriching. The closest thing to a disagreement took place after a successful thesis presentation event, where Massimo showed some odd behaviour towards me. Because he was my advisor, I was at a disadvantage, but I asked Massimo why he was behaving badly towards me, to which I received no answer. I felt threatened, and it was very awkward. His odd behaviour extended to those who collaborated with me on Wiring later on. I decided that we could make an open source version of Wiring, starting from scratch. I asked Gianluca Martino [now one of the five Arduino partners] to help me manufacture the first prototypes, the first boards. Here, Massimo is again implying that Wiring wasn't open source, which it was. And also that they would build the software from \"scratch\", which they didn't.","title":"Makezine"},{"location":"tnt/the-untold-history-of-arduino/#academic-mistakes","text":"I understand how easy it is to engage people with good storytelling and compelling tales, but academics are expected to do their homework, and at least check the facts behind unsubstantiated statements. In this book, Making Futures: Marginal Notes on Innovation, Design, and Democracy Hardcover \u2013 October 31, 2014 by Pelle Ehn (Editor), Elisabet M. Nilsson (Editor), Richard Topgaard (Editor): Chapter 8: How Deep is Your Love? On Open-Source Hardware (David Cuartielles) Info In 2005, at the Interaction Design Institute Ivrea, we had the vision that making a small prototyping platform aimed at designers would help them getting a better understanding of technology. David Cuartielles' version of Arduino's history doesn't even include Wiring. This book has been released chapter by chapter under Creative Commons: http://dspace.mah.se/handle/2043/17985","title":"Academic Mistakes"},{"location":"tnt/the-untold-history-of-arduino/#more-links-for-your-perusal","text":"Wiring as predecessor to Arduino: http://ptgmedia.pearsoncmg.com/images/9780321906045/samplepages/9780321906045.pdf Interview with Ben Fry and Casey Reas: http://rhizome.org/editorial/2009/sep/23/interview-with-casey-reas-and-ben-fry/ Safari Books Online, Casey Reas, Getting Started with Processing, Chapter One, Family Tree: https://www.safaribooksonline.com/library/view/getting-started-with/9781449379827/ch01.html Nicholas Zambetti Arduino Project Page: http://www.zambetti.com/projects/arduino/ (Nicholas did a lot of work with both Wiring and Arduino)","title":"More Links for Your Perusal"},{"location":"tnt/the-untold-history-of-arduino/#articles-about-arduino-vs-arduino","text":"Wired Italy - What's happening in Arduino? http://www.wired.it/gadget/computer/2015/02/12/arduino-nel-caos-situazione/ Repubblica Italy - Massimo Banzi: \"The Reason of the War for Arduino\" http://playground.blogautore.repubblica.it/2015/02/11/la-guerra-per-arduino-la-perla-hi-tech-italiana-nel-caos/ Makezine - Massimo Banzi Fighting for Arduino http://makezine.com/2015/03/19/massimo-banzi-fighting-for-arduino/ Hackaday - Federico Musto of Arduino SRL discusses Arduino legal situation http://hackaday.com/2015/07/23/hackaday-interviews-federico-musto-of-arduino-srl/ Hackaday - Federico Musto of Arduino SRL shows us new products and new directions http://hackaday.com/2016/01/04/new-products-and-new-directions-an-interview-with-federico-musto-of-arduino-srl/","title":"Articles About Arduino vs. Arduino"},{"location":"tnt/the-untold-history-of-arduino/#video","text":"Massimo going to Ted Talk -- candid (2012-08-06) This is a candid view of Massimo just before performing at a TED Talk. You can make your own mind up about the majority of the video, however, the most interesting comment, in my opinion, is at the end , where he says: Massimo going to Ted Talk ... Innovation without asking for permission. So, in a way, Open Source allows you to be innovative without asking for permission.","title":"Video"},{"location":"tnt/the-untold-history-of-arduino/#thank-you","text":"Thank you for taking time to read this. I think it is very important, not just in the academic world, to properly acknowledge the origin of things. As I learned from fantastic educators, doing this properly not only enriches your work, but also positions it better to allow others to investigate and see where your ideas come from. Maybe they will find other alternatives or improve what was done and better position their own ideas. Personally, watching the outreach of what I created back in 2003 in so many different contexts, seeing those commands bringing to life people's ideas and creations from all over the world, has brought me so many satisfactions, surprises, new questions, ideas, awareness and friendships. I am thankful for that. I think it is important to know the past to avoid making the same mistakes in the future. Sometimes I wish I would have had a chance to talk about this differently, for a different motif. Instead, many times I have come across journalists and common people compromised in their independence. Either they had direct business with Arduino, or simply wanted to avoid upsetting Massimo Banzi. Or there are the close-minded individuals following a cause and refusing to see or hear anything different from what they believe. And then there are the individuals who are just part of the crowd that reproduce what they are told to reproduce. For those others, this document is an invitation to trust your curiosity, to question, to dig deeper in whatever interests you and is important to you as an individual or as a member of a community. I'll see you soon, Hernando. The notion of a \"Sketch\" within the context of writing programs comes from Processing and previously from Design by Numbers (DBN). It was extended by Wiring within the context of prototyping with electronics or \"sketching\" with hardware. \u21a9 Interactive Telecommunications Program at New York University \u21a9 Page 34, ISBN-13: 978-0596510510 ISBN-10: 0596510519, http://www.amazon.com/Making-Things-Talk-Practical-Connecting/dp/0596510519/ref=sr_1_2?ie=UTF8&sr=8-2&keywords=Making+Things+Talk \u21a9 https://groups.google.com/a/arduino.cc/d/msg/developers/HEKecd0qhS4/nADS2jW6DgAJ \u21a9","title":"Thank You!"}]}